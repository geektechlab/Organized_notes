Inside assembly code, you can call an external C function. For example, the following C function has four input parameters and returns a 32-bit result:
	int my_add_c(int x1, int x2, int x3, int x4)
	{
		return (x1 + x2 + x3 + x4);
	}
With the definition in AAPCS, x1=R0, x2=R1, x3=R2, and x4=R3. The result return is stored in R0. We also need to be aware that Caller Saved Registers (e.g., R0 to R3, and R12) can be changed by a C function. So if there is any data in these registers that are needed later, we need to save them first.

In the ARM toolchain, you can call this function using the following code:
	MOVS R0, #0x1 ; First parameter (x1)
	MOVS R1, #0x2 ; Second parameter (x2)
	MOVS R2, #0x3 ; Third parameter (x3)
	MOVS R3, #0x4 ; Fourth parameter (x4)
	IMPORT my_add_c
	BL my_add_c ; Call “my_add_c” function. Result store in R0

Let us reverse the process and implement the My_Add function in assembly, and call it from C code. Inside the assembly code, we need to make sure that if we need to modify callee saved registers (e.g., R4 to R11), we push these registers on to the stack first and then restore them before exiting the function. We also need to save LR if this function is going to call another function because the value of LR will be changed when executing BL or BLX. The My_Add function can be implemented as:
	EXPORT My_Add
	My_Add FUNCTION
	ADDS R0, R0, R1
	ADDS R0, R0, R2
	ADDS R0, R0, R3
	BX LR ; Return result in R0
	ENDFUNC
Inside the C program code, we need to declare My_Add function using extern:
	extern int My_Add(int x1, int x2, int x3, int x4);
	int y;
	y = My_Add(1, 2, 3, 4); // call the My_Add function
If your assembly code needs to access some data variables in your C code, you can also use the “IMPORT” keyword (for ARM toolchain) or “.global” (for GNU toolchain).
