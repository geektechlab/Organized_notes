Cortex-M4 processors supports a number of features:
• Multiple bus interfaces to allow concurrent instructions and data accesses (Harvard bus architecture)
• Bus interface designs based on AMBA (Advanced Microcontroller Bus Architecture), a de facto on-chip bus standard: AHB (AMBA High-performance Bus) Lite protocol for pipelined operations in memory and system bus, and APB (Advanced Peripheral Bus) protocol for communication to debug components
• Support both little endian and big endian memory systems
• Support for unaligned data transfers
• Support exclusive accesses (for semaphore operations in systems with an embedded OS or RTOS)
• Bit addressable memory spaces (bit-band)
• Memory attributes and access permissions for different memory regions
• An optional Memory Protection Unit (MPU). Memory attributes and access permission configurations can be programmed at runtime if the MPU is available.

it is possible to store and execute program code in SRAM and RAM regions, the processor design is not optimized for such operation and requires one extra clock cycle per instruction for each instruction fetch. As a result, the performance is slightly slower when executing program codes though the system bus.

The memory space for the NVIC, MPU, SCB, and various system peripherals is called the System Control Space (SCS).

( figure 6.1 )
( table 6.1 )
( table 6.2 )
( figure 6.2 )

The Cortex-M processors provide generic bus interfaces based on AMBA (Advanced Microcontroller Bus Architecture). The AMBA specification supports several bus protocols. In the Cortex-M3 and Cortex-M4 processors, the AHB (AMBA High-performance Bus) Lite protocol is used for the main bus interfaces, and the APB protocol is used for the Private Peripheral Bus (PPB), which is mainly used for debug components. Additional bus segments based on APB can be added onto the system bus by using additional bus bridge components.

In order to provide better performance, the CODE memory region has separated the bus interfaces from the system bus, as shown in Figure 6.2. In this way, data accesses and instruction fetches can be carried out in parallel. The separate bus arrangement also helps to improve the interrupt responsiveness because during the interrupt handling sequence, stack accesses and reading the vector table in the program image can be carried out at the same time.

In a simple microcontroller design, typically the program memory is connected to the I-CODE and D-CODE bus, and the SRAM and peripherals are connected to the system bus. See Figure 6.3 for a simple arrangement of a Cortex-M3 or Cortex-M4 design.

Peripheral interfaces are usually based on the APB protocol. However, for highperformance peripherals, AHB Lite could be used instead for higher bandwidth and operation speed. Note that the Private Peripheral Bus (PPB) is not used for normal peripherals. This is because:
• PPB is privileged access only
• Only 32-bit accesses are allowed
• PPB write accesses need more clock cycles as there is no write buffer (Strongly Ordered device accesses
• Peripherals in PPB cannot make use of the bit-band feature
• Little endian only, even if the processor is configured to be big endian.
• It is accessible by the processor and debugger, but no other bus master

you can also find multiple bus masters on the internal bus system such as DMA, Ethernet, and USB controllers. Often in the documentation of these products, the terms “bus matrix” or “multi-layer AHB” are mentioned. What this means is that the internal bus system contains an AHB interconnect which allows simultaneous transfers from multiple bus masters to be carried out to different memory or peripherals. ( figure 6.5 )

In the system shown in Figure 6.5, each AHB slave bus segment (which might contain multiple AHB slaves) connected to the AHB interconnect (or bus matrix) can be accessed by multiple bus masters. If two bus masters are trying to access the same bus slave segment at the same time, the internal arbiter in the AHB interconnect will delay the transfer from the lower priority master to allow the transfer fromhigher priority bus master to get through first.

Since there are multiple SRAM blocks in separate AHB slave bus segments, transfers between SRAM blocks and different bus masters can be carried out at the same time. For example, the processor can be using one of the SRAMs for data processing, while the DMA controller could be transferring data between a peripheral and a second SRAM block, and the Ethernet or USB controller could also be using the third SRAM block, all at the same time. This allows applications requiring high-data bandwidth (e.g., hi-speed USB) to work on low-cost microcontrollers, which normally have a relatively low clock frequency.

Different types of memories can be connected to the AHB Lite bus interfaces with suitable memory interface logic. Although the bus size is 32-bit, it is possible to connect memories with other width sizes (e.g., 8 bits, 16 bits, 64 bits, 128 bits, etc.) if appropriate conversion hardware is used.

although the architecture uses names like SRAM and RAM for memory region names, there is no real limitation on what types of memories can be connected to the processors. For example, some memories connected could be PSRAM, SDRAM, DDR DRAM, etc. Also, there is no real limitation on what type of program memories have to be used. For example, the program code could be in flash memory, EPROM, OTP ROM, etc.

The memory size is also flexible. Some of the low-cost Cortex-M microcontrollers might have only 8KB of Flash and 4KB of on-chip SRAM. The only real requirement for data memory (e.g., SRAM) is that the memory must be byte addressable and the memory interface needs to support byte, halfword, and word transfers.

The Cortex-M3 and Cortex-M4 processors support both little endian and big endian memory systems. In normal cases the memory systems are designed to be either little endian only, or big endian only. The Cortex-M3 and Cortex-M4 processors determine the endianness of the memory system at a system reset. Once it is set, the endianness of the memory system cannot be changed until the next system reset.

It is possible to design a Cortex-M3 or Cortex-M4 microcontroller with a big endian memory system. In such case, the first byte of word-size data is stored in the most significant byte of the 32-bit address memory location (Table 6.4).

( IMP
table 6.3, 6.4, 6.5
IMP )

In the Cortex-M processors:
• Instruction fetches are always in little endian.
• Access to 0xE0000000 to 0xE00FFFFF including System Control Space (SCS), debug components, and Private Peripheral Bus (PPB) are always little endian.

Since the memory system is 32-bit (at least from a programmer’s model point of view), a data access that is 32-bit (4 bytes, or word) or 16-bit (2 bytes, or halfword) in size can either be aligned or unaligned. Aligned transfers means the address value is a multiple of the size (in bytes). For example, a word-size aligned transfer can be carried out to address 0x00000000, 0x00000004 . 0x00001000, 0x00001004, ., and so on. Similarly, a half-word size aligned transfer can be carried out to 0x00000000, 0x00000002 . 0x00001000, 0x00001002, ., and so on. An example of an aligned and unaligned data transfer is shown in Figure 6.6.

word transfer must have address bit[1] and bit[0] equal to 0, and a half-word transfer must have an address bit[0] equal to 0. For example, word data can be located at 0x1000 or 0x1004, but it cannot be located at 0x1001, 0x1002, or 0x1003. For half-word data, the address can be 0x1000 or 0x1002, but it cannot be 0x1001. All byte size transfers are aligned.

The Cortex-M3 and Cortex-M4 processors support unaligned data transfers in normal memory accesses (e.g., LDR, LDRH, STR, STRH instructions). There are a number of limitations:
• Unaligned transfers are not supported in Load/Store multiple instructions
• Stack operations (PUSH/POP) must be aligned
• Exclusive accesses (such as LDREX or STREX) must be aligned; otherwise, a fault exception (usage fault) will be triggered
• Unaligned transfers are not supported in bit-band operations. Results will be unpredictable if you attempt to do so.

When unaligned transfers are issued by the processor, they are actually converted into multiple aligned transfers by the processor’s bus interface unit. This conversion is transparent, so application programmers do not have to worry about it. However, when an unaligned transfer takes place, it is broken into several separate aligned transfers and as a result it takes more clock cycles for a single data access and might not be good in situations in which high performance is required.

In most cases, C compilers do not generate unaligned data accesses. It can only happen in:
• Direct manipulation of pointers
• Accessing data structures with “__packed” attributes that contain unaligned data
• Inline/Embedded Assembly code

It is also possible to set up the Cortex-M3 or Cortex-M4 processor so that an exception is triggered when an unaligned transfer takes place. This is done by setting the UNALIGN_TRP (Unaligned Trap) bit in the Configuration Control Register, CCR (address 0xE000ED14) in the System Control Block, SCB. In this way, the Cortex-M3 or Cortex-M4 processor generates usage fault exceptions when unaligned transfers take place. This is useful during software development to test whether an application produces unaligned transfers.
