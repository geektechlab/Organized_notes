Many embedded system products require low power microcontrollers, especially portable products that run on batteries. In addition, low power characteristics can benefit product designs in many ways, including:
• Smaller battery size (smaller product size and lower cost) or longer battery life
• Lower electromagnetic interference (EMI), which allows better wireless communication quality
• Simpler power supply design, avoiding heat dissipation issues
• In some cases it even allows the system to be powered using alternate energy sources (solar panel, energy harvesting from the environment)

the low power microcontroller market has moved on and now, just having low active current and sleep current is often inadequate for low power designs. For example, many of these microcontrollers might need long execution times to complete a processing task, which results in higher overall power consumption. Therefore energy efficiency is equally important. In recent years, the Cortex-M microcontrollers have narrowed the gap between the active current and sleep current (Figure 9.1) and at the same time provide much better performance than many 8-bit and 16-bit microcontrollers. Therefore the Cortex-M microcontrollers are becoming much more attractive for many low power system designers.

Today we see many low power Cortex-M microcontrollers with very sophisticated system features that enable longer battery life. For example:
• Various run modes and sleep modes are available
• Ultra low power Real-Time Clock (RTC), watchdog and Brown-Out Detector (BOD)
• Smart peripherals that can operate while the processor remains in sleep mode
• Flexible clock system control features to allow clock signals for inactive parts of the design to be turned off

In a given application some of these factors could be more important than others. For example, in some battery powered products energy efficiency is the most important factor, while in some industrial control applications the wake-up latency can be critical. There are also different approaches to designing low power systems. Nowadays a lot of embedded systems are designed to be interrupt driven (Figure 9.2). This means that the system stays in sleep mode when there is no request to be processed. When an interrupt request arrives, the processor wakes up and processes the requests, and goes back into sleep mode when the processing is done. Alternatively, if the data processing request is periodic and has a constant duration, and if the data processing latency is not an issue, you could run the system at the slowest possibly clock speed to reduce the power. There is no clear answer to which approach is better, as the choice will be dependent on the data processing requirements of the application, the microcontroller being used, and other factors like the type of power source available.

Sleep modes
	Sleep modes are common features in most microcontroller designs. In the Cortex-M processors, the processors support two sleep modes: Sleep and Deep Sleep (Figure 9.3). These sleep modes can be further extended using device-specific power management features, and in some cases the Deep Sleep mode can be used with advanced chip design technologies such as State Retention Power Gating (SRPG) to further reduce the power. What exactly happens during sleep modes depends on the chip design. In most cases some of the clock signals can be stopped to reduce the power consumption. However, the chip can also be designed such that part of it shuts down to further reduce power. In some cases it is also possible to power down the whole chip completely, and the only way to wake up the system from such power down mode is via a system reset.

The Cortex-M processor provides a register called the System Control Register (SCR) to allow you to select between the Sleep mode and Deep Sleep mode. This register is at address 0xE000ED10, and can be accessed in C programming using the “SCB->SCR” symbol. The details of the SCR bit fields are listed in Table 9.2. Just like most other registers in the System Control Block (SCB), the SCR can only be accessed in privileged state. The SLEEPDEEP bit (bit 2) can be set to enable the Deep Sleep mode. This register can also be used to control other lower power features like Sleep-On-Exit and SEV-OnPend. We will cover these features later in this chapter (in sections 9.2.5 and 9.2.6).

The processor provides two instructions for entering sleep modes: WFI and WFE (see Table 9.3). Both WFI sleep and WFE sleep can be woken up by interrupt requests (depending on the priority of the interrupt, current priority level, and interrupt mask settings; see section 9.2.4). WFE can be woken up by events. This includes a pulse from an event input signal (called RXEV on the processor), and events that happened in the past. Inside the processor, there is a single bit event register that can indicate that an event had occurred previously. This event register can be set by:
• Exception entrance and exit
• When SEV-On-Pend feature is enabled, the event register can be set when an interrupt pending status is changed from 0 to 1
• An External Event Signal (RXEV) from on-chip hardware (this is devicespecific)
• Execution of the SEV (Send Event) instruction
• Debug event (e.g., halting request)
Similar to WFI sleep, during WFE sleep the processor can be woken up by an interrupt request if the interrupt has higher priority than the current level, including the priority of the interrupt masking such as BASEPRI, regardless of the SEV-OnPend feature setting.

In most cases, interrupts (including NMI and SysTick timer interrupts) can be used to wake up the Cortex-M3 or Cortex-M4 microcontrollers from sleep modes. However, you also need to check the microcontroller’s reference manual carefully because some of the sleep modes might turn off clock signals to the NVIC or peripherals, which would then prevent the interrupts (or some of them) from waking up the processor. If the sleep mode is entered using WFI or Sleep-On-Exit, the interrupt request needs to be enabled, and have a higher priority level than the current level for the wake-up to occur (Table 9.4). For example, if the processor enters sleep mode while running an exception handler, or if the BASEPRI register was set before entering sleep mode, then the priority of the incoming interrupt will need to be higher than the current level to wake-up the processor. The PRIMASK wake-up condition is a special feature to allow software code to be used to restore certain system resources between waking up and execution of ISRs. For example, a microcontroller could allow its clocking of Phase Locked Loops (PLL) to be turned off during sleep mode to reduce power, and restore it before executing the ISRs:
(i) Before entering sleep mode, the PRIMASK is set, the clock source switched to crystal clock, and then the PLL is turned off.
(ii) The microcontroller enters sleep mode with the PLL turned off to save power.
(iii) An interrupt request arrives, wakes up the microcontroller, and resumes program execution from the point after the WFI instruction.
(iv) The software code re-enables the PLL and then switches back to using the PLL clock, then clears the PRIMASK and services the interrupt request. More information on using such an arrangement is given in sections 9.4.3 and Figure 9.14.

If the sleep mode is entered using a WFE instruction, the wake-up conditions are slightly different (Table 9.5). A feature called SEVONPEND can be used to generate a wake-up event when an interrupt request arrives and set the pending status, even if the interrupt was disabled or had the same or lower priority than the current level. Note that the SEVONPEND feature generates the wake-up event only when a pending status switches from 0 to 1. If the pending status of the incoming interrupt was already set, it will not generate a wake-up event.
