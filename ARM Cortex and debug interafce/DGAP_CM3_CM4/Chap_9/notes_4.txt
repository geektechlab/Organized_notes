The Cortex-M processors have a small integrated timer called the SysTick (System Tick) timer. It is integrated as a part of the NVIC and can generate the SysTick exception (exception type #15). The SysTick timer is a simple decrement 24-bit timer, and can run on processor clock frequency or from a reference clock frequency (normally an on-chip clock source).

In modern operating systems, a periodic interrupt is needed to ensure that the OS kernel can invoke regularly; for example, for task management and context switching. This enables a processor to handle different tasks in different time slots. The processor design also ensures that the application tasks running at unprivileged level cannot disable this timer; otherwise, these tasks could disable the SysTick timer and lock out the whole system.

The reason for having the timer inside the processor is to help software portability. Since all the Cortex-M processors have the same SysTick timer, an OS written for one Cortex-M3/M4 microcontroller can be reused on other Cortex-M3/M4 microcontrollers. If you do not need an embedded OS in your application, the SysTick timer can be used as a simple timer peripheral for periodic interrupt generation, delay generation, or timing measurement.

The counter inside the SysTick is a 24-bit decrement counter (Figure 9.15). It can decrement using the processor’s clock, or using a reference clock signal (called STCLK in Cortex-M3 or Cortex-M4 Technical Reference Manual from ARM).  An additional register called SysTick Calibration Register is available to allow the on-chip hardware to provide calibration information for the software. the use of SysTick Calibration Register is not required because the CMSIS-Core provides a software variable called “SystemCoreClock” . This variable is set up in the system initialization function “SystemInit()” and is also updated every time the system clock configuration is changed. This software approach is much more flexible then the hardware approach using the SysTick Calibration Register. Details of the SysTick registers are shown in Tables 9.7 to 9.10.

In cases you need to program the SysTick registers directly, and the following sequence is recommended:
1. Disable the SysTick timer by writing 0 to SysTick->CTRL. This step is optional. It is recommended for reusable code because the SysTick could have been enabled previously.
2. Write the new reload value to SysTick->LOAD. The reload value should be the interval value e1.
3. Write to the SysTick Current Value register SysTick->VAL with any value to clear the current value to 0.
4. Write to the SysTick Control and Status register SysTick->CTRL to start the SysTick timer.

Since the SysTick timer counts down to 0, if you want to set the SysTick interval to 1000, you should set the reload value (SysTick->LOAD) to 999. If you want to use the SysTick timer in polling mode, you can use the count flag in the SysTick Control and Status Register (SysTick->CTRL) to determine when the timer reaches zero. For example, you can create a timed delay by setting the SysTick timer to a certain value and waiting until it reaches zero:
	SysTick->CTRL = 0; // Disable SysTick
	SysTick->LOAD = 0xFF; // Count from 255 to 0 (256 cycles)
	SysTick->VAL = 0; // Clear current value as well as count flag
	SysTick->CTRL = 5; // Enable SysTick timer with processor clock
	while ((SysTick->CTRL & 0x00010000)==0);// Wait until count flag is set
	SysTick->CTRL = 0; // Disable SysTick
If you want to schedule the SysTick interrupt for one-shot operation, which triggers in a certain time, you can reduce the reload value by 12 cycles to compensate for the interrupt latency. For example, if we want to have the SysTick handler to execute in 300 clock cycle time:
	volatile int SysTickFired; // A global software flag to indicate SysTickAlarm executed
	SysTick->CTRL = 0; // Disable SysTick
	SysTick->LOAD = (300-12); // Set Reload value Minus 12 because of exception latency
	SysTick->VAL = 0; // Clear current value to 0
	SysTickFired = 0; // Setup software flag to zero
	SysTick->CTRL = 0x7; // Enable SysTick, enable SysTick
	while (SysTickFired == 0); // Wait until software flag is set by SYSTICK handler
Inside the one-shot SysTick Handler, we need to disable the SysTick so that the SysTick exception only triggers once. We might also need to clear the SysTick pending status in case the pending status has been set again when the required processing task takes some time:
	void SysTick_Handler(void) // SYSTICK exception handler
	{
		SysTick->CTRL = 0x0; // Disable SysTick, Execute required processing task
		SCB->ICSR j= 1<<25; // Clear SYSTICK pend bit in case it has been pended again
		SysTickFired++; // Update software flag so that the main program know that SysTick alarm task has been carried out
		return;
	}
If there is another exception happening at the same time, the SysTick exception could be delayed. The SysTick timer can be used for timing measurement. For example, you can measure the duration of a short function using the following code:
	unsigned int start_time, stop_time, cycle_count;
	SysTick->CTRL = 0; // Disable SysTick
	SysTick->LOAD = 0xFFFFFFFF; // Set Reload value to maximum
	SysTick->VAL = 0; // Clear current value to 0
	SysTick->CTRL = 0x5; // Enable SysTick, use processor clock
	while(SysTick->VAL != 0); // Wait until SysTick reloaded
	start_time = SysTick->VAL; // Get start time
	function(); // Execute function to be measured
	stop_time = SysTick->VAL; // Get stop time
	cycle_count = start_time e stop_time;
Since the SysTick is a decrement counter, the value of start_time is larger than stop_time. You might want to include a check for the count_flag at the end of the timing measurement. If the count_flag is set, the duration being measured is longer than 0xFFFFFF clock cycles. In that case you will have to enable the SysTick exception and use the SysTick Handler to count how many times the SysTick counter underflows. The total number of clock cycles will then also include the SysTick exceptions.

The SysTick timer provides a register to provide a calibration value. If this information is available, the lowest 24 bits of the SysTick->CALIB register provide the reload value required to get 10 msec SysTick intervals. However, many microcontrollers do not have this information and the TENMS bit field would read as zero. The CMSIS-Core approach of providing a software variable (SystemCoreClock) for clock frequency information is more flexible and supported by most microcontroller vendors. You can use the bit 31 of the SysTickCalibration register to determine if a reference clock is available.

There are a number of considerations when using the SysTick timer:
• The registers in the SysTick timer can only be accessed when in privileged state.
• The reference clock might not be available in some microcontroller designs.
• When you are using an embedded OS in your application, the SysTick timer will be used by the OS and therefore should not be used by the application tasks.
• The SysTick Timer stops counting when the processor is halted during debugging.
• Depending on the design of the microcontroller, the SysTick timer may stop in certain sleep modes
