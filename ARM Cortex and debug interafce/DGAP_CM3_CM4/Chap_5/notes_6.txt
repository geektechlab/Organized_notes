Overview of enhanced DSP extension in Cortex-M4 Compared to the Cortex-M3 processor, the Cortex-M4 processor supports a number of additional instructions such as:
• Single Instruction, Multiple Data (SIMD)
• Saturating instructions
• Additional multiply and MAC (multiply and accumulate) instructions
• Packing and unpacking instructions
• Optional floating point instructions (if floating unit is available)
These instructions enable the Cortex-M4, a general-purpose processor, to handle real-time digital signal processing (DSP) tasks more efficiently.

First, we’ll have a look at how SIMD data is handled in Cortex-M4 processors. Very often, the data needed to be processed are 16-bit or 8-bit in size. For example, most audio is sampled with ADCs (Analog to Digital Converters) with 16-bit resolution or less, and image pixels are often represented with multiple channels of 8-bit data (e.g., RGB color space). Since the data path inside the processor is 32-bit, we can utilize the data path to handle 2x16-bit data or 4x8-bit data. We also need to consider that sometimes data are to be processed as signed values, and some other imes as unsigned values. So a 32-bit register can be used for four types of SIMD data, as shown in Figure 5.13. In most cases, the data inside a SIMD data set would be the same type (i.e., no mixture of signed and unsigned data, and no mixture of 16-bit and 8-bit data inside a SIMD data set). This allows simpler SIMD instruction set design. In order to handle SIMD data, additional instructions have been added to the ARM Cortex-M architecture, and this is called Enhanced DSP extension. Sometimes this is referred to as the ARMv7E-M architecture.

Since the SIMD data types are not native data types in C language, normally C compilers cannot generate the required DSP instructions in normal C code. In order to make it easier for software developers, intrinsic functions are added in the header files in CMSIS compliant driver libraries. In this way the software developers can access these instructions easily. To make it even better, ARM also provides a DSP library called CMSIS-DSP, which can be used by software developers free of charge.

Multiply and MAC instructions
	There are also a number of various multiply and MAC instructions. In the earlier section of this chapter we covered some of the multiply and MAC instructions that are available in both Cortex-M3 and Cortex-M4 processors. These are given in Table 5.54. Note: In the Cortex-M4, the UMULL, UMLAL, SMULL, and SMLAL instructions have a faster execution time than the Cortex-M3 processor. In addition, the Cortex-M4 processor also supports additional multiply and MAC instructions, and some of them come in multiple forms for selecting lower and upper half-words from input operands, as shown in Table 5.55.

Floating point instructions
	To support floating point operations, the Cortex-M4 also has a number of instructions for floating point data processing as well as floating point date transfers (Table 5.58). These instructions are not available if the Cortex-M4 device you are using does not have a floating point unit. All the floating point instructions start with the letter V. Before using any floating point instruction, you must first enable the floating point unit by setting the CP11, CP10 bit fields in the Co-processor Access Control Register (SCB->CPACR at address 0xE000ED88). This is usually done within the SystemInit(void) function in the device initialization code provided by the microcontroller vendors. Also, the “__FPU_PRESENT” directive in the device header file should be set to 1. In floating point operations, the input operands have to be converted to floating point format. Otherwise we can call this Operand NaN (Not a Number) and some forms of NaN can be used to signal floating point exceptions.

Barrel shifter
	A number of 32-bit Thumb instructions can make use of the barrel shifter feature in the Cortex-M3 and Cortex-M4 processors. For example, if the second operand is an ARM core register (Rm), an optional shift can be applied for some of the data processing instructions before the data processing (Figure 5.14). The shift is optional. So you can write the instruction as following if the shift/rotate operation is not required:
		mnemonic Rd, Rn, Rm
	The barrel shifter operations can be applied as shown in Table 5.59. The barrel shifter is also useful in memory access instructions; for example, in the calculation of an address:
		LDR Rd, [Rn, Rm, LSL #n]
	This is particularly useful in data array handling where the address equals to array_base + (index * 2n ).

Accessing special instructions and special registers in programming
	Some instructions cannot be generated by the C compiler with normal C statements. For example, instructions that trigger sleep (WFI, WFE) and memory barrier (ISB, DSB, and DMB) are such instructions. There are several ways to get around this:
	• Use intrinsic functions provided in the CMSIS (inside CMSIS-Core header files).
	• Use compiler-specific intrinsic functions.
	• Use inline assembler (or embedded assembler in ARM/Keil toolchains) to insert the required instructions.
	• Use compiler specific features such as keywords (e.g., __svc in ARM/Keil toolchains can be used to generate SVC instruction) or idiom recognitions. In some cases we also need to access special registers inside the processor. There are again several options:
		• Use processor access functions provided in CMSIS-Core (Appendix E.4).
		• Use compiler specific feature such as Name Register variable feature in ARM C compiler (section 5.9.5).
		• Insert assembly code using inline assembler or embedded assembler.
		In general, CMSIS-Core functions are preferred because they are portable (compiler independent).

Intrinsic functions
	CMSIS-core intrinsic functions
		Header files in the CMSIS-Core define a set of intrinsic functions for accessing special instructions. These functions can be found in the CMSIS-Core file “core_cmInstr.h” and “core_cm4_simd.h” (for Cortex-M4 SIMD instructions).
	Compiler-specific intrinsic functions
		Using a compiler-specific intrinsic function is just like using a C function, although the definition of the function is built-in inside the C compiler. Very often this method provides the most optimized code, however, the function definitions are tooldependent and therefore the application code will not be portable across different toolchains. Be aware that sometimes the compiler-specific intrinsic functions can have function names which are very similar to those in CMSIS-Core (e.g., void __wfi(void) in the ARM C compiler, and __WFE(void) in CMSIS-Core). Also, the parameter required could be different.

Inline assembler and embedded assembler
	In some cases, you might need to insert assembly instructions in C code using inline assembler; for example, when you want to insert a SVC instruction in gcc. This is also useful for creating optimized code, as it gives you good control of what instruction sequence is generated. However, an application created using inline assembler is toolchain-dependent (less portable).
