The CPACR register allows you to enable or disable the FPU. It is located in address 0xE000ED88 and can be accessed as “SCB->CPACR” in CMSIS-Core. Bit 0 to bit 19 and bit 24 to bit 31 are not implemented and are reserved (Figure 13.12). This programmer’s model of this register provides enable control for up to 16 co-processors. On the Cortex-M4, the FPU is defined as co-processor 10 and 11. Since there is no other co-processor, only CP10 and CP11 are available and both are for the FPU. When programming this register, the settings for CP10 and CP11 must be identical. The encoding for CP10 and CP11 is shown in Table 13.3.

By default CP10 and CP11 are zero after reset. This setting disables the FPU and
allows lower power consumption. Before using FPU, you need to program the
CPACR to enable the FPU first. For example:
	SCB->CPACRj= 0x00F00000; // Enable the floating point unit for full access
This step is typically carried out inside the SystemInit() function provided in the device-specific software package file. SystemInit() is executed by the reset handler.

The floating point register bank contains thirty-two 32-bit registers, which can be organized as sixteen 64-bit double-word registers, as  shown in Figure 13.13. S0 to S15 are caller saved registers.

So if a function A calls a function B, function A must save the contents of these registers (e.g., on the stack) before calling function B because these registers can be changed by the function call (e.g., return result).

S16 to S31 are callee saved registers. So if a function A calls a function B, and function B needs to use more than 16 registers for its calculations, it must save the contents of these registers (e.g., on the stack) first, and must restore these registers from the stack before returning to function A. The initial values of these registers are undefined.

Floating point status and control register (FPSCR)
	The FPSCR holds the arithmetic result flags and sticky status flags, as well as bit fields to control the behavior of the floating point unit (Figure 13.14 and Table 13.4). The N, Z, C, and V flags are updated by floating point comparison operations, as shown in Table 13.5. You can use the results of a floating point compare for conditional branch/ conditional execution by copying the flags to APSR first: VMRS APSR_nzcv, FPSCR ; Copy flags from FPSCR to flags in APSR The bit fields AHP, DN, and FZ are control register bits for special operation modes. By default, all these bits default to 0 and their behavior is compliant with IEEE 754 single precision operation. In normal applications there is no need to modify the settings of the floating point operation control. Do not change these bits if your application requires IEEE 754 compliance. The RMode bit field is for controlling the rounding mode for calculation results. The IEEE 754 standard  defines several rounding modes, as shown in Table 13.6.  The bits IDC, IXC, UFC, OFC, DZC, and IOC are sticky status flags that show any abnormalities (floating point exceptions) during floating point operations. Software  an check these flags after the floating point  perations, and can clear them by writing zero to them. Section 13.5 has more information on floating point exceptions.

Floating point context control register (FPU->FPCCR)
	The Floating Point Context Control Register (FPCCR) allows you to control the behavior of exception handling such as the lazy stacking feature (Table 13.7). It also allows you to access some of the control information. In most applications there is no need to change the setting in this register. By default Automatic FPU context-saving, restoration and lazy stacking are enabled to reduce interrupt latency. You can set ASPEN and LSPEN in the configurations shown in Table 13.8.

Floating point context address register (FPU->FPCAR)
	When an exception takes place and if the current context is active floating point context (the FPU has been used), then the exception stack frame contains registers from the integer register bank (R0eR3, R12, LR, Return Address xPSR) as well as FPU registers (S0eS15, FPSCR). In order to reduce interrupt latency, by default lazy stacking is enabled and it means that the stacking mechanism will reserve the stack space for the FPU registers, but will not actually push these registers onto the stack until it really needs to. The FPCAR register is part of this lazy stacking mechanism. It holds the address of the FPU registers in the stack frame so that the lazy stacking mechanism knows where to push the FPU registers to later. Bits 2 to 0 are not used because the stack frame is double-word aligned (Figure 13.15). When an exception occurs in the lazy stacking scenario, the FPCAR is updated to the address of the FPU S0 register space in the stack frame, as shown in Figure 13.16.

8 Floating point default status control register (FPU-> FPDSCR)
	The FPDSCR register holds the default configuration information (operation modes) for the floating point status control data. The values are copied to the FPSCR at exception entry (Figure 13.17). In a complex system there can be different types of applications running in parallel, each with different FPU configurations (such as rounding mode). In order to allow this, the FPU configuration needs to be switched automatically at exception entry and exception return. The FPFSCR defines the FPU configuration when the exception handlers start, including the OS kernel as most parts of the OS are executing in the Handler mode. For application tasks, each of them have to set up the FPSCR when the tasks start. After that, the configuration will be saved and restored with the FPSCR during context switching.

Media and floating point feature registers (FPU->MVFR0, FPU->MVFR1)
	The FPU has two read-only registers to allow software to determine what instruction features are supported. The values of MVFR0 and MVFR1 are hard coded (Table 13.9). Software can use these registers to determine which floating point features (Figure 13.18) are available. If the bit field is 0, it means the feature is not available. If it is 1 or 2 it is supported. The single-precision field is set to 2 to indicate that apart from normal single-precision calculations, it can also handle floating divide and square root functions.
