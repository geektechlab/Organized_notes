Usually, the starting address (0x00000000) should be boot memory, and it will usually be either flash memory or ROM devices, and the value cannot be changed at run-time. However, in some applications it is useful to be able to modify or define exception vectors at run-time. In order to handle this, the Cortex-M3 and Cortex-M4 processors support a feature called Vector Table Relocation. The Vector Table Relocationfeature provides a programmable register called the Vector Table Offset Register (VTOR). This register defines the starting address of the memory being used as the vector table (Figure 7.11). The VTOR register has a reset value of zero.

Example 1: 32 interrupt sources in the microcontroller The vector table size is (32 (for interrupts) þ16 (for system exception space)) x 4 (bytes for each vector) ¼ 192 (0xC0). Extending it to the next power of two makes it 256 bytes. So the vector table base address can be programmed as 0x00000000,0x00000100, 0x00000200, and so on.

Example 2: 75 interrupt sources in the microcontrollerThe vector table size is (75 (for interrupts) þ16 (for system exception space)) x 4 (bytes for each vector) ¼ 364 (0x16C). Extending it to the next power of two makes it 512 bytes. So the vector table base address can be programmed as 0x00000000, 0x00000200, 0x00000400, and so on. Since the minimum number of interrupt is 1, the minimum vector table alignment is 128 bytes. Therefore the lowest 7 bits of the VTOR are reserved and forced to zero.

The vector table relocation feature can be useful in a number of cases:
1. Devices with boot loader (Figure 7.12)
In some microcontrollers there are multiple program memories: boot ROM and user flash memory. The boot loaders are often pre-programmed in the boot ROM by the microcontroller manufacturer. When the microcontrollers start, they first execute the boot loader code in the bootROM,  and before branching to the user application in the user flash, the VTOR is programmed to point to the starting point of the user flash memory so that the vector table in user flash will be used.

2. Applications load into RAM (Figure 7.13)
In some situations, the application could be loaded from an external source to the RAM and then get executed. It could have been stored on an SD card, or even need to be transferred through a network. In this case, a program stored in onchip memory for booting will need to initialize some hardware, copy the externally stored application into RAM, update the VTOR and then execute the externally stored application.

3. Dynamic changing of vector
In some cases, you might want to have multiple implementations of an interrupt handler in ROM and want to switch between them at different stages of the application. In this case, you can copy the vector table from the program memory to SRAM, and program the VTOR to point to the vector table in SRAM. Since the contents in SRAM can be modified at any time, you can then modify the interrupt vector easily at different stages of the application. In a minimal setup, the vector table needs to provide the initial MSP value and the reset vector for the system to boot up. In addition, depending on your application, you might also need to include the NMI vector, as some devices could have NMI triggered as soon as it started, and the HardFault vector for error handling.

There are various status attributes applicable to each interrupt:
• Each interrupt can either be disabled (default) or enabled
• Each interrupt can either be pending (a request is waiting to be served) or not pending
• Each interrupt can either be in an active (being served) or inactive state To support this, the NVIC contains programmable registers for interrupt enable control, pending status, and read-only active status bits.

Different combinations of these status attributes are possible. For example, while you are serving an interrupt (active), you can disable it, and then a new request for the same interrupt arrives again before the interrupt exits, causing the interrupt to be disabled while active and with a pending status. An interrupt request can be accepted by the processor if:
• The pending status is set,
• The interrupt is enabled, and
• The priority of the interrupt is higher than the current level (including interrupt masking register configuration).

The NVIC is designed to support peripherals that generate pulsed interrupt requests as well as peripherals with high level interrupt request. There is no need to configure any NVIC register to select either interrupt type. For pulsed interrupt requests, the pulse must be at least one clock cycle long. For level triggered interrupts, the peripheral requesting service asserts the request signal until it is cleared by an operation inside the ISR (e.g., write to a register to clear the interrupt request). The request signals received by the NVIC are active high, although the external interrupt request at the I/O pin level could be active low.

The pending status of the interrupts are stored in programmable registers in the NVIC. When an interrupt input of the NVIC is asserted, it causes the pending status of the interrupt to be asserted. The pending status remains high even if the interrupt request is de-asserted. In this way, the NVIC can work with pulsed interrupt requests.

The pending status means it is put into a state of waiting for the processor to serve the interrupt. In some cases, the processor serves the request as soon as an interrupt becomes pending. However, if the processor is already serving another interrupt of higher or equal priority, or if the interrupt is masked by one of the interrupt masking registers, the pended request will remain until the otherinterrupt handler is finished, or when the interrupt masking is cleared.

When the processor starts to process an interrupt request, the pending status of the interrupt is cleared automatically, as shown in Figure 7.14. When the interrupt is being served, it is in the active state. Please note that in the interrupt entry sequence, a number of registers are pushed onto the stack automatically. This is called stacking. Meanwhile, the starting address of the ISR is fetched from the vector table. In many microcontroller designs, the peripherals operate with level-triggered interrupts and therefore the ISR will have to clear the interrupt request manually; for example, by writing to a register in the peripheral. After the interrupt service is completed, the processor carries out an exception return (covered in section 7.7.4). The registers that were automatically stacked are restored and the interrupted program is resumed. The active status of the interrupt is also cleared automatically.

When an interrupt is active, you cannot accept the same interrupt request again until it has completed and terminated with an exception return (sometimes called an exception exit).

The pending status of interrupts are stored in interrupt pending status registers, which are accessible from software code. So you can clear the pending status of an interrupt or set it manually. If an interrupt request arrives when the processor is serving another higher-priority interrupt and the pending status is cleared before the processor starts responding to the pending request, the request is cancelled and will not be served (Figure 7.15).

If a peripheral continuously asserts the interrupt request, and the software attempts to clear the pending status, the pending status will be set again (Figure 7.16).

If an interrupt source continues to assert its interrupt request after it has been serviced, the interrupt will be in the pending state again and will get serviced by the processor again. This is shown in Figure 7.17.

For pulsed interrupt requests, if an interrupt request signal is pulsed several times before the processor starts processing, the request will be treated as one single interrupt request, as illustrated in Figure 7.18.

The pending status of an interrupt can be set again when it is being served. For example, in Figure 7.19 a new interrupt request arrived while the previous request was still being served, and this caused a new pending status and therefore the processor needs to serve this interrupt again after the first ISR is completed.

Please note that the pending status of an interrupt can be set even when the interrupt is disabled. In this case, when the interrupt is enabled later, it can be triggered and get served. In some cases this might not be desirable, so in this case you will have to clear the pending status manually before enabling the interrupt in the NVIC.

In general the NMI request behavior is the same as interrupts. Unless an NMI handler is already running, or the processor is halted or in a locked up state, a NMI request will be executed almost immediately because it has the highest priority  and cannot be disabled.

The processor accepts an exception if the following conditions are met:
• The processor is running (not halted or in reset state)
• The exception is enabled (with special cases for NMI and HardFault exceptions, which are always enabled)
• The exception has higher priority than the current priority level
• The exception is not blocked by an exception masking register (e.g., PRIMASK) Note that for the SVC exception, if the SVC instruction is accidentally used in an exception handler that has the same or higher priority than the SVC exception itself, it will cause the HardFault exception handler to execute.

An exception entrance sequence contains several operations:
• Stacking of a number of registers, including return address to the currently selected stack. This enables an exception handler to be written as a normal C function. If the processor was in Thread mode and was using the Process Stack Pointer (PSP), the stack area pointed to by the PSP will be used for this stacking. Otherwise the stack area pointed to by the Main Stack Pointer (MSP) will be used.
• Fetching the exception vector (starting address of the exception handler/ISR). This can happen in parallel to the stacking operation to reduce latency.
• Fetching the instructions for the exception handler to be executed. After the starting address of the exception handler is determined, the instructions can be fetched.
• Update of various NVIC registers and core registers. This includes the pending status and active status of the exception, and registers in the processor core including the Program Status Register (PSR), Link Register (LR), Program Counter (PC), and Stack Pointer (SP). Depending on which stack was used for stacking, either the MSP or PSP value would be adjusted accordingly just before the exception handler starts. The PC is also updated to the starting address of the exception handler and the Link Register (LR) is updated with a special value called EXC_RETURN. This value is 32-bit, and the upper 27 bits are set to 1. Some of the lower 5 bits are used to hold status information about the exception sequence (e.g., which stack was used for stacking). This value is to be used in the exception return.

Within the exception handler, you can carry out services for the peripheral that requires service. The processor is in Handler mode when executing an exception handler. In Handler mode:
• The Main Stack Pointer (MSP) is used for stack operations
• The processor is executing in privileged access level If a higher-priority exception arrives during this stage, the new interrupt will be accepted, and the currently executing handler will be suspended and pre-empted by the higher-priority handler. This is called a nested exception. If another exception with the same or lower priority arrives during this stage, the newly arrived exception will stay in the pending state and will be serviced when the current exception handler is completed. At the end of the exception handler, the program code executes a return that causes the EXC_RETURN value to be loaded into the Program Counter (PC). This triggers the exception return mechanism.

In ARM Cortex-M processors, the exception return mechanism is triggered using a special return address called EXC_RETURN. This value is generated at exception entrance and is stored in the Link Register (LR). When this value is written to the PC with one of the allowed exception return instructions, it triggers the exception return sequence. The exception return can be generated by the instructions shown in Table 7.8. When the exception return mechanism is triggered, the processor accesses the previously stacked register values in the stack memory during exception entrance and restores them back to the register bank. This is called unstacking. In addition, a number of NVIC registers (e.g., active status) and registers in the processor core (e.g., PSR, SP, CONTROL) will be updated. In parallel to the unstacking operation, the processor can start fetching the instructions of the previously interrupted program to allow the program to resume operation as soon as possible. The use of the EXC_RETURN value for triggering exception returns allows exception handlers (including Interrupt Service Routines) to be written as a normal C function/subroutine. In code generation, the C compiler handles the EXC_RETURN value in LR as a normal return address. Due to the EXC_RETURN mechanism, it is impossible to have a normal function return to address 0xF0000000 to 0xFFFFFFFF. However, since the architecture specified that this address range cannot be used for program code (has the Execute Never (XN) memory attribute), it does not create any confusion.
