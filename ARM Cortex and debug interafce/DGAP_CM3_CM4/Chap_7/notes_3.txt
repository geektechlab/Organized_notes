There are a number of registers in the NVIC for interrupt control (exception type 16 up to 255). These registers are located in the System Control Space (SCS) address range. Table 7.9 shows a summary of these registers. All of these registers, with the exception of the Software Trigger Interrupt Register (STIR), can only be accessed in privileged access level. By default STIR can only be accessed in privileged access level, but can be configured to be accessed in unprivileged access level. By default, after a system reset:
• All interrupts are disabled (enable bit ¼ 0)
• All interrupts have priority level of 0 (highest programmable level)
• All interrupt pending statuses are cleared

The Interrupt Enable register is programmed through two addresses. To set the enable bit, you need to write to the NVIC->ISER[n] register address; to clear the enable bit, you need to write to the NVIC->ICER[n] register address. In this way, enabling or disabling an interrupt will not affect other interrupt enable states. The ISER/ICER registers are 32-bits wide; each bit represents one interrupt input. As there could be more than 32 external interrupts in the Cortex-M3 or CortexM4 processors, you often find more than one ISER and ICER register e for example, NVIC->ISER[0], NVIC->ISER[1], and so on (Table 7.10). Only the enable bits for interrupts that exist are implemented. So, if you have only 32 interrupt inputs, you will only have ISER and ICER.

If an interrupt takes place but cannot be executed immediately (for instance, if another higher-priority interrupt handler is running), it will be pended. The interrupt-pending status can be accessed through the Interrupt Set Pending (NVIC->ISPR[n]) and Interrupt Clear Pending (NVIC->ICPR[n]) registers. Similarly to the enable registers, the pending status controls might contain more than one register if there are more than 32 external interrupt inputs. The values of the pending status registers can be changed by software, so you can cancel a current pended exception through the NVIC->ICPR[n] register, or generate software interrupts through the NVIC->ISPR[n] register (Table 7.11).

Each external interrupt has an active status bit. When the processor starts the interrupt handler, that bit is set to 1 and cleared when the interrupt return is executed. However, during an Interrupt Service Routine (ISR) execution, a higher-priority interrupt might occur and cause pre-emption. During this period, although the processor is executing another interrupt handler, the previous interrupt is still defined as active. Although the IPSR (Figure 4.5) indicates the currently executing exception services, it cannot tell you whether an exception is active when there is a nested exception. The Interrupt Active Status registers are 32 bits, but can also be accessed using half-word or byte-size transfers. If there are more than 32 external interrupts, there will be more than one active register. The active status registers for external interrupts are read-only (Table 7.12).

Each interrupt has an associated priority-level register, which has a maximum width of 8 bits and a minimum width of 3 bits. As described in section 7.4, each register can be further divided into group priority level and sub-priority level based on priority group settings. The priority-level registers can be accessed as byte, half-word, or word. The number of priority-level registers depends on how many external interrupts the chip contains (Table 7.13). If you need to determine the number of priority levels available in the NVIC, you can use the “__NVIC_PRIO_BITS” directive provided in the CMSIS-Core header file provided by your microcontroller supplier. Alternatively you can write 0xFF to one of the Interrupt Priority-Level registers and read back to see how many bits are set. In the case that the device implemented eight levels of interrupt priority levels (3-bits), the read back value would be 0xE0.

Besides using NVIC-ISPR[n] registers, you can also use a Software Trigger Interrupt Register (NVIC->STIR, see Table 7.14) to trigger an interrupt using software. For example, you can generate interrupt #3 by writing the following code in C: NVIC->STIR = 3; Unlike NVIC->ISPR[n], which can only be accessed in privileged access level, you can enable unprivileged program code to trigger a software interrupt by setting bit 1 (USERSETMPEND) of the Configuration Control Register (address 0xE000ED14). By default the USERSETMPEND is cleared, which means only privileged code can use NVIC->STIR. Similar to NVIC->ISPR[n], NVIC->STIR cannot be used to trigger system exceptions like NMI, SysTick, etc. Additional registers in the System Control Block (SCB) data structure are available for systemexception management.

The NVIC also have an Interrupt Controller Type Register in address 0xE000E004. This read-only register gives the number of interrupt inputs supported by the NVIC in granularities of 32 (Table 7.15). In the CMSIS device-driver library, you can access this read-only register using SCnSCB->ICTR. (SCnSCB refers to “System Control Registers not in SCB”). While the Interrupt Controller Type register can give you an approximate number of interrupts available, you can obtain the exact number of interrupts available by writing to interrupt control registers such as interrupt enable/pending registers while the PRIMASK register is set (to disable the interrupt from taking place), and read back to see exactly how many bits are implemented in the interrupt enable/pending registers.
