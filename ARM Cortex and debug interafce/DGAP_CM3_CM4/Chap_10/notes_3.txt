To demonstrate context-switching operation in a real example, we use a simple task scheduler that switches between four tasks in a round-robin arrangement. The first example assumes that there are no floating point registers, and therefore can be used on the Cortex-M3 processor as well as the Cortex-M4 processor without the floating point unit. This example code is developed with the STM32F4 Discovery Kit, which provides four LEDs. Each task toggles one of the LEDs at different speeds. The context-switching operation is carried out by the PendSV exception handler. Since the exception sequence already saved registers R0-R3, R12, LR, return address (PC), and xPSR, the PendSV only needs to store R4-R11 to the process stack (Figure 10.10).

( understand code )

Using this method, the PSP is set up to task 0 before task 0 is executed. It is not strictly required to initialize the stack frame for task 0 (at the stack setup steps after LED_initialize()), but we included the task 0 initialization code there so that all the tasks set up have the same look and feel. With this simple design, you can either run all tasks in unprivileged state by setting CONTROL to 3, or run all tasks in privileged state by setting CONTROL to 2.

The execution of ISB is a recommendation in the architecture. For existing Cortex-M3 and Cortex-M4 processors, omitting the ISB does not cause any error.

This example can be further extended to support context saving of registers in the Cortex-M4 floating point unit. To do this, we need to extend the registers being stacked in the context-switching sequence to include EXC_RETURN, because bit 4 of this value indicates when the exception stack frame contains floating point registers. To enhance the design further, we also include the CONTROL register for each task so that you can run some of the tasks in privileged state and some in unprivileged state. The stacking of floating point registers is conditional, and based on whether the task is a floating point operation, as indicated by bit 4 of the EXC_RETURN value (Figure 10.11).

In this example, we also demonstrate a different way to start the first task. Instead of running the OS initialization step in Thread, we can run this in the SVC handler  and use an exception return to switch into the first task. The SVC mechanism shown in the example is  using __svc keyword, a feature in the ARM C compiler toolchain.

The enhanced example has more registers saved to the process stack, and also the stack frame initialization has additional values to setup. However, the context switching is still very straightforward to implement. The use of SVC for starting this little OS example added a small complexity because the value of EXC_RETURN needs to be controllable. That is why we created the svc_exc_return variable. By setting this variable to 0xFFFFFFFD at the end of the SVC handler, the SVC handler returns to Thread mode using PSP. As a result, the stack frame information that we write to task 0 was used and this caused task 0 to start. Note: return from SVC to task 0 does not go through PendSV, so only eight words are unstacked. As a result the PSP is not set to the lowest word of the stack frame created.
