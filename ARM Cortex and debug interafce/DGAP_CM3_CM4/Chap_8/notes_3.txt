The term interrupt latency refers to the delay from the start of the interrupt request to the start of the interrupt handler execution. In the Cortex-M3 and Cortex-M4 processors, if the memory system has zero latency, and provided that the bus system design allows vector fetch and stacking to happen at the same time, the interrupt latency is only 12 clock cycles. This includes stacking the registers, vector fetch, and fetching instructions for the interrupt handler. However, in many cases the latency can be higher due to wait states in the memory system. If the processor is carrying out a memory transfer, including buffered write operations, the outstanding transfer has to be completed before the exception sequence starts. The duration of the execution sequence also depends on memory access speed.

Besides wait states generated by the memory devices or peripherals, there can be other situations that can increase the interrupt latency:
• The processor was serving another exception at the same or higher priority.
• Debugger accesses to the memory system.
• The processor was carrying out an unaligned transfer. From the processor point of view, this might be a single access, but at the bus level it takes multiple cycles, as the bus interface needs to convert the unaligned transfer into multiple aligned transfers.
• The processor was carrying out a write to bit-band alias. The internal bus system converts this into a read-modify-write sequence, which takes at least two cycles.
• The Cortex-M3 and Cortex-M4 processors use a number of methods to reduce the latency of servicing interrupts. For instance, most of the operations such as nested interrupt handling are automatically handled by the processor hardware. Also you don’t need to use software code to determine which interrupt to service, or use software code to locate the starting addresses of ISRs.

Some of the instructions take multiple clock cycles to execute. If an interrupt request arrives when the processor is executing a multiple cycle instruction, such as an integer divide, the instruction could be abandoned and restarted after the interrupt handler completes. This behavior also applies to load double-word (LDRD) and store double-word (STRD) instructions.

In addition, the Cortex-M3 and Cortex-M4 processors allow exceptions to be taken in the middle of Multiple Load and Store instructions (LDM/STM) and stack push/pop instructions. If one of these LDM/STM/PUSH/POP instructions is executing when the interrupt request arrives, the current memory accesses will be completed, and the next register number will be saved in the stacked xPSR (Interrupt-Continuable Instruction [ICI] bits). After the exception handler completes, the multiple load/store/push/pop will resume from the point at which the transfer stopped. The same approach applies to floating point memory access instructions (i.e. VLDM, VSTM, VPUSH and VPOP) for Cortex-M4 processor with floating point unit. There is a corner case: If the multiple load/store/push/pop instruction being interrupted is part of an IF-THEN (IT) instruction block, the instruction will be canceled and restarted when the interrupt is completed. This is because the ICI bits and IT execution status bits share the same space in the Execution Program Status Register (EPSR).

For Cortex-M4 processor with floating point unit, if the interrupt request arrive when the processor is executing VSQRT (floating point square root) or VDIV (floating point divide), the floating point instruction execution continues in parallel with the stacking operation.

When an exception takes place but the processor is handling another exception of the same or higher priority, the exception will enter the pending state. When the processor finishes executing the current exception handler, it can then proceed to process the pending exception/interrupt request. Instead of restoring the registers back from the stack (unstacking) and then pushing them on to the stack again (stacking), the processor skips the unstacking and stacking steps and enters the exception handler of the pended exception as soon as possible (Figure 8.12). In this way, the timing gap between the two exception handlers is considerably reduced. For a memory system with no-wait state, the tail-chain latency is only six clock cycles.

The tail chaining optimization also makes the system more energy efficient because it reduces the amount of stack memory accesses, and each memory transfer consumes energy.

When an exception takes place, the processor accepts the exception request and starts the stacking operation. If during this stacking operation another exception of higher priority takes place, the higher priority late arrival exception will be serviced first.

For example, if Exception #1 (lower priority) takes place a few cycles before Exception #2 (higher priority), the processor will behave as shown in Figure 8.13, such that Handler #2 is executed as soon as the stacking completes.

If an exception request arrives during the unstacking process of another exception handler that has just finished, the unstacking operation would be abandoned and the vector fetch and instruction fetch for the next exception service begins. This optimization is called pop pre-emption. (Figure 8.14)
