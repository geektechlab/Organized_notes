Data watchpoint and trace (DWT) unit

( can be used in interrupt latency topic )

The DWT contains up to four hardware comparators for data watchpoint generation,
data trace, debug event generation, and a number of profiling counters. The DWT
has many different functions, as discussed in the following sections.
Debug event generation
• Generate Debug event (such as data watchpoint event, PC matching event) that
can be used to halt the processor or invoke Debug Monitor exception.
• The Debug event generated can also be used by the ETM for trace start/stop
control, or generate the ETM trigger (cause the ETM to emit a trigger packet in
the instruction trace stream).
Data trace
• Generate data trace packets when the comparator matches. The packets can
contain data values, data addresses, or current PC values.
PC sampling
• Generate periodic PC sampling to the trace stream for profiling usage.
• Allow the debugger to sample PC value by reading a register called PCSR (PC
Sampling register) periodically. This allows some basic profiling to be carried
out even if the hardware does not support trace capture.
Profiling
• A number of counters (mostly 8-bit) are available for counting various types
of cycle information. When the counter underflows, a trace packet is generated so
that by combining the trace packet collected and the counter values, the debugger
can determine the activities of the processor over a period of time (e.g., how
many cycles were spent in memory accesses, sleep, exception overhead, etc.).
Exception trace
• The DWT can generate a trace packet at exception entrance and exit, allowing
you to determine which exceptions have occurred, which is very useful for
debug. When combining timestamping packets in the ITM, it can even allow you
to measure how much time the processor spent on each exception.

Before accessing any DWT registers or using any DWT features, the TRCENA
bit (Trace Enable) in CoreDebug->DEMCR (see Table 14.5) must be set to 1. To use trace functions (including profiling trace, data trace, etc.), the DWTENA bit in the
ITM Trace Control Register must also be set to 1 (see appendix G, Table G.27).
Each of the comparators has three registers, which are as follows:
• DWT_COMP (comparator registers)
• DWT_MASK register
• DWT_FUNCTION register
The comparators have a 32-bit compare value that can be used for comparing:
• Data address
• PC value
• DWT_CYCCNT value (comparator 0 only)
• Data value (comparator 1 only)

The DWT_MASK register determines the bit compare mask to be used during
the comparison.The DWT_FUNCTION registers determine the function of the comparators. To
avoid unexpected behavior, the MASK register and the COMP register should be
programmed before this register is set. If the comparator’s function is to be changed,
you should disable the comparator by setting FUNCTION to 0 (disable), then program the MASK and COMP registers, and then enable the FUNCTION register in
the last step.
In systems with multiple processors, the debug event generated by the comparators can be linked to other processor systems to trigger debug operations in other
processors.
The rest of the DWT counters are typically used for profiling the application
code. They can be programmed to emit events (in the form of trace packets) when the counter overflows. One typical application is to use the CYCCNT register
to count the number of clock cycles required for a specific task, for benchmarking
purposes. Although most of these profiling counters are only 8 bits wide, when
combining the counter value and the trace packet information emitted, the counting
range is unlimited.

The counters can also be used for calculating CPI (Cycle-Per-Instruction). For
example, the number of instructions executed over a period of time can be measured
using:
Total instruction executed = Total cycle count - CPICNT - EXCCNT - SLEEPCNT - LSUCNT + FOLDCNT
Note: FOLDCNT is for folded instruction cycles, which indicate an instruction
execution such as IT has overlapped with the execution cycle of another instruction.
The profiling counters are stopped when the processor is halted.
PC sampling is a simple method for basic profiling. The DWT supports PC sampling in two ways:
• Output PC samples via the trace interface periodically
• Debugger can read the PC Sample Register (DWT->PCSR) periodically

By sampling the PC value over a long period of execution time, it is possible to
estimate:
• which functions are executed (it could miss some functions if they are short, but
some of those can be determined by analysis of the execution path). In this way it
helps to identify parts of the program that are never tested.
• how much time is spent on which functions. Over a long period of sampling, you
can estimate statistically how much (in terms of percentage) execution time is
spent on a given function.
