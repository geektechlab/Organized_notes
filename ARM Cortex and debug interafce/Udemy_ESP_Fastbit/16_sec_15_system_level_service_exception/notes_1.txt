ARM Cortex Mx processor supports 2 important system-level service exceptions. One is SVC and another one is pendSV. SVC stands for Supervisory call and pendSV stands for Pendable Service. Supervisory calls are typically used to request privileged operations or access to system resources from an operating system. SVC exception is mainly used in an OS environment. When you are using an application which has a embedded OS, or real time operating system, or a simple scheduler, in those cases we use SVC and pendSV system exceptions.

For example, a less privileged user task can trigger SVC exception to get system level services such as like you know accessing device drivers, or accessing peripherals, accessing some restricted memory locations or something like that. It can request such services from the kernel of the operating system. And PendSV is mainly used in in an OS environment to carry out context switching between two or more tasks when no other exceptions are active in the system. PendSV is mainly used in multi task system, where you have multiple task and the scheduler. The scheduler takes the help of PendSV system exception to carry out context switching.

SVC is a eleventh exception in the exception model of the processor and pendSVs a exception number is 14. SVC exception is triggered by SVC instruction. SVC instruction is a thumb ISA instruction which causes SVC exception. In an RTOS scenario, user tasks can execute SVC instruction with an associated argument to make supervisory calls to seek privileged resources from the kernel. Basically, SVC instruction is used for the user task or less privileged task to ask the kernel to get some services. Like you can implement a system call layer by using SVC instruction. Unprivileged user task may use the SVC instruction to change the processor mode to privileged mode. To access privileged resources like peripherals.SVC instruction is always used along with a number, that what we call as SVC number or an SVC argument. That number can be used to identify the request type by the kernel code. So,the SVC handler executes right after the SVC instruction is executed. There is no delay in between unless a higher priority exception arrives at the same time.

Let's consider this scenario. This is an application, where it has two parts. First part is the user level code or user task. And this application also has another part that is kernel level code. So, this is a case of an embedded OS application let's say. Basically what happens is, user level code or user task they run in thread mode,isn't it? And the kernel make grant unprivileged access levels to them. Otherwise, user task may change any configuration of the system level registers, and they can trample the security of the system. Isn't it? That's why, user task would be running in unprivileged access level. After that, second part is as I said it's a kernel level code and it runs with a privileged access level. Because, it can change any configuration of the system level registers of the processor. And after that there is a privileged resource. Let's say, this case display. Now let's say user task wants to write some data to the display. User task cannot touch the privileged resource just like that.

The privileged resource in this case display is maintained or it is taken care by it's registers. There will be configuration register, there will be data register, something like that. So, user level code should not be allowed to change those configuration or writing to data register just like that. Otherwise, user task may corrupt the display.That's a reason user task should make a request to the kernel level code, and the way it does is using SVC instruction. A user level task executes SVC instruction with an argument 1, and that actually triggers the kernel level code. And now the kernel level code runs which is a SVC request handler and this handler extracts the SVC number, that is 1 and then match that number to the service. In this case, let's say write. And data which is given by the user task will be return to the display. In this way the kernel level code guards the privileged resource, that is display. User task cannot touch the privileged resource just like that. That is not allowed. Because, the kernel code will restrict access to display using the memory protection unit let's say.If there is a memory protection unit in the processor, then the kernel code may take the help of memory protection unit to restrict access to the address range of this peripheral registers.So, it can do that.

In that case, if a user task tries to change any configuration or tries to write data into the display registers then there will be a fault. In this case, memory manage fault will be triggered and after that kernel may kill that user task. Like that you can bring security to your application which increases the robustness of the application.

How do you trigger the SVC exception? There are two ways to trigger it. The most common one is direct execution of the SVC instruction with an immediate value. For example, SVC #0x4. Here, 0x4 is called as an SVC number or SVC argument. And you have to execute SVC instruction in 'C' program using inline assembly code. Using SVC instruction is very efficient in terms of latency. Because, SVC exception will be triggered immediately. There is also one more method that is not common, that is setting the exception pending bit in "System Handler Control and State Register" of the processor.
