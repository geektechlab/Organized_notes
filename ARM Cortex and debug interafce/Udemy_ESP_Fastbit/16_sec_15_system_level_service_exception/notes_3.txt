fhPendSV Exception is an exception type 14 and has a programmable priority level. the exception number is 14. This exception is triggered by setting its pending status by writing to the "interrupt control and state register" of the processor. You don't have any instruction to trigger a pendSV exception. You have to pend this exception in the interrupt control and state register of the processor. Triggering a pendSV system exception is a way of invoking the pre-emptive kernel to carry out the context switch in an OS environment. That's a major use case of the pendSV.

If you are using some standalone application without any kernel or scheduling things, then you need not to use this exception. Majorly it is used in an OS environment. So, in an OS environment, PendSV handler is set to the lowest priority level, and the PendSV handler carries out the context switch operation. Context switching is one of the key operation in OS design, scheduler does a context switching. That operations are carried out by the pendSV handler. That's a major use case.

Typically this exception is triggered inside a higher priority exception, and it gets executed when the higher priority handler finishes. Using this characteristic, we can schedule the PendSV exception handler to be executed after all the other interrupt processing task are done. Because, generally we keep the priority of PendSV as lowest possible. That's a reason in an OS noisy environment, after all the IRQs are executed or finished in the pendSV handler will run.This is very helpful for a context switching operation which is a crucial operation in various  OS design and using pendSV in context switching will be more efficient in an interrupt noisy environment. Because, in an interrupt noisy environment, we need to delay the context switching until all the IRQs are executed. Context switching is delayed until all the active ISRs are executed or finished. Generally, that is the design a thing which is followed in OS or scheduler design. In that case, we can use pendSV to carry out the context switching after all the IRQs are executed or finished.

What exactly the context switch? Context switch means, saving the context of old task and retrieving the context of the next task which needs to be scheduled on the processor. Let's consider a scenario of multiple task. There are 2 task. task A and Task B. Task A is currently running on the processor. After some time you want to remove this Task A from the processor and you have to scheduled Task B. For this you can use a scheduler. What you can do is, you can make a scheduler to run at constant or fix duration. Let's say, 1 millisecond. For every 1 millisecond the scheduler code runs. This is actually a kernel code or it is a code which is part of the kernel. So, the scheduler runs for every 1 milliseconds, let's assume that. When it runs, what it does is, it saves the context of the currently running task onto the stack memory, and then it retrieves the context of the next task which is in the ready list. It makes that task to run on the CPU. Here it saves, saves the context of old task and here it retrieves the context of the next task. Which is going to run on the processor. This operation we call it as a context switch, that is generally carried out by the scheduler.

The OS code runs on each systick timer exception and decides to schedule different task. Let's understand the scenario of pendSV in context switching. So, one possible scenario, how you can use pendSV in context switching. Let's say you have a task or user task running in the thread mode. That is a thread mode code and a systick timeout happens. Now, it is a time to run the scheduler. Scheduler runs, scheduler code is nothing but a systick handler. What scheduler code does is, it pends the PendSV. It doesn't carry out context switch actually. I will tell you why, it doesn't carry out the context switch. I mean, it can carry out the context switch, but generally we don't do context switch in the timer handler.

The systick handler or the scheduler just pends the PendSV. When that systick handler exists if there are no interrupts in the system, then pendSV handler runs. Because, pendSV exception is configured for the lowest possible priority. So, if there are no active interrupts, then pendSV will run. In the pendSV context switch will be done. Context switch means, context of this task will be saved to the stack and context of the next task will be retrieved from the stack.  And pendSV handler schedulesor it makes the next task to run on the CPU. The Task B executes. When  Task B is executing some other interrupt happens. Let's say, a button interrupt or a peripheral interrupt. The ISR executes. ISR is a handler code it can always preempt the thread mode code. Now, ISR is executing. And suddenly what happens is, this timeout happens, that is systick timeout happens. Systick will preempt that ISR, this is a interrupt nesting. This is a time where the timeout happened.This is a fixed interval timeout. Whenever systick times out, scheduler runs. When the scheduler runs here and it again pends the pendSV. Just pends the pendSV and exits here. When this scheduler exits, this ISR continues here. When ISR finishes ISR exits here, and when this ISR is finished the pendSV handler will be invoked and it will carry out the context switch. Here, you can see that the context switch didn't delay this ISR execution, isn't it ? You can consider this as a interrupt noisy environment, there is a interrupt actually. But the processing of that interrupt is not delayed by the context switch. Because, when the scheduler ran it just pends the pendSV it didn't do any context switch, it immediately returned to the ISR. After ISR is finished, the pendSV invoked and it does the context switch. That's why, when all the interrupts service routines are finished, then only pendSV handler will be invoked and context switch will be taken care. After that Task A continuous. That's a use case of pendSV how we can use in context switching operation.

we generally don't do context switch in the systick handler. We always do that in the pendSV handler by pending the pendSV in the systick handler. This slide explains the scenario of context switching without pendSV. Let's say, you have a task here. Task A is executing and systick timeout happens, systick handler runs you do the context which here itself. Of course, you can do that . When you do that what happens? Task B is scheduled. You do all the scheduling thing, that is saving the context of Task A and retrieving the context of Task B everything you do in this systick handler. If you do that, that Task B resumes here. Task B is running and interrupt triggers, some interrupt. As I said, it could be a button interrupt or a UART interrupt or whatever it is, and the ISR runs. ISR is unfinished or it is just executed half. Here, the systick timeout happens. Now again the scheduler runs. When the scheduler runs according to your design, you do all the context switch here itself. You would do the context switch here, that means you retrieve the context of the next task and you make that task to schedule onto the processor. What is a task? Task is a thread mode code. That means, you are attempting to come to thread mode by keeping an unfinished ISR. This is a fault, that is not allowed in ARM Cortex Mx processor. You cannot return to thread mode by keeping unfinished handler code, that is in this case some ISR handler.  That's why, processor will not allow you to come to thread mode rather it raises a fault. So, the exact fault is usage fault. That's a reason why we don't do context switch operation inside the systick handler, rather we postpone it to the pendSV handler. The better technique is, instead of doing context switch here, just pend the pendSV. Then execute the ISR and then when ISR exits, pendSV runs, and it does the context switch.

Let's understand some other use cases of pendSV. You can use pendSV for offloading interrupt processing. If a higher priority handler is doing time-consuming work, then other lower priority interrupts may suffer and systems responsiveness may reduce. This can be solved using a combination of ISR and pendSV handler. Offloading interrupt processing using pendSV. Interrupts maybe serviced in 2 halves. So, the first half is the time critical part that needs to be executed as a part of ISR execution. Second half is called as bottom half, is basically delayed execution  where rest of the time-consuming work will be done. So,PendSV can be used in these cases, to handle the second half execution by triggering it in the first half. You have a Task A running. Let's say, an interrupt triggers, and let's say IRQ0 and ISR of the IRQ0 runs, it supposed to do some time consuming work. If it is keep doing time consuming work then other interrupts may get delayed and other lower priority interrupts may get delayed. What it does is, it does the first half processing that is time critical processing in ISR 0. It just finishes time critical  work in the ISR. Then it just pend the pendSV and exits. In that case, what happens is, when there are no active interrupts or when there are no active ISRs executing in the system, pendSV handler will run and it can carry out the non-time critical bottom half processing. That's how you can a process the second half using the pendSV. That makes this ISR very short, isn't it? It does the time critical thing, a pends the pendSV and exits. When pendSV runs it does all bottom half processing. When it is doing any bottom half processing, if any interrupt triggers that interrupt can pre-empt this pendSV. Because, pendSV is always configure for the lowest priority. IRQ1 in this case can preempt this pendSV and ISR1 can run. When this finishes again pendSV resumes, when pendSV finishes it can return to the thread mode. Here we can see that, the work of the ISR is stretched up to here. It allows other ISRs to run in between. That's another use case of pendSV, which is used for offloading interrupt processing.

1) PendSV is used for preventing interrupt handler to thread code switching. When some interrupt is running and systick handler runs and comes back and has to switch task but can't because if handler to thread mode switch happens, ARM treats it as a fault. So, systick just pends PendSV and once original interrupt handler completes, it switches task. PendSV is lowest priority interrupt.
2) PendSV can devide interrupt in two parts ( top half and bottom half ? ). So, high priority task can be done interrupt handler itself and low priority tasks can be done by PendSV later. So, more interrupts can be served in a time because handler will be short and nested low priority inetrrupts will be blocked for less time. Also since PendSV is lowest priority interrupt, it's handler can be preemted by any inteerupt.
