Cortex-M processors are designed with features that support OS operations. If TrustZone®
is not implemented, the following features are available in the majority of Cortex-M processors, including the Cortex-M23 and Cortex-M33:
• SysTick timer: A simple timer inside the processor for generating periodic interrupt events
for OS operations (i.e., System Ticks). It enables the OS to support Cortex-M processors outof-the-box. Software developers can also use the SysTick timer for other timing purposes if
the SysTick is not being used by an OS, that is, either the system does not have an OS, or the
OS uses another device specific timer peripheral for the system tick interrupt.
• Banked stack pointer: The stack pointer is banked between the Main Stack Pointer (MSP)
and the Process Stack Pointer (PSP)
	- The MSP is used for booting up, system initialization, and for exception handlers (including the OS Kernel).
	-The PSP is used by application tasks.
• Stack limit checking: This detects stack overflow errors and is a new feature in Armv8-M.
(Note: This feature is not available in the Cortex-M23 processor without TrustZone and,
when TrustZone is included, only the Secure stack pointers support the stack limit
checking feature.)
• SVC and PendSV exceptions: The SVC instruction trigger’s the SVCall exception event,
which allows application tasks (which usually execute as unprivileged thread) to access OS
services (which execute with privileged access permission). The PendSV exception is triggered by the Interrupt Control and State Register in the System Control Block (SCB->
ICSR: see Section 9.3.2). It can be used for context switching operations (Section 11.9).
• Unprivileged execution level and Memory Protection Unit (MPU): This allows a basic
security model which restricts the access rights of unprivileged application tasks. The
separation of privileged and unprivileged software can also be used in conjunction with
the Memory Protection Unit (MPU), thus further enhancing the robustness of the
embedded systems.
• Exclusive access: The exclusive load and store instructions are useful for semaphore and
mutual exclusive (MUTEX) operations in the OS.

When TrustZone is implemented, a range of the aforementioned OS features are banked
between the Secure and the Non-secure states. The following are additional features which
are available when TrustZone is implemented:
• Banked stack pointer––a total of four stack pointers are available: MSP_S (Secure MSP),
PSP_S (Secure PSP), MSP_NS (Non-secure MSP), and PSP_NS (Non-secure PSP).
• Stack limit checking for Secure stack pointers for all Armv8-M processors.
• Banked MPU (Both Secure and Non-secure).
• Banked SVCall and PendSV exception.
• Secure SysTick Timer (optional on Armv8-M Baseline/Cortex-M23 processor).
In addition to the above, a number of features in the processor also indirectly benefit OS
deployment in the Cortex-M processors. For example, the Instrumentation Trace Macrocell
(ITM) in the Cortex-M33 processor (as well as all Armv7-M processors) can be used to enable
OS aware debugging. The low interrupt latency characteristic of the Cortex-M processor also
improves the performance of context switching.

The SysTick timer is always present in Armv8-M Mainline processors, such as the CortexM33 processor.
When TrustZone is implemented, there can be up to two SysTick timers in the processor.
The possible configurations are listed in Table 11.1.

The SysTick timer is a simple 24-bit timer and contains 4 registers (Fig. 11.1).
The timer operates as a down counter and triggers the SysTick exception when it reaches 0
(Fig. 11.2). After reaching zero, at the next transition it automatically reloads using the value
in the reload value register. It can run at the processor’s clock frequency but can also be set up
to decrement using, if available, a reference clock. Normally such a reference clock would be
an on-chip clock source with a fixed clock speed. Please note, if the processor’s clock has
stopped, which occurs during certain sleep modes, the SysTick timer would also stop.

Some points:
• The SysTick registers are accessible in privileged state only.
• Unprivileged access to SysTick triggers an error response.
• Access to the registers should be carried out using 32-bit aligned transfers.

(imp: FIG. 11.1 SysTick registers. )

( read systick implemetation, register and usage details )

Armv8-M processor with TrustZone
implemented can have up to two SysTick timers, that is, a Secure SysTick and a Non-secure
SysTick. Non-secure software can only see the Non-secure SysTick, but the Secure software
can see both the Secure SysTick and the Non-secure SysTick (via the Non-secure SysTick alias
address). This is shown in Fig. 11.3.
The SysTick exception is banked between the Secure and the Non-secure worlds. The SysTick
exceptions are linked to the SysTick timer of the same security domain as described below:
• The Secure SysTick timer triggers the Secure SysTick exception and the exception entry
uses the SysTick vector in the Secure vector table. The base address of the Secure vector
table is pointed to by the VTOR_S.
• The Non-secure SysTick timer triggers the Non-secure SysTick exception and the exception
entry uses the SysTick vector in the Non-secure vector table. The base address of the Nonsecure vector table is pointed to by the VTOR_NS.
SysTick exceptions can also be triggered by software using SCB->ICSR (Interrupt Control
and State Register: see Section 9.3.2). The behavior of triggering a SysTick exception using
SCB->ICSR is shown in Table 11.7.

( FIG. 11.3 SysTick in address space. )

A number of considerations need to be made when using the SysTick timer:
1. The registers in the SysTick timer are only be accessed when in privileged state and can
only be accessed using a 32-bit aligned access.
2. The reference clock might not be available in some microcontroller designs.
3. When you are using an embedded OS in your application, the SysTick timer might be used
by the OS and should therefore not be used by application tasks.
4. The SysTick Timer stops counting when the processor is halted during debugging.
5. Depending on the design of the microcontroller, the SysTick timer may stop in certain sleep
modes.
