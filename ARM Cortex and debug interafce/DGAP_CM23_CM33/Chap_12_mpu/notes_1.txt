The Memory Protection Unit (MPU) is an optional feature in the Arm® Cortex®-M processor. It has two main purposes:
• To define the access permission of an application or process
	- In an OS environment, the MPU can be used for process isolation—which means
application tasks running in unprivileged state can only access memory spaces that are
assigned to them. Therefore, if an application task crashes, or has been compromised by
a hacker, it cannot corrupt or access memories used by the OS or by other application
tasks. Hence, it improves the security and robustness of the system.
	- The MPU can be used to force some of the address ranges to be read-only. For example,
after loading a program image into RAM, you can, to prevent it from accidentally
changing the program image inside, use the MPU to force the program location in RAM
to be read-only.
	 -The MPU can be used to mark certain data address ranges (e.g., stack, heap) as nonexecutable. This is a useful countermeasure to prevent hackers from attacking a system
using code injection techniques. Using the MPU to mark a portion of the SRAM as nonexecutable prevents the code injected into the stack and heap from being executed.
• To define the memory attributes of the address ranges
	- For systems with caches (either built-in as a part of the processor or integrated at the
system level), the MPU can be used for defining whether certain address ranges should
be cacheable. If they are cacheable, the MPU can then be used to define the type of
caching scheme (e.g., write-back, write-through) and the shareability attributes of the
memory regions.
	- While possible, although in general not recommended, the MPU can be used to override
the memory/device type definition of the default memory map (see Chapter 6,
Section 6.3 for Memory Types and Memory Attributes, and Table 6.4 regarding the Memory Attributes in the default memory map). Note: In normal applications, however,
software developers should avoid switching an address from “Normal” to “Device” (or
vice-versa) because a debugger would not know that the default memory/device type in
the memory map had been overridden. A consequence of the aforementioned action is
that the debugging of the system could become more difficult. This is because the bus
transfers generated by the debugger would have mismatching memory attributes,
resulting in inconsistencies between the application and the debug views.
In some RTOS’s designed for Armv6-M and Armv7-M based Cortex-M processors, the MPU
is used for stack overflow detection in application threads. However, in Armv8-M processors,
stack overflow detection can be handled by the stack limit check registers. Specifically, in the:
• Cortex-M33: the stack limit check registers (see Section 11.4) can be used for both Secure
and Non-secure software.

When an MPU violation is detected, the transfer is blocked and a fault exception is
generated:
• If the MemManage Fault (exception type 4) is available (it is not available in the CortexM23 processor), is enabled and has a higher priority than that of the current level, then the
MemManage Fault would be instantly triggered.
• If that is not the case (either MemManage Fault is not available, is disabled or its priority
level is same or lower than the current priority level), then HardFault (exception type 3)
would be triggered.
The exception handler can then decide how best to deal with the error, i.e., whether the
system should reset or, in the case of an OS environment, whether the OS should either terminate the offending task or restart the whole system.
The MemManage Fault is banked between security states:
• If a Secure MPU violation takes place, a Secure MemManage Fault is triggered
• If a Non-secure MPU violation takes place, a Non-secure MemManage Fault is triggered
When a MemManage Fault event is escalated to HardFault, the target security state depends on whether TrustZone® is implemented on the device and on the configuration of
the AIRCR.BFHFNMINS bit (Table 9.18).

Unlike the Memory Management Unit (MMU) in application processors (e.g., Cortex-A
processors), the MPU does not offer address translation (i.e., it has no virtual memory support). The reason for Cortex-M processors not supporting the MMU feature is to ensure that
the processor system can deal with real-time requirements: When an MMU is used for virtual
memory support and when there is a Translation Lookup Buffer (TLB) miss (i.e., a logical address needs to be translated to a physical address but the address translation details are not
available in the local buffer), the MMU needs to carry out a page table walk. The page table
walk operation is needed to obtain the address translation information. However, because
during the page table walk operation the processor might not be able to deal with interrupt
requests, the use of an MMU is not ideal for real-time systems.

The MPU is a programmable unit and is controlled by privileged software. By default, the
MPU is disabled, which means that:
• The memory access permission in the system’s memory map is based on the default
memory access permission (see Section 6.4.4)
• The memory attribute in the system’s memory map is based on the default memory map
(see Section 6.3.3)
The use of default memory access permission and default memory attribute also applies
when the MPU has not been implemented.
The MPU operates by defining MPU regions. In Armv8-M, each MPU region has a starting
and an ending address, with a 32-byte granularity. Before enabling the MPU, privileged software needs to program the MPU to define the MPU regions for both the privileged and the
unprivileged software. The settings for each region include:
• The starting and ending addresses of the MPU region,
• The access permissions of the MPU region (i.e., whether the region is privileged access only
or is full access), and
• The attributes of the MPU region (i.e., the memory/device type, cache attributes, etc.).
After programming the MPU regions, the MPU can then be enabled.

In an OS environment, the MPU region settings are likely to be reconfigured at each context
switch so that each unprivileged application/thread has their own accessible address ranges.
Each application/thread uses several MPU regions for code (including regions for shared libraries), data (such as stack), and peripherals. OS code also provides MPU regions for
privileged code (e.g., interrupt handlers).
To simplify the MPU setup, the MPU for Cortex-M processors also provides a
programmable background region feature. When this is enabled, privileged software is,
unless the settings are overridden by an enabled MPU region, able to see the access
permissions and memory attributes of the default memory map. By using the background
region feature, OS code only needs to program the MPU regions required for the
unprivileged code.

In the Cortex-M23 and Cortex-M33 processors, the MPU feature is optional. When
implemented, the MPU could have 4/8/12 or 16 MPU regions. If the TrustZone security extension is implemented, there can be up to two MPUs, one for the Secure and one for the Nonsecure world. The number of MPU regions for the Secure and the Non-secure MPU can be
different.
Although the Cortex-M23 and Cortex-M33 processors do not have an internal level 1 cache,
the cache attributes produced by the MPU settings are exported to the processor’s top level so,
if a system level cache is available, it can utilize the attribute information.

The design of the MPU is based on the Protected Memory System Architecture (PMSA).
PMSAv8 is part of the Armv8-M Architecture [1]. When configurating the MPU:
• Before changing the MPU configuration, a DMB instruction should be executed to ensure
that the previous memory accesses (if some of those are still outstanding) are not affected.
• If a system level cache is present, and if the configuration of the MPU is going to change the
caching scheme, you will need to clean the cache before updating the MPU configuration.
• After the MPU has configured, you should execute a DSB and then an ISB instruction to
ensure that the subsequent program operations are using the new MPU settings.
