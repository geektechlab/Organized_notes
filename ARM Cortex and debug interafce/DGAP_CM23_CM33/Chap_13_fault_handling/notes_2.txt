SecureFault

The Secure fault exception is triggered by violations of security rules as outlined in the
TrustZone. The Secure fault exception is not available when TrustZone has not been
implemented and is not available in the architectures of either Armv6-M or Armv7-M.
There are a range of security violations that trigger the Secure fault and some of these are:
• Memory accesses that violate security permission. These can be:
- Data read/write
- Exception stacking, unstacking
• An illegal transition between security domains. For example:
- A branch from the Non-secure to Secure world without going through a valid entry
point (Note: a valid entry point requires an SG instruction in a region marked as
Non-secure Callable).
- A branch from the Secure to the Non-secure world without using a correct instruction
(e.g., BXNS, BLXNS)
• When a security integrity check fails during an exception sequence. Examples of this are:
- An invalid EXC_RETURN code
- An invalid integrity signature in an exception stack frame. The integrity signature is
inserted in a Secure exception stack frame when a Non-secure interrupt is triggered
when executing a piece of Secure code. When the processor returns from a Non-secure
interrupt handler and switches back into the Secure software, and the integrity signature
is invalid or missing, a Secure fault would be triggered.
Please note, at the system level, bus access could be filtered by TrustZone security components ( the Memory Protection Controller, the Peripheral Protection Controller, etc.). These
components can, instead of triggering a SecureFault, trigger a BusFault using the bus error
response.

HardFault

The HardFault exception can be triggered by:
• A bus error response received for the vector fetch.
• A security or MPU violation for the vector fetch.
• An SVC instruction execution when the priority level of the SVCall exception is the same or
is lower than the current level.
• The execution of a breakpoint (BKPT) instruction where the debug has been disabled (i.e.,
there is no debug connection and the debug monitor exception has been disabled, or has a
lower priority than the current level).
The HardFault can also be triggered by the escalation of the MemManage Fault, the
BusFault, the UsageFault and the SecureFault when these fault exceptions are:
• Not available (e.g., in the Cortex-M23 processor and in Armv8-M Baseline, all fault events
escalate to HardFault), or
• Not enabled (The aforementioned configurable fault exception handlers need to be
enabled by software before they can be used), or
• Of the same or of a lower priority than the current exception priority level. When this
occurs, the priority level of the aforementioned configurable fault exception is insufficient,
which means that the configurable fault exception cannot be carried out and, is instead,
escalated to the HardFault exception. The exception to this is an asynchronous BusFault,
which can be pended and then handled when the other higher priority interrupt handler(s)
has finished.

Faults triggered by exception handling

The MemManage Fault, the Bus Fault, the UsageFault (but only when triggered by a stack
limit violation) and the SecureFault can all be triggered by memory access during an exception entry and an exception return sequence. For example,
• Stacking/unstacking. If normal stack operations are functioning correctly, the stacking
error could be caused by a stack overflow. If stacking is working correctly but failed during
an unstacking operation, the cause could be:
- Unexpected changes in the MPU configurations
- An incorrect change in the EXC_RETURN (e.g., the incorrect stack pointer was used for
the unstacking)
- An incorrect change in the stack pointer value.
• Lazy stacking—but only if the FPU is available and is enabled. Further information on lazy
stacking can be found in Chapter 14, Section 14.4. In normal applications, it is likely that if
the lazy stacking of an exception results in a fault then the same fault would, unless the
MPU configuration was changed in between, have occurred at the stacking stage. Another
possible cause of a fault during lazy stacking could be that the contents of the Floatingpoint Context Address Register (FPCAR) had been unexpectedly modified or corrupted.
• Vector fetches—this always triggers a HardFault and could be caused by the:
- Incorrect configuration of the Vector Table Offset Register (VTOR), or
- Incorrect configuration of the SAU/IDAU—resulting in the security attribute of the
vector table address being incorrect.
• EXC_RETURN failing integrity checking—The corruption of the EXC_RETURN during
exception handling routines is another likely cause for the occurrence of fault exceptions
during exception returns. The Cortex-M processor contains several integrity checks in its
exception handling sequencing and the failing of any integrity check can result in a fault
exception.
If a stacking or unstacking error occurs during an exception sequence, the current priority
level for error handling is based on the priority level of the interrupted process/task (level X),
as shown in Fig. 13.1.

Based on the diagram shown in Fig. 13.1, if a fault event takes place during the exception
handler sequence, the following scenarios could happen:
• A fault occurs during stacking/unstacking #1—If the fault exception (i.e., the BusFault, the
MemManage Fault, the UsageFault, or the SecureFault) is disabled, or has the same or a
lower priority level than the current priority level, it is immediately escalated to the
HardFault exception.
• A fault occurs during stacking/unstacking #2—If the fault exception is enabled and has a
higher priority level than both the current level and the priority level of the exception to be
serviced, the fault exception is executed first and exception #N is pended.
• A fault occurs during stacking/unstacking #3—If the fault exception is enabled and has a
priority level between the background level and the level of the to be serviced exception
#N, the handler for exception #N would be executed first and the triggered fault handler
would be executed afterwards.
• A fault occurs during Lazy stacking—If the FPU has been implemented and has been
enabled, if the lazy stacking feature is also enabled (i.e., the default setting), and if the
exception handler #N also use the FPU, then the stacking of the FPU registers happens later
during the execution of exception handler #N. The lazy stacking feature, which is covered
in Chapter 14, Section 14.8, helps reduce interrupt latency.
For the aforementioned lazy stacking scenario, if the memory access for lazy stacking triggers a fault event, it is handled as though the fault had occurred during stacking. For example:
• If the configurable fault exception is disabled, or has the same or a lower priority level than
priority level X then it will escalate to HardFault.
• If the configurable fault exception is enabled and has a higher priority level than level
Y (i.e., the level that the exception handler #N currently executing has), then the
configurable fault exception executes immediately.
• If the configurable fault exception is enabled and has the same or a lower priority level than
level Y (i.e., the level that the exception handler #N currently executing has), then the
pending status of the configurable fault exception is set and will execute when exception
handler #N has finished.

When using the Cortex-M33 processor (or other Armv8-M Mainline processors), the
MemManage Fault, the BusFault, the UsageFault and the SecureFault can, optionally,
be enabled; but SecureFault is only available when writing software running in the Secure
world. Before enabling these handlers, the exception priority levels should be set up
based on the application’s requirements.

The enable control bits of these fault handlers are in the System Handler Control and State
Registers (SCB->SHCSR). The fault exception can be enabled by setting the corresponding
enable bit to 1 as per the following examples:
SCB->SHCSR j= SCB_SHCSR_MEMFAULTENA_Msk; //Set bit 16 to 1
SCB->SHCSR j= SCB_SHCSR_BUSFAULTENA_Msk; //Set bit 17 to 1
SCB->SHCSR j= SCB_SHCSR_USGFAULTENA_Msk; //Set bit 18 to 1
SCB->SHCSR j= SCB_SHCSR_SECUREFAULTENA_Msk; //Set bit 19 to 1
