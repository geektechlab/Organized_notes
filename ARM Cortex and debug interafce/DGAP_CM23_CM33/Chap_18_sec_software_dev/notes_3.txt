Security state transitions and their relationship with exception priority levels

Some of the system exceptions are banked between security states, e.g., exceptions like SysTick,
SVC, and PendSV. Because of this, there are, for those exceptions, Secure and Non-secure exception priority level registers. When one of the aforementioned system exception handlers calls a
function from the opposite security domain, the exception priority level of the first triggered exception is used. In the example in Fig. 18.9, the Non-secure SVC calls a Secure API, and, even
though the processor is in Secure state and its IPSR (Interrupt Program Status Register) is indicating that it is running an SVC handler, the exception priority level of the Non-secure SVC is used.
Please note, there are special cases where the exception priority level changes in crossdomain function calls/returns.
When Secure exceptions are prioritized by setting the PRIS (Prioritize Secure) bit in the
AIRCR (Application Interrupt and Reset Control Register), the switching of one security state to another via a function call/return can affect the processor’s current exception priority level.
For example, when the same code example detailed in Fig. 18.9 is executed, and if the AIRCR.
PRIS is set to 1, the effective exception priority level during the execution of the Non-secure
SVC handler would be 0xC0. However, the effective priority level would change to 0x80
during the execution of the Secure function (i.e., function A) (Fig. 18.10).

( FIG. 18.9 Exception priority level of banked system exceptions at cross-domain function calls. )

( FIG. 18.10 Security state transition can change the processor’s exception priority level )

Other TrustZone instructions

To support the various TrustZone operations, Armv8-M introduced several instructions.
These are listed in Table 18.9.
Information on these instructions can be found in Chapter 5, Section 5.20.
The TT instructions are accessed via intrinsic functions and are covered in Section 18.3.6.
The VLSTM and VLLDM instructions are generated by the C/C++ compiler as follows:
• Before the Non-secure function call is made, the Secure software reserves a small portion of
memory space on the stack for the FPU registers and then executes the VLSTM instruction.
This marks the data in the FPU and tells it that it needs to be protected from the Non-secure
state software, but this action does not push the FPU registers into the allocated stack space.
• The Non-secure C function is called and executed. This means that:
	When the Non-secure C function executes an FPU instruction, the stacking of the FPU
registers takes place and saves the Secure data in the FPU to the Secure stack. The FPU
registers are then cleared to prevent leakage of the Secure information. Once the stacking
and clearing of the registers is completed, the Non-secure function is resumed and
operations continue.
• After returning from the Non-secure API, the processor executes the VLLDM instruction.
When this instruction is executed:
	If the executed Non-secure function did not use the FPU, the FPU registers would not be
touched and the VLLDM instruction would only clear the pending FPU stacking request.
	If the executed Non-secure function did use the FPU, the previous Secure FPU data would
be in the Secure stack and the VLLDM instruction would restore the Secure FPU context.
When the FPU is not implemented or is disabled, the VLSTM and VLLDM instructions
execute as NOPs (No operation).

( 18.3.2 Security setup )

