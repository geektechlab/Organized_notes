Each of the interrupts can be enabled or disabled at the NVIC. And, in addition, there are several global interrupt/exception masking registers that allow interrupts and exceptions to be blocked based on priority levels. Details as follow:
• PRIMASK—available in all Cortex-M processors. When this is set to 1, all exceptions with programmable priority levels (0 to 0xFF) would be blocked, and only Non-Maskable Interrupt (NMI, level-2) and HardFault (level-1 or -3) are able to invoke. Interrupt masking is disabled when its value is 0, which is the default value.
• FAULTMASK— When this is set to 1, all exceptions with programmable priority levels (0 to 0xFF) and HardFault are blocked (there are some exceptions). Interrupt masking is disabled when its value is 0, which is the default value.
• BASEPRI—available in Armv8-M Mainline (Cortex-M33) and Armv7-M (Cortex-M3, Cortex-M4 and Cortex-M7). This register allows the blocking of interrupts/exceptions based on their programmable priority levels. It is disabled when the value is 0, which is the default value.

The PRIMARK, FAULTMASK, and BASEPRI registers:
• Can be accessed in privileged state only.
• Are banked between Secure and Non-secure states if the TrustZone security extension is implemented. Secure software can access both the Secure and Non-secure masking registers, but Non-secure software can only access ones that are Non-secure. PRIMASK and FAULTMASK registers are 1-bit wide and the width of the BASEPRI register ranges from 3 bits to 8 bits (depending on the width of the priority level registers).The most significant bits of the BASEPRI register field is aligned to bit 7, while other bits in this register are unimplemented.

The purpose of the interrupt masking registers is as follows:
• PRIMASK—For general disabling of interrupts and exceptions, e.g., to enable critical regions in program code to be executed without getting interrupted.
• FAULTMASK—Can be used by fault exception handlers to suppress the triggering of further faults (only some types of faults can be suppressed) during fault handling. For example, when it is set it can bypass the MPU and can, optionally, suppress bus error responses. This potentially makes it easier for fault handling code to carry out remedial actions. Unlike PRIMASK, FAULTMASK is cleared automatically at exception exit (except in NMI).
• BASEPRI—for the general disabling of interrupts and exceptions based on priority levels. For some OS operations, there could be a need to block some exceptions for a brief period of time, but, at the same time, still allow high priority interrupts to be serviced. This register is 8-bit wide, but the lowest bits could be unimplemented (see Fig. 4.9). When this register is set to a Nonzero value, it blocks exceptions and interrupts that have the same or a lower priority level than the BASEPRI’s level.

These interrupt masking registers can be accessed at privileged level using the MRS and MSR instructions.

CONTROL register
	The CONTROL register contains multiple bit fields for various processor system configuration settings and is available in all Cortex-M processors (Fig. 4.10). This register can be written in privileged state, but can be read by both privileged and unprivileged software. When the TrustZone security extension is implemented, some of the bit fields are banked between security states. Two of the bit fields in the CONTROL register are only available when the Floating-Point Unit (FPU) is implemented. The bit fields of the CONTROL register are shown in Table 4.4. When the processor is reset, the value of the CONTROL register is 0, which means:
	• the MSP is the current selected stack pointer (SPSEL bit is 0).
	• the program execution starts in privileged thread mode, (nPRIV bit is 0).
	• if the FPU is implemented, the FPU does not contain active software context data (indicated by 0 value in the FPCA bit) and does not hold any Secure data (SFPA is 0). 

	The privileged thread software can, optionally, write to the CONTROL register to:
		• Switch the stack pointer selection (the software needs to handle this carefully otherwise the data used by the current software held in the stack will not be accessible if the current selected SP value has changed).
		• Switch to unprivileged level—if privileged code changes nPRIV to 1, this switches the processor into unprivileged level. However, the unprivileged thread software cannot switch itself back to privileged by writing 0 to nPRIV (because unprivileged code cannot write to the CONTROL register). It is, however, possible for an exception/interrupt handler to change then PRIV bit (CONTROL bit 0) back to 0.

Unprivileged code is blocked from writing to the CONTROL register. This is essential and ensures a very high level of security—preventing a compromised unprivileged software component from taking over the whole system and, also, preventing an unreliable application thread from crashing the system. Normally an OS can provide various system services, via system exceptions, to enable access to privileged resources (e.g., to enable or disable interrupts). This ensures that it is not a problem for application threads to run in unprivileged state in a system with an OS. If it is necessary for a thread mode code to regain privileged access, a system exception (e.g., SVC or SuperVisor Call) and the corresponding exception handler is needed.

Secure privileged software can also access the Non-secure CONTROL register using the CONTROL_NS symbol. There are a couple of specific points you need to be aware of when changing the value of the CONTROL register:
• If the FPU is implemented, the FPCA and SFPA bits are automatically set by the processor’s hardware when a floating-point instruction is executed. When updating the SPSEL and nPRIV bits in the CONTROL register, care should be taken to preserve the FPCA and SFPA bits. If they are not preserved, the data stored in the FPU registers will not be saved to the stack by the exception handling sequence and could be lost when an exception/interrupt occurs. As a result, generally speaking, software should use a read-modify-write sequence to update the CONTROL register to ensure the FPCA and SFPA are not accidentally cleared.
• After modifying the CONTROL register, as specified by the Armv8-M architecture reference manual, an Instruction Synchronization Barrier (ISB) instruction should be used to ensure the effect of the update applies immediately to any subsequent code. The ISB instruction is accessible using __ISB() function in the CMSIS-CORE. • Since the SPSEL and then PRIV settings are orthogonal (i.e., they operate independently), there are four possible combinations of settings. However, only three of them are commonly used in real world applications (Table 4.5).

Unlike other special registers, the CONTROL register can be read in unprivileged state. This allows software to determine whether the current execution level is privileged by reading the values of IPSR and the CONTROL registers:
	int in_privileged(void)
	{
		if (__get_IPSR() != 0) return 1; // True when in handler mode
		else // In thread mode
			if ((__get_CONTROL() & 0x1)==0) return 1; // True when nPRIV==0
			else return 0; // False when nPRIV==1
	}

Stack limit registers
	Cortex-M processors use a descending stack operation model. It means the stack pointers are decremented when more data is added to the stack. When too much data is pushed into a stack and the space consumed is more than the allocated stack space, the overflowing stack data can corrupt the OS kernel data and memories used by other application tasks. This can cause various types of errors and, potentially, result in security vulnerabilities.

	Stack Limit Registers are used for detecting stack overflow errors. They were introduced in the Armv8-M architecture and were not available in the previous generation of Cortex-M processors. There are four stack limit registers.

	The stack limit registers are 32-bit and can be set to the lowest address of each of the stack address ranges allocated to each stack (Fig. 4.13).Because the lowest 3 bits (bit 2 to bit 0) of these stack limit registers are always zero (writes to these bits are ignored), the stack limits are always aligned to double word boundaries.

	By default, the stack limit registers reset to 0 (the lowest address in the memory map) so that the stack limits will not be reached; effectively the stack limit checks are disabled at startup. The stack limit registers can be programmed when the processor is executing in privileged state. Please note:
		• Secure privileged software can access all stack limited registers, and
		• Non-secure privileged software can only access Non-secure stack limit registers.

	The stack limit is violated if a stack pointer goes lower than the corresponding stack limit register. The violating stack operation (i.e., the memory access to the address below the stack limit) will not take place so as to avoid corrupting memories used by other applications. The stack limit check only happens during stack related operations, such as:
		• Stack push, including during exception sequences
		• When the stack pointer is updated (e.g., when the stack is allocated for local memory use by a function).

	The stack limit check is not performed immediately when the stack limit registers are updated. This simplifies context switching operations in the design of an OS (there is no need to set the stack limit registers to 0 before updating the Process Stack Pointer (PSP)). If a stack limit violation takes place, a fault exception is triggered (UsageFault/HardFault).

Floating-point registers in Cortex-M33
	The FPU hardware is optional in the Cortex-M33, the Cortex-M4, the Cortex-M7, and other Armv8-M Mainline processors. If the floating-point unit is available, the floating-point unit (FPU)includes an additional register bank containing another 32 registers (S0–S31, each ofwhich are 32-bit), and a Floating-Point Status and Control Register (FPSCR). This is shown in Fig. 4.14.

	Each of the 32-bit registers, S0–S31 (“S” for single precision), can be accessed individually using floating point instructions, or accessed as a pair, using the register names D0–D15 (“D” for double-word/double-precision). For example, S1 and S0 are paired together to become D0, and S3 and S2 are paired together to become D1. Although the floating-point unit in the Cortex-M33 processor does not support double precision floating point calculations, you can still use floating point instructions for transferring double precision data. The FPSCR can only be accessed in privileged state and contains various bit fields (Fig. 4.15). The purposes of these bit fields include:
	• defining some of the floating-point operation behaviors
	• providing status information about the floating-point operation results
	By default, the behavior of the FPU is configured to be compliant with IEEE 754 single precision operations. In normal applications, there is no need to modify the control settings of the FPU. Table 4.7 describes the bit fields in the FPSCR. Note: The exception bits in the FPSCR can be used by software to detect abnormalities in floating point operations.

	In addition to the registers in the floating-point register bank and the FPSCR, there are a number of additional memory mapped registers that are related to floating-point unit operations. One of the important ones is the Coprocessor Access Control Register (CPACR, Fig. 4.16). By default, the FPU is disabled when the processor is reset to reduce power consumption. Before the FPU can be used, it needs to be enabled first and this is achieved by programming the CPACR.

	Please note, the CPACR is available in Armv8-M Mainline only.

	The CPACR is located at address 0xE000ED88, is privileged access only and is cleared to 0 when the processor is reset. If the TrustZone security extension is implemented this register is banked between security states. Secure software can also access the Non-secure version of the CPACR (CPACR_NS) using NS alias address 0xE002ED88. Secure software can also define whether Non-secure software can access each of the coprocessors using a register called the Non-secure Access Control Register (NSACR). The CPACR and NSACR registers are used for enabling the coprocessor interface and also the Arm Custom Instructions features.

The results of arithmetic and logic operations affect a number of status flags in the Application Program Status Register (APSR). These flags include the:
• N-Z-C-V bits: status flags for integer operations
• Q bit: status flag for saturation arithmetic (available in Armv8-M Mainline/Cortex-M33 processor)
• GE bits: status flags for SIMD operations (available in Armv8-M Mainline/Cortex-M33 processor with DSP extension)

Impact of TrustZone on the programmer’s model
	Apart from certain special registers, in general there is little difference between the programmer’s model for Secure and Non-secure software. It means most runtime libraries and assembly code can be reused in either Secure or Non-secure states when migrating from Armv6-M/Armv7-M to the Armv8-M architecture. The registers in the programmer’s model (excluding memory mapped registers) that are present when the TrustZone security extension is implemented include:
	- Secure stack pointers (MPS_S, PSP_S)
	- Secure stack limit registers (MSPLIM_S, PSPLIM_S)
	- Bit 3 of the CONTROL registers if the FPU is implemented (available in the Cortex-M33 processor)
	- A Secure version of the interrupt masking registers (PRIMASK_S, FAULTMASK_S and BASEPRI_S)

	The other registers are shared between Secure and Non-secure states. If the TrustZone security extension is not implemented, the programmer’s model of Armv8-M is very similar to the previous generation of Cortex-M processors; except that the Cortex-M33 processor has additional Non-secure stack limit registers that are not available in the Armv7-M processors.
