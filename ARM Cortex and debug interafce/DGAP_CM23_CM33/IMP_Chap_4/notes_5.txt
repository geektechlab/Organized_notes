Cortex-M33 processors include a comprehensive list of debugging features: such as program execution controls, including halting and stepping, instruction breakpoints, data watch points, registers and memory accesses, profiling, and traces. There are two types of interface provided in the Cortex-M processors to help developers to debug and analyze software operations. They are debug and trace. The debug interface allows a debug adaptor to connect to a Cortex-M based microcontroller to control the debug features and to access the memory space on the chip. The Cortex-M processor supports:
• The traditional JTAG protocol, which uses either four or five pins, or
• A 2-pin protocol called Serial Wire Debug (SWD). The Serial Wire debug protocol was developed by Arm and can handle with just two pins, without any loss of debug performance, the same debug features that are in the JTAG protocol. In some devices, one debug protocol is implemented, and in others two. If both protocols are implemented, dynamic switching of protocols could be possible through a special signal sequence.

The two protocols can coexist on the same connector, with the JTAG TCK shared with the Serial Wire clock and with the JTAG TMS shared with the Serial Wire Data. The Serial Wire Data pin is bidirectional when used in SWD protocol mode (Fig. 4.30). Both protocols are widely supported by different debug adaptors from various companies. The trace interface is used to collect information from the processor during run-time. This can be data values, exception events and profiling information. If the Embedded Trace Macrocell (ETM) is used, it can even provide complete details of the program’s execution. Two type of trace interface are supported: a single pin protocol called Serial Wire Output (SWO) and a multi-pin protocol called Trace Port (Fig. 4.31). The Serial Wire Output (SWO) is a low-cost trace solution which has a lower trace data bandwidth than the parallel trace port. However, the bandwidth is still enough to capture the selective data trace, event trace and basic profiling- which are basic trace features collectively known as the Serial Wire Viewer (SWV). The output signal, which is called SWO, is often shared with the JTAG TDO pin, a fact which means you only need one standard JTAG/SWD connector for both debug andtrace. (Obviously the trace data can only be captured when the two pin SWD protocol is used for debugging.)

The Trace Port mode requires one clock pin and multiple data pins. The number of data pins used is configurable, and in most cases the Cortex-M23 and Cortex-M33 microcontrollers support a maximum of four data pins (a total of five pins when one includes the trace clock). The Trace Port mode supports a much higher trace bandwidth than the SWO. You can, if needed, also use the Trace Port mode with fewer pins. For example, when some of the Trace Data pins are multiplexed with I/O functions and you need to use some of those I/O pins for your application. The high trace data bandwidth of the Trace Port model allows:
• real-time recording of program execution information (program trace), and
• other trace information you can collect using the SWV. The real-time program trace requires a companion component called the Embedded Trace Macrocell (ETM) inside the chip.

An alternative instruction trace solution, called Micro Trace Buffer (MTB), is also available for the Cortex-M23 and the Cortex-M33 processors. This has a limited trace history and only needs a debug connection to retrieve the instruction trace data.

To capture real-time trace data, you can use a low-cost debug adaptor such as the Segger J-Link, which can capture data through the SWO interface. Or, you can use advanced products such as the Segger J-Trace to capture trace data in trace port mode. When compared to the previous generations of Cortex-M processors, the Cortex-M23 and Cortex-M33 processors have a number of debug and trace feature enhancements. For example, both ETM and MTB instruction trace are supported in both of these processors (the previous processors only supported one of those solutions).

To capture real-time trace data, you can use a low-cost debug adaptor such as the Keil ULINK-Plus or Segger J-Link, which can capture data through the SWO interface. Or, you can use advanced products such as the Keil ULINK Pro or Segger J-Trace to capture trace data in trace port mode. When compared to the previous generations of Cortex-M processors, the Cortex-M23 and Cortex-M33 processors have a number of debug and trace feature enhancements. For example, both ETM and MTB instruction trace are supported in both of these processors (the previous processors only supported one of those solutions).

In most Cortex®-M microcontrollers, there can be several types of reset. From a processor’s architectural point of view there are at least two types:
- Power on reset—resets everything in the microcontroller. This includes the processor and its debug support components and peripherals.
- System reset—resets just the processor and peripherals, but not the debug support component of the processor.
In normal operations the processor system receives a power-on reset when the system is first powered up.

During a system debug or processor reset operation, the debug components in the CortexM23 or Cortex-M33 processor are not reset so that the connection between the debug host (i.e., the debugger software running on the computer) and the microcontroller can be maintained. To reset the processor during a debug session, the debug host, in most cases (this might be configurable in the debug tool), makes use of the Application Interrupt and Reset Control Register (AIRCR) in the System Control Block (SCB).

In a Cortex-M33 processor system with the TrustZone security extension, the processor starts in a Secure state and the Secure vector table is used for the reset sequence. The Non-secure Main Stack Pointer (MSP_NS) is, in this instance, initialized by the Secure software. The setup of the MSP is necessary because some exceptions, such as the NMI or HardFault handler, could potentially occur shortly after the reset. The stack memory and the MSP will then be needed for the stacking process which is carried out as part of the exception handling.

Because the stack operations in the Cortex-M23 and Cortex-M33 processors are based on full descending stack (the SP’s value decrements before storing the data during a stack PUSH operation), the initial SP value should be set to the first address location after the last allocated address of the stack memory. For example, if you have a stack memory range from 0x20007C00 to 0x20007FFF (1 K bytes), the initial stack value should be set to 0x20008000, as shown in Fig. 4.33. As explained in Section 4.4.5, the LSB of the exception vectors should be set to 1 to indicate the Thumb state. For that reason, the example in Fig. 4.33 has 0x101 in the reset vector, whereas the boot code starts at address 0x100. After the reset vector is fetched, the CortexM processor then starts to execute the program from the reset vector address and begins normal operations. Normally, the development tool chain automatically sets the LSB of the exception vectors to 1 (the linker should recognize the address is pointing to the Thumb code and will, therefore, set the LSB of the addresses to 1).
