the operation of the processor can be divided into:
• Privileged and unprivileged states—this state separation is always available,
• Secure and Non-secure states—this state separation is available if the TrustZone security extension is implemented.

In addition to the separation between privileged and unprivileged and the separation between Secure and Non-secure, Cortex-M processors also have the concepts of processor states and operation modes. When combining all these together, we have the state diagram, as shown in Fig. 4.2.

Software running in privileged thread mode can switch the processor into unprivileged thread mode by programming a special register called “CONTROL”. Please note, the transition between privileged and unprivileged states can also happen during function calls that switch from one security domain to another. This is because the nPRIV bit in the CONTROL register is banked (Secure and Non-secure states both have their own nPRIV bits). At first glance this might sound strange because typical secure systems do not allow unprivileged code access to privileged level, except via OS’s APIs.

However, this is not an issue in the Armv8-M processor as explained in the following scenarios:
• Non-secure unprivileged thread software calling Secure privileged APIs (Fig. 4.3): The Secure APIs are created by a Trusted party. The codes in these trusted APIs are designed with security measures in mind to prevent the APIs from being exploited. As a result, allowing a transition from unprivileged to privileged level in the execution of these APIs is not a security issue concern.
• Secure unprivileged thread software calling Non-secure privileged code (Fig. 4.4): As the Secure code is expected to be developed by trusted parties, the security risk in Secure unprivileged code gaining Non-secure privileged is not an issue. Even if the Secure unprivileged software is not fully trusted, allowing it to access Non-secure privileged resources does not pose a security risk. This is because it does not allow the Secure unprivileged software to bypass or disable the security management of the Secure privileged code.

For a system with the TrustZone security extension implemented, it is also possible to leave the Non-secure state unused and to execute the whole application in the Secure state. The debug state is used during software development. ( FIG. 4.5 Operation states and modes when the TrustZone security extension is NOT implemented. )

When the halt mode debug features are enabled (this requires a debug connection), the processor can enter the debug state when the software developer halts the processor, or if a debug event like a breakpoint has taken place. This allows the software developer to examine or change the register values of the processor. The memory contents and peripheral registers can be examined or changed via the debugger in either Thumb or debug states. In a deployed system without a debugger connected to it, the processor will not enter the debug state.

Coprocessor registers—the Cortex-M33 processor has a coprocessor interface that allows chip designers to add coprocessors (hardware for accelerating certain processing tasks). The coprocessor hardware contains coprocessor registers, which can be accessed using coprocessor instructions.

The register bank in Cortex-M processors has 16 registers: R0–R15 (see Fig. 4.6). Some of these registers have special usage as detailed below:
• R13—Stack pointer (SP). It is used for accessing the stack memory (e.g., stack PUSH or POP operations). Physically there can be two or four stack pointers—the Secure stack pointers are available only when the TrustZone security extension is implemented.
• R14—Link register (LR). This register is updated automatically to hold the return address when calling a function or subroutine. At the end of the function/subroutine, the value from LR is transferred into the program counter (PC) in order to resume its operation. In the case of nested function calls (i.e., a function call is made within a function which was called by another code), the value in LR must first be saved (e.g., using the stack PUSH operation to save the value into the stack memory) before the second level of function call is made. If it is not, the value in LR would be lost and would not be able to return to the original program. LR is also used to hold a special value called EXC_RETURN (Exception Return) during exception/interrupt handling. At the end of the interrupt service routine, the EXC_RETURN value is transferred into the PC to trigger the exception return. Further information on this is covered in Chapter 8, Sections 8.4.5 and 8.10.
• R15—Program Counter (PC). The main advantage of having the PC in the register bank is that it makes accessing constant data in the program code easier (e.g., Obtaining a constant using a data read instruction with the “PC related addressing mode”, for accessing a branch offset in a table branch operation). It is also possible to read/write to the PC. When reading this register, the operation returns a value which is the current instruction address (an even number), plus an offset of 4 (this is due to the pipeline nature of the processor and compatibility requirements with legacy processors, e.g., the Arm7TDMI). Writing to this register causes a branch operation. However, it is recommended that normal branch instructions should be used for general branch operations.

The rest of the registers (R0–R12) are general purpose. R0–R7 are also known as low registers. Because of the limited space available in a 16-bit instruction, many 16-bit Thumb instructions can only access low registers. The high registers (R8–R12) can be used with 32-bit instructions, and a few 16-bit instructions like MOV (move).

The initial values of R0–R12 can be unpredictable at startup. The hardware startup sequence automatically initializes the value of the Secure Main Stack Pointer (MSP_S) if the TrustZone security extension is implemented, or Non-secure Main Stack Pointer (MSP_NS) if it is not. The hardware startup sequence also initializes  the program counter (R15/PC).

( TABLE 4.1 )

As illustrated in Fig. 4.6, the SP is banked between Secure and Non-secure states. When accessing the stack pointer with MSR/MRS instructions, it is possible to specify which stack pointer should be used:
• MSP—Main Stack Pointer of the current security state (could be MSP_S or MSP_NS)
• PSP—Process Stack Pointer of the current security state (could be PSP_S or PSP_NS)
• MSP_NS—This enables Secure software to access the Non-secure Main Stack Pointer
• PSP_NS—This enables Secure software to access the Non-secure Process Stack Pointer

Special purpose registers can be accessed using special register access instructions such as MRS and MSR
	MRS <reg>, <special_reg>; Read special register into register
	MSR <special_reg>, <reg>; write to special register

The Program Status Register is 32-bit and can be subdivided into:
• Application PSR—contains various “ALU flags” which are required for conditional branches and instruction operations that need special flags (e.g., add with carry flag).
• Execution PSR—contains execution state information.
• Interrupt PSR—contains current interrupt/exception state information. These three registers can be accessed as one combined register, sometimes referred to as “xPSR”

The PRIMARK, FAULTMASK, and BASEPRI registers:
• Can be accessed in privileged state only.
• Are banked between Secure and Non-secure states if the TrustZone security extension is implemented. Secure software can access both the Secure and Non-secure masking registers, but Non-secure software can only access ones that are Non-secure. PRIMASK and FAULTMASK registers are 1-bit wide and the width of the BASEPRI register ranges from 3 bits to 8 bits (depending on the width of the priority level registers).The most significant bits of the BASEPRI register field is aligned to bit 7, while other bits in this register are unimplemented.

CONTROL register
	The CONTROL register contains multiple bit fields for various processor system configuration settings and is available in all Cortex-M processors (Fig. 4.10). This register can be written in privileged state, but can be read by both privileged and unprivileged software. When the TrustZone security extension is implemented, some of the bit fields are banked between security states. Two of the bit fields in the CONTROL register are only available when the Floating-Point Unit (FPU) is implemented. The bit fields of the CONTROL register are shown in Table 4.4. When the processor is reset, the value of the CONTROL register is 0, which means:
	• the MSP is the current selected stack pointer (SPSEL bit is 0).
	• the program execution starts in privileged thread mode, (nPRIV bit is 0).
	• if the FPU is implemented, the FPU does not contain active software context data (indicated by 0 value in the FPCA bit) and does not hold any Secure data (SFPA is 0). 

Secure privileged software can also access the Non-secure CONTROL register using the CONTROL_NS symbol. There are a couple of specific points you need to be aware of when changing the value of the CONTROL register:
• After modifying the CONTROL register, as specified by the Armv8-M architecture reference manual, an Instruction Synchronization Barrier (ISB) instruction should be used to ensure the effect of the update applies immediately to any subsequent code. Since the SPSEL and then PRIV settings are orthogonal (i.e., they operate independently), there are four possible combinations of settings. However, only three of them are commonly used in real world applications (Table 4.5).

Unlike other special registers, the CONTROL register can be read in unprivileged state. This allows software to determine whether the current execution level is privileged by reading the values of IPSR and the CONTROL registers:
	int in_privileged(void)
	{
		if (__get_IPSR() != 0) return 1; // True when in handler mode
		else // In thread mode
			if ((__get_CONTROL() & 0x1)==0) return 1; // True when nPRIV==0
			else return 0; // False when nPRIV==1
	}

Stack limit registers
	Cortex-M processors use a descending stack operation model. It means the stack pointers are decremented when more data is added to the stack. When too much data is pushed into a stack and the space consumed is more than the allocated stack space, the overflowing stack data can corrupt the OS kernel data and memories used by other application tasks. This can cause various types of errors and, potentially, result in security vulnerabilities.

	Stack Limit Registers are used for detecting stack overflow errors. They were introduced in the Armv8-M architecture and were not available in the previous generation of Cortex-M processors. There are four stack limit registers.

	The stack limit registers are 32-bit and can be set to the lowest address of each of the stack address ranges allocated to each stack (Fig. 4.13).Because the lowest 3 bits (bit 2 to bit 0) of these stack limit registers are always zero (writes to these bits are ignored), the stack limits are always aligned to double word boundaries.

	By default, the stack limit registers reset to 0 (the lowest address in the memory map) so that the stack limits will not be reached; effectively the stack limit checks are disabled at startup. The stack limit registers can be programmed when the processor is executing in privileged state. Please note:
		• Secure privileged software can access all stack limited registers, and
		• Non-secure privileged software can only access Non-secure stack limit registers.

	The stack limit is violated if a stack pointer goes lower than the corresponding stack limit register. The violating stack operation (i.e., the memory access to the address below the stack limit) will not take place so as to avoid corrupting memories used by other applications. The stack limit check only happens during stack related operations, such as:
		• Stack push, including during exception sequences
		• When the stack pointer is updated (e.g., when the stack is allocated for local memory use by a function).

	The stack limit check is not performed immediately when the stack limit registers are updated. This simplifies context switching operations in the design of an OS (there is no need to set the stack limit registers to 0 before updating the Process Stack Pointer (PSP)). If a stack limit violation takes place, a fault exception is triggered (UsageFault/HardFault).

Floating-point registers in Cortex-M33
	The CPACR is located at address 0xE000ED88, is privileged access only and is cleared to 0 when the processor is reset. If the TrustZone security extension is implemented this register is banked between security states. Secure software can also access the Non-secure version of the CPACR (CPACR_NS) using NS alias address 0xE002ED88. Secure software can also define whether Non-secure software can access each of the coprocessors using a register called the Non-secure Access Control Register (NSACR). The CPACR and NSACR registers are used for enabling the coprocessor interface and also the Arm Custom Instructions features.

Impact of TrustZone on the programmer’s model
	Apart from certain special registers, in general there is little difference between the programmer’s model for Secure and Non-secure software. It means most runtime libraries and assembly code can be reused in either Secure or Non-secure states when migrating from Armv6-M/Armv7-M to the Armv8-M architecture. The registers in the programmer’s model (excluding memory mapped registers) that are present when the TrustZone security extension is implemented include:
	- Secure stack pointers (MPS_S, PSP_S)
	- Secure stack limit registers (MSPLIM_S, PSPLIM_S)
	- Bit 3 of the CONTROL registers if the FPU is implemented (available in the Cortex-M33 processor)
	- A Secure version of the interrupt masking registers (PRIMASK_S, FAULTMASK_S and BASEPRI_S)

	The other registers are shared between Secure and Non-secure states. If the TrustZone security extension is not implemented, the programmer’s model of Armv8-M is very similar to the previous generation of Cortex-M processors; except that the Cortex-M33 processor has additional Non-secure stack limit registers that are not available in the Armv7-M processors.

With two exceptions, the memory features in the Cortex-M3 and the Cortex-M4 processors are available on the Cortex-M33 processor. The two exceptions are:
• Bit band access—The optional bit band feature in the Cortex-M3 and Cortex-M4 processors define two 1MB regions in the memory space to be bit addressable via two-bit band alias regions. The address remapping process of the bit band access can potentially conflict with the TrustZone security arrangements (if the security attributes of the two addresses are setup differently) and cannot therefore be included.

On the other hand, the bus interface of the Cortex-M33 processor overcomes a limitation factor of the Cortex-M3 and Cortex-M4 processors: there is no performance penalty when executing code with the system AHB (address 0x20000000 and above). Whereas, in the CortexM3/M4 processors (address 0x20000000 and above) there is a register stage which causes a delay cycle for each instruction fetch.

Because the Cortex-M33 processor has a Harvard bus architecture, instruction fetches and data access can be carried out simultaneously over two separate bus interfaces. As mentioned in Chapter 3, Section 3.5, it has a unified memory view (i.e., instruction and data access share the same 4GB address space). The CODE bus interface covers the CODE region (address 0x00000000 to 0x1FFFFFFF) and the SYSTEM bus interface covers the rest of the address space (0x20000000 to 0xFFFFFFFF), but not the Private Peripheral Bus (PPB) address range (0xE00000000 to 0xE00FFFFF).

When a Cortex-M23 or Cortex-M33 processor implements the TrustZone security technology the 4GB is divided into:
• Secure addresses—accessible by Secure software only. Part of the Secure address space can also be defined as Non-Secure Callable (NSC), which allows Non-secure software to call Secure APIs.
• Non-secure addresses—accessible by both Secure and Non-secure software.
• Exempted addresses—These are address regions that are exempted from Security checking. Both Secure and Non-secure software can access Exempted regions. Unlike the Non-secure address(es), the Exempted region(s) setting is enforced even before the processor exits from reset and, typically, is used by debug components. A comparison of the three address types as detailed above is shown in Table 4.11.

In a TrustZone based microcontroller design, the system contains Secure and Non-secure program spaces, data spaces and peripheral spaces. As a result, the memory regions in the default memory map, as shown in Fig. 4.19, is then further divided into Secure and Nonsecure sections. An example of such partitioning is shown in Fig. 4.20. The use of address bit 28 for partitioning is commonly used as it gives the largest continuous address space for each Secure and Non-secure region within each region in the default memory map. Another advantage is that the hardware design for the Implementation Defined Attribution Unit (IDAU) for address partitioning is very easy to do.

the partitioning of the address space is handled by the Security Attribution Unit (SAU) and the Implementation Defined Attribution Unit (IDAU). The SAU can contain up to 8 programmable regions, and the IDAU (typically a hardware-based address lookup component) can support up to 256 regions. Potentially, the IDAU could contain limited programmability in some devices. The IDAU, typically, is used to define the default security partitioning and the SAU is used by Secure privileged software to, optionally, override some of the IDAU’s security region definitions.

As shown in Fig. 4.19, the processor’s memory space contains a SCS. This address range contains memory mapped registers for:
- The NVIC
- The MPU
- The SysTick
- A group of system control registers called System Control Block (SCB) The SCB contains various registers for:
- Controlling processor configurations (e.g., low power modes)
- Providing fault status information (fault status registers)
- Vector table relocation (VTOR)
The SCS address range starts from address 0xE000E000 to 0xE000EFFF. If the TrustZone security extension is implemented, a number of registers (e.g., the MPU and the SysTick) could be banked between security states. In each security state the software accesses its own bank of SCS registers in the SCS address space. Secure software can also access Non-secure SCS registers using the Non-secure alias of SCS, which is in the range 0xE002E000 to 0xE002EFFF.

If the TrustZone security extension is not implemented, then physically there are two stack pointers in the Cortex-M processors. They are the:
• Main Stack Pointer (MSP)—This is the default stack pointer used after reset, and is used for all exception handlers.
• Process Stack Pointer (PSP)—This is an alternative stack pointer that can only be used in Thread mode. It is usually used for application tasks in embedded systems running an embedded operating system (OS). If the TrustZone security extension is implemented there are four stack pointers. These are:
• Secure MSP (MSP_S)
• Secure PSP (PSP_S)
• Non-secure MSP (MSP_NS)
• Non-secure PSP (PSP_NS)

Secure software uses the Secure stack pointers (MSP_S and PSP_S), and Non-secure software uses the Non-secure stack pointers (MSP_NS and PSP_NS). The stack pointers must be initialized to use the correct address space based on the security partitioning of the memory map. As mentioned in “CONTROL register” section (Section 4.2.2.3) and Table 4.4, the SPSEL bit (bit 1) of the CONTROL register is used for selecting between MSP and PSP in Thread mode:
• If SPSEL is 0, Thread mode uses the MSP for stack operations.
• If SPSEL is 1, Thread mode uses the PSP for stack operations.

Please note, the SPSEL bit is banked between security states, so Secure and Non-secure software can have different settings for the selection of the stack pointer in thread mode. Also, the values of the SPSEL bits could be automatically updated when returning from exceptions.

For simple systems without TrustZone, a minimal application could use just the MSP for all operations by keeping the SPSEL bit to 0. This is shown in Fig. 4.25. After an interrupt event is triggered, the processor first pushes a number of registers into the stack before entering the Interrupt Service Routine (ISR). This register state saving operation is called “Stacking”. At the end of the ISR, these registers are restored to the register bank, an operation is called “Unstacking”.

If an operating system is used, the stacks for each of the application threads would normally be separated from each other. The Process Stack Pointer (PSP) is therefore used for the application threads to allow easier context switching without affecting the stacks used by the privileged codes. With this arrangement, privileged codes, such as exception handlers, use the MSP, similar to the previous example (Fig. 4.25). As the thread and handler modes use different stack pointers, the SP selection switches at exception entries and exception exits. This switching is shown in Fig. 4.26. Note, automatic “Stacking” and “Unstacking” operations use the PSP because it is the currently selected SP before the exception. The separation of the stacks can prevent a stack corruption or error in an application task from damaging the stack used by the OS. It also simplifies the OS design and hence allows faster context switching.

For systems with the TrustZone security extension implemented, Secure and Non-secure software manage their corresponding SPSEL bits in the CONTROL register, and, thus, in thread mode it is possible for the processor to switch between different SPSEL settings when there are function calls between security states. In handler mode, either MSP_S or MSP_NS would be used, depending on the security domain of the exception/interrupt.

After the processor powers up:
• If the TrustZone is not implemented, the processor automatically initializes the MSP by reading the vector table.
• If the TrustZone is implemented, the processor automatically initializes the MSP_S by reading the Secure vector table.

Other stack pointers not initialized by the reset sequence have to be initialized by software. This includes the situation where Secure software needs to launch a Non-secure application after finishing its security initialization (The Non-secure MSP (MSP_NS) must be initialized by Secure software beforestarting the Non-secure application). Although just one of the SPs is selected at a time (when using SP or R13 to access it), it is possible to specify read/write directly to the MSP and PSP, providing that the processor is in privileged state. If the processor is in Secure privileged state, the software can also access the Non-secure stack pointers.

When using assembly language programming, these functions can be carried out using MRS (move from special register to general register) and MSR (move from general register to special register) instructions.

Memory protection unit (MPU)

By default, the MPU(s) are disabled after reset. In simple applications, the MPU is not used and can be ignored. In embedded systems that require high reliability, the MPU can be used to protect memory regions by means of defining access permissions in privileged and unprivileged access states. For example, an embedded OS can define the access permission for each application thread. In other cases, the MPU is configured just to protect a certain memory region, for example, to make a memory range read only.

The MPU also defines memory attributes of the system, e.g., cacheability. If the system contains a system level cache then it might be essential to program the MPU to define the cacheability attribute of certain address spaces.

Each exception source has an exception number. Exception numbers 1–15 are classified as system exceptions, and exceptions 16 and above are for interrupts. The design of the NVIC in the Cortex-M23 supports up to 240 interrupt signals and the one in the Cortex-M33 supports up to 480. However, the number of interrupts is defined by chip designers and, in practice, the number of interrupt signals implemented in the design is often far less; and are typically in the range of 16–100. With this configurability, the silicon size of the design can be reduced, which also reduces power consumption.

( IMP: figure 4.27, table 4.14 )

If the TrustZone security extension is implemented:
• Each of the interrupts (exception types 16 and above) can be configured as Secure (default) or Non-secure. This is configurable at run time.
• Some of the system exceptions are banked between security states (e.g., SysTick, SVC, PendSV, HardFault (conditionally), MemManage Fault, UsageFault).
• Some of the system exceptions target the Secure state by default, but can be configured to target the Non-secure state by software (NMI, BusFault).
• The target security state of the Debug Monitor exception is defined by the debug authentication setting (see Chapter 16).
• The Secure Fault exception targets Secure state only.

The interrupt management registers in the NVIC also define the priority levels of exceptions (for exceptions with programmable levels) and also allows, if the TrustZone security extension is implemented, each interrupt to be defined as Secure or Non-secure.

In a system with the TrustZone security extension, exception priority levels are shared between Secure and Non-secure exceptions. Therefore,
• If an interrupt is being served in one security state and another interrupt in the other security state with a higher priority level is triggered, the interrupt preemption can take place.
• If an interrupt is being served in one security state it blocks the all interrupts that have a lower or the same priority level, no matter whether those interrupts are configured as Secure or Non-secure.

If the TrustZone security extension is implemented, the interrupt masking registers are banked, and the interrupt masking behavior is based on the combined result of both Secure and Non-secure interrupt masks.

When an exception event takes place and is accepted by the processor core, the corresponding exception handler is executed. To determine the starting address of the exception handler, a vector table mechanism is used. The vector table is an array of 32-bit data inside the system memory, each representing the starting address of one exception type (Fig. 4.28).The vector table is relocatable and the base address of the vector table is controlled by a programmable register in the NVIC called the Vector Table Offset Register (VTOR). After reset, the VTOR is reset to a value defined by the chip designer; this is different from previous Cortex-M0/M0+/M3/M4 processors where the vector table offset is set to address 0x0 after reset. The vector address used to determine the starting address is: Exception type4 + VTOR. The bit 0 of the vector read from the vector table is then masked off for use as the ISR starting address. For example, if the VTOR is reset to 0, then the calculations of the vector address for reset and NMI exceptions are as follow:
(1) When handling a Reset exception, because the reset is exception type 1, the address of the reset vector is therefore 1*4 (each vector  is 4 bytes) + VTOR, which equals 0x00000004.
(2) When handling an NMI exception, the NMI vector (type 2) is located in 2*4+ VTOR=0x00000008. The address offset 0x00000000 is used to store the starting value for the MSP. The LSB of each exception vector indicates whether the exception is to be executed in Thumb state. Since the Cortex-M processors can support only Thumb instructions, the LSB of all the exception vectors should be set to 1.

If the TrustZone security extension is implemented, there two vector tables. The vector table for Secure exceptions should be placed in a Secure address range and the vector table for the Non-secure exceptions in a Non-secure address range. The VTOR register is banked into the VTOR_S (Secure VTOR) and the VTOR_NS (Non-secure).

During a system debug or processor reset operation, the debug components in Cortex-M33 processor are not reset so that the connection between the debug host (i.e., the debugger software running on the computer) and the microcontroller can be maintained. To reset the processor during a debug session, the debug host, in most cases (this might be configurable in the debug tool), makes use of the Application Interrupt and Reset Control Register (AIRCR) in the System Control Block (SCB).

In a Cortex-M33 processor system with the TrustZone security extension, the processor starts in a Secure state and the Secure vector table is used for the reset sequence. The Non-secure Main Stack Pointer (MSP_NS) is, in this instance, initialized by the Secure software. The setup of the MSP is necessary because some exceptions, such as the NMI or HardFault handler, could potentially occur shortly after the reset. The stack memory and the MSP will then be needed for the stacking process which is carried out as part of the exception handling.
