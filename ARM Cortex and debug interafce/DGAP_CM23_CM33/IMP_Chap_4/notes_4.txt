Memory protection unit (MPU)

The Memory Protection Unit (MPU) is optional in the Cortex-M33 processor. Cortex-M33 processors support 0 (no MPU)/4/8/12 or 16 MPU regions. The programmer’s model of the MPU in Armv8-M is different from that in the Armv6-M and Armv7-M architectures. This change gives better flexibility in the definitions of the MPU regions. If the TrustZone security extension is implemented, the Cortex-M23 and Cortex-M33 processors can have up to two MPUs—a Secure MPU and a Non-secure MPU. The number of supported MPU regions in these two MPUs could be different.

The MPU is programmable and the configuration of the MPU regions is managed by a number of memory mapped MPU registers. By default, the MPU(s) are disabled after reset. In simple applications, the MPU is not used and can be ignored. In embedded systems that require high reliability, the MPU can be used to protect memory regions by means of defining access permissions in privileged and unprivileged access states. For example, an embedded OS can define the access permission for each application thread. In other cases, the MPU is configured just to protect a certain memory region, for example, to make a memory range read only.

The MPU also defines memory attributes of the system, e.g., cacheability. If the system contains a system level cache then it might be essential to program the MPU to define the cacheability attribute of certain address spaces.

Each exception source has an exception number. Exception numbers 1–15 are classified as system exceptions, and exceptions 16 and above are for interrupts. The design of the NVIC in the Cortex-M23 supports up to 240 interrupt signals and the one in the Cortex-M33 supports up to 480. However, the number of interrupts is defined by chip designers and, in practice, the number of interrupt signals implemented in the design is often far less; and are typically in the range of 16–100. With this configurability, the silicon size of the design can be reduced, which also reduces power consumption.

( figure 4.27, table 4.14 )

The exception number is reflected in various registers, including the IPSR, and is used to determine the exception vector addresses. Exception vectors are stored in a vector table, and the processor reads this table to determine the starting address of an exception handler during the exception entrance sequence. The interrupt latency of the Cortex-M23 and Cortex-M33 processor is very low, only 12clock cycles.

Reset is a special kind of exception. When the processor exits from a reset it executes the reset handler in Thread mode (rather than Handler mode as in other exceptions). Also, the exception number in the IPSR is read as zero.

If the TrustZone security extension is implemented:
• Each of the interrupts (exception types 16 and above) can be configured as Secure (default) or Non-secure. This is configurable at run time.
• Some of the system exceptions are banked between security states (e.g., SysTick, SVC, PendSV, HardFault (conditionally), MemManage Fault, UsageFault).
• Some of the system exceptions target the Secure state by default, but can be configured to target the Non-secure state by software (NMI, BusFault).
• The target security state of the Debug Monitor exception is defined by the debug authentication setting (see Chapter 16).
• The Secure Fault exception is available on the Armv8-M Mainline (e.g., the Cortex-M33 processor) and targets Secure state only.

The NVIC is a part of the Cortex®-M processor. It is programmable and its registers are located in the system control space of the memory map (see Fig. 4.19). The NVIC handles the exceptions and interrupt configurations, prioritization and interrupt masking. The NVIC has the following features:
• Flexible exception and interrupt management
• Nested exception/interrupt support
• Vectored exception/interrupt entry
• Interrupt Masking

The interrupt management registers in the NVIC also define the priority levels of exceptions (for exceptions with programmable levels) and also allows, if the TrustZone security extension is implemented, each interrupt to be defined as Secure or Non-secure.

In a system with the TrustZone security extension, exception priority levels are shared between Secure and Non-secure exceptions. Therefore,
• If an interrupt is being served in one security state and another interrupt in the other security state with a higher priority level is triggered, the interrupt preemption can take place.
• If an interrupt is being served in one security state it blocks the all interrupts that have a lower or the same priority level, no matter whether those interrupts are configured as Secure or Non-secure.

The NVIC in the Cortex-M33 processor provide interrupt masking registers, for example, the PRIMASK special register. Setting the PRIMASK register disables all exceptions, excluding HardFault and NMI. This masking is useful for operations that should not be interrupted, such as time critical control tasks or real time multimedia codecs. For a Cortex-M33 based system, you can alternatively use the BASEPRI register to selectively mask exceptions or interrupts which are below a certain priority level. If the TrustZone security extension is implemented, the interrupt masking registers are banked, and the interrupt masking behavior is based on the combined result of both Secure and Non-secure interrupt masks.

When an exception event takes place and is accepted by the processor core, the corresponding exception handler is executed. To determine the starting address of the exception handler, a vector table mechanism is used. The vector table is an array of 32-bit data inside the system memory, each representing the starting address of one exception type (Fig. 4.28).The vector table is relocatable and the base address of the vector table is controlled by a programmable register in the NVIC called the Vector Table Offset Register (VTOR). After reset, the VTOR is reset to a value defined by the chip designer; this is different from previous Cortex-M0/M0+/M3/M4 processors where the vector table offset is set to address 0x0 after reset. The vector address used to determine the starting address is: Exception type4 + VTOR. The bit 0 of the vector read from the vector table is then masked off for use as the ISR starting address. For example, if the VTOR is reset to 0, then the calculations of the vector address for reset and NMI exceptions are as follow:
(1) When handling a Reset exception, because the reset is exception type 1, the address of the reset vector is therefore 14 (each vector  is 4 bytes) + VTOR, which equals 0x00000004.
(2) When handling an NMI exception, the NMI vector (type 2) is located in 24+ VTOR¼0x00000008. The address offset 0x00000000 is used to store the starting value for the MSP. The LSB of each exception vector indicates whether the exception is to be executed in Thumb state. Since the Cortex-M processors can support only Thumb instructions, the LSB of all the exception vectors should be set to 1.

If the TrustZone security extension is implemented, there two vector tables. The vector table for Secure exceptions should be placed in a Secure address range and the vector table for the Non-secure exceptions in a Non-secure address range. The VTOR register is banked into the VTOR_S (Secure VTOR) and the VTOR_NS (Non-secure).

Several exceptions listed in Table 4.14 are fault handling exceptions. Fault exceptions are triggered when the processor detects an error such as an execution of an undefined instruction, or when the bus system returns an error response to a memory access. The fault exception mechanism (Fig. 4.29) allows errors to be detected quickly and allows the system to respond to an error condition without waiting for a watchdog timer to kick in.

In Armv8-M Mainline architecture (e.g., the Cortex-M33 processor), by default all fault events trigger the HardFault exception. This is because the Bus Fault, Usage Fault, Memory Management Fault and Secure Fault are disabled by default and therefore escalate to HardFault. If these configurable fault exceptions are enabled (these exceptions can, individually, be enabled by software), then they could be triggered by specific classes of fault events. If they are, the corresponding fault handlers can then potentially utilize the fault status registers to determine the exact type of fault, and, if possible, carry out remedial action(s). Similar to Armv8-M Baseline, it is possible to configure the HardFault (as well as the BusFault) to target, except for security violations, the Non-secure state.
