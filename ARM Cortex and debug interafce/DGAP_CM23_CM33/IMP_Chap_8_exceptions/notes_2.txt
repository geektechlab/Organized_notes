When an exception or interrupt event occurs a number of steps take place to handle the exception or to service the interrupt. A simplified view of an exception handling is shown in Fig. 8.2.

The processor accepts an exception request if the following conditions are met:
• An interrupt or exception event takes place, causing its pending state register to be set to 1
• The processor is running (not halted or in reset state)
• The exception is enabled (Note: NMI and HardFault exceptions are always enabled)
• The exception has a higher priority than the current priority level
• The exception is not blocked by an exception masking register (e.g., PRIMASK)
Note: For an SVC exception, if the SVC instruction is accidentally used in an exception handler that has the same or a higher priority than the SVC exception itself, the result will be a HardFault exception.

An exception entry sequence contains a number of operations:
• It pushes the contents of a number of registers into the current selected stack––the register values include the return address. This is known as “stacking” and enables an exception handler to be written as a normal C function. If the processor was in Thread mode and wasusing the Process Stack Pointer (PSP), the stack area pointed to by the PSP will be used for this stacking. Otherwise, the stack area pointed to by the Main Stack Pointer (MSP) will be used.
• It fetches the exception vector (starting address of the exception handler/ISR). For processors with Harvard bus architecture, like the Cortex-M33 processor, this can, toreduce latency, happen in parallel to the stacking operation.
• It fetches instructions for the exception handler to execute. After the starting address of the  exception handler is determined by reading the vector table, the instructions are then fetched.
• It updates various NVIC and core registers. This includes the pending status and active status of the exception and registers in the processor core, including the Program Status Register (PSR), Link Register (LR), Program Counter (PC), and Stack Pointer (SP).
• It erases Secure information in the register bank before the ISR starts if the processor was running Secure software and is taking a Non-secure exception. This is to prevent Secure information from leaking to the Non-secure world.

Depending on which stack was used for stacking, either the MSP or PSP value would be adjusted just before the exception handler started. The PC would also be updated to the stating address of the exception handler and the LR would be updated with a special value, calledEXC_RETURN (see Section 8.10). This “special” value is 32 bits, with its upper 25 bits set to 1. Some of its lower 7 bits are used to hold status information about the exception sequence (e.g., which stack was used for stacking). This value will be used in the exception return.

Within the exception handler, the peripheral that triggered the interrupt request is serviced by software operations. The processor is in Handler mode when executing an exception handler. In Handler mode:
• the Main Stack Pointer (MSP) is used for stack operations,
• the processor executes at privileged access level.
If a higher priority exception arrives at this stage, the new interrupt will be accepted and the current executing handler will be suspended and preempted by the higher priority handler. This situation is called nested exception. If another exception with the same or with a lower priority arrives during this stage, the newly arrived exception will stay in pending state and will only be serviced when the current exception handler has finished. When the exception handler is finished, the program code executes a return which causes the EXC_RETURN value to be loaded into the Program Counter (PC). This triggers the exception return mechanism.

In some processor architecture, a special instruction is used for an exception return. However, when this is the case it means the exception handlers cannot be written and compiled as normal C code. In Arm Cortex-M processors, the exception return mechanism is triggered using a value called EXC_RETURN. This value is generated at the exception entry sequence and is stored in the Link Register (LR). When this value is written to the PC with one of the allowed exception return instructions, it triggers the exception return sequence.

The exception return can be generated by the instructions shown in Table 8.8. During an exception return, the register values of the previously interrupted program that were saved to the stack during the exception entrance are automatically restored by the processor. This operation is called unstacking. In addition, when this occurs, a number of NVIC registers (e.g., the active status of interrupts) and registers in the processor core (e.g., PSR, SP, CONTROL) will be updated.

In parallel to the unstacking operation, for processors with the Harvard bus architecture, such as the Cortex-M33, the processor will start fetching the instructions of the previously interrupted program to allow the program to quickly resume its operations. The use of the EXC_RETURN value for triggering exception returns allows exception handlers (including Interrupt Service Routines) to be written as a normal C function/subroutine.

In code generation, the C compiler handles the EXC_RETURN value in LR as a normal return address. Because of the values used by the EXC_RETURN mechanism, it is not possible to have a normal function return to address 0xF0000000 to 0xFFFFFFFF. However, since the architecture specifies that this address range cannot be used for program code (because it has a Execute Never (XN) memory attribute) it does not cause any software problems.

Each of the interrupts and exceptions in Arm Cortex-M processors has an exception priority level. When a higher priority level interrupt/exception occurs during a lower priority interrupt/exception service, it preempts the lower priority service. This is known as nested interrupt/exception handling. In Cortex-M processors:
• A higher value in the priority level register means a lower priority level (see Fig. 8.3).
• A priority level with a value of zero is the highest level for a programmable interrupt/ exception.
• Some system exceptions (NMI, HardFault, and reset) have fixed/non-programmable priority levels of negative values––hence a higher priority than interrupts/exceptions with programmable priority levels.

In Armv8-M processors with a Main extension (e.g., the Cortex-M33 processor) and in Armv7-M processors:
• The implemented width of the priority level registers is configurable by chip designers. The minimum width is 3 bits (8 levels) and the maximum is 8 bits (256 levels, with a maximum of 128 levels of preemption).
When less than 8 bits are implemented in the priority level registers, the reduction in the number of priority level registers is achieved by cutting out the Least Significant Bit (LSB) portion of the priority configuration registers. In this way, when a software binary image moves to a device which has fewer priority levels, this will not cause, an inversion of the priority levels––which can occur if the MSB (Most Significant Bits) is lost.

( FIG. 8.4 Priority level registers of Cortex-M23 and Cortex-M33 processors. )

The interupt/exception priority level decides whether an incoming interrupt/exception is accepted by the processor:
• If the incoming interrupt/exception event has a higher priority level than the processor’s current priority level, then the interrupt/exception request will be accepted and the exception entry sequence will start.
• If the incoming interrupt/exception event has the same or a lower priority level than the processor’s current priority level, then the incoming interrupt/exception request is blocked and held in a pending status register (to be served later). This is caused when any of the following conditions occurs:
	• The processor is already serving another interrupt/exception of the same/higher priority level, or
	• An interrupt/exception mask register is set which changes the processor’s current effective priority level to the same/higher priority level as the incoming interrupt/ exception

There are a few exceptions: For example, if an SVC or a synchronous fault exception is triggered and the priority level is insufficient to execute the corresponding fault handler, then the exception event will be escalated to a HardFault exception. Several system exceptions have fixed priority levels of negative values (Table 8.9). If the TrustZone security extension is not implemented, the Secure HardFault is not present. AIRCR.BFHFNMIS is a programmable bit and is only accessible by Secure privileged software. If TrustZone is being used then AIRCR.BFHFNMIS should be set to 0.

The priority level of exceptions and interrupts are controlled by priority level registers. These registers are memory mapped and can be accessed in privileged state only. By default, all priority level registers have a value of 0 when the processor starts from reset.

( TABLE 8.9 Priority levels of system exceptions. )

8-bit priority level registers are further divided into two halves:
- The upper half (left bits) is the group priority for the preemption control
- The Lower half (right bits) is the subpriority
The exact division of group priority and subpriority is controlled by a bit field in the AIRCR called PRIGROUP (priority grouping, Table 8.10). This register is only available for Armv8-M processors with the Main extension (i.e., Mainline subprofile) and is banked between security states. Using the PRIGROUP bit field, the maximum level of interrupt/exception nesting can be controlled. The group priority level defines whether an interrupt can take place when the processor is already running another interrupt handler. The subpriority level value is only used when two exceptions with the same group priority level have occurred at the same time. In such a case, the exception with the higher subpriority (lower value) will be handled first.

In some applications, it is essential to arrange for some of the Secure interrupts or Secure system exceptions to have a higher priority than the Non-secure interrupts/exceptions. This is to ensure the background Secure software services operates correctly. For example, a device could have a certified Bluetooth software service running in the background and its operation must not be affected by a failure of applications running on the Non-secure side. To meet this requirement, TrustZone for Armv8-M allows Secure software to prioritize, if needed, Secure exceptions and interrupts. The Secure exceptions/interrupt prioritization is controlled by a programmable bit in the AIRCR called PRIS (Prioritize Secure exception). By default, this bit is set to 0 out of reset, which means Secure and Non-secure exceptions/interrupts share the same configurable programmable priority level space for level 0 to 0xFF (Fig. 8.5). When the AIRCR.PRIS is set to 1, although Non-secure software will still see it has exception/interrupt priority levels 0 to 0xFF, the effective level value will be shifted by 1 bit and placed in the  lower half of the Secure exception/interrupt priority level space (Fig. 8.6). While AIRCR.PRIS can, to some extent, protect background Secure exception/interrupt services, the services can still be stopped if the halting debug is enabled (subject to debug authentication configuration). The system can also be stopped by a reset or the powerdown of the device. The Secure interrupt/exception prioritization feature is available in all Armv8-M processors when the TrustZone security extension is implemented.

In Armv8-M processors with TrustZone, the interrupt masking registers (PRIMASK, FAULTMASK, and BASEPRI) are banked between security states. Since the priority level space is shared between the Secure and the Non-secure world, setting an interrupt mask register on one side can block some, or all, of the exceptions on the other side. AIRCR.PRIS also affects the operations of the interrupt masking registers. For example, if the AIRCR.PRIS is set to 1, and the Non-secure software sets the Non-secure PRIMASK (PRIMASK_NS) to 1, then, on the Secure side, although Secure exceptions with priority level 0x80 to 0xFF are blocked, on the Non-secure side all Non-secure exceptions with configurable priority levels (0x0 to 0xFF) are blocked.
