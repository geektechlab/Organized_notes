SysTick System tick timer(s) is basic 24-bit timer for OS periodic interrupt operations, or for other timekeeping purposes. If TrustZone is present there can be up to two SysTick timers.

The Cortex-M33 processor has a three-stage pipeline:
• First stage: Instruction fetch and predecoding.
• Second stage: Decode and simple execution.
• Third stage: Complex execution. Some of the operations are completed at the second pipeline stage. This arrangement enables low power consumption and also better efficiency. This processor pipeline design also supports the limited dual issue of 16-bit instructions.

The higher performance of Cortex-M33 processor is due to:
• A richer instruction set;
• Use of Harvard bus architecture to allow concurrent data and instruction fetches;
• Limited dual-issue capability.

The instruction set used in Arm Cortex-M processors is called the Thumb® instruction set. Except for double-precision floating-point instructions and cache preload instructions, all instruction supported in the Cortex-M7 processors are available in the Cortex-M33. (Note: The Cortex-M33 does not have a double-precision FPU option or a cache memory controller feature.)

Many of the instructions used in the Armv8-M Baseline instruction set are 16-bit in size. This enables high code density. For general data processing and control tasks, the program code can be composed of mostly 16-bit instructions (instead of 32-bit) to reduce the size of program memory.

Both the Cortex-M23 and Cortex-M33 processors have a 4GB unified address space (32-bit address). Unified means that there is only one address space, even though there can be more than one bus interface. For example, the Cortex-M33 processor is based on Harvard bus architecture, which allows simultaneous instruction and data access, but that does not mean that the system has 4GB of memory space for instructions and another 4GB of memory space for data.

This 4GB address space is divided into a number of regions in the architecture’s definition (IMP: Fig. 3.4). Some address ranges in the Private Peripheral Bus (PPB) are allocated to internal components, i.e., the Nested Vectored Interrupt Controller (NVIC), Memory Protection Unit (MPU), and a number of debug components. The rest of the memory regions have predefined memory attributes, making them particularly suitable for storing program (e.g., in the CODE region), data (e.g., in the SRAM region), and for accessing peripherals (e.g., in the Peripheral region). The usage of the memory region is fairly flexible. For example, you can execute programs from the SRAM and RAM regions. If necessary, some of thememory attributes can be overriddenwith theMPU (Memory Protection Unit).

If the Cortex-M23/Cortex-M33 based system supports the TrustZone security extension, then the memory space is divided into Secure and Non-secure address ranges. This partitioning can be programmable using the Security Attribution Unit (SAU) and the Implementation Defined Attribution Unit (IDAU). Both Secure and Non-secure software needs their own program, data, and peripheral address spaces.

The Cortex-M33 processor uses Harvard bus architecture and has two AHB5 master interfaces. One is for access to the CODE region and the other is for access to the rest of the memory space (apart from the Private Peripheral Bus (PPB)). This arrangement allows program fetches to the CODE region and access to data in the RAM or in a peripheral to be carried out at the same time.

The Cortex-M33 processor also has an additional PPB interface for the connection of optional debug components.  This interface is based on the Advanced Peripheral Bus (APB) protocol from AMBA 4.

There are two types of memory access controls in the Cortex-M23 and Cortex-M33 processor systems (Fig. 3.5):
	1. A mechanism for defining access permissions based on the separation of Secure and Non-secure memories:
		If the TrustZone security extension is implemented, then the memory space is partitioned into Secure and Non-secure address ranges. The Secure software can access both sets of address ranges, but the Non-secure software can only access the Non-secure address range. If a Non-secure software component tries to access a Secure memory address a fault exception is triggered and the access is blocked.

		On the system level, further transfer filtering mechanisms can be put in place to block transfers based on the address location and the security attribute of the bus transaction. The partition of Secure and Non-secure address ranges is handled by the SAU and the IDAU.

	2. A mechanism for defining access permissions based on the separation of Privileged and Unprivileged software:
		The concept of privileged and unprivileged executionlevels in processors has been around for a number of years. In a system with an Operating Systems (OS), the OS kernel and exception handlers are executed at privileged access level and application threads are (usually) executed using at unprivileged access level. Using a Memory Protection Unit (MPU), the access permission of unprivileged threads/tasks can be restricted.

		If the TrustZone security extension is implemented, there can be two MPUs inside the processor (both of them are optional).One would be used for managing access permissions for Secure software and the other would be used for managing access permissions for Non-secure software.

		In a TrustZone capable system, the two types of memory protection mechanisms can work together. If the executing software attempts to access a memory location and the access permission check fails one of the protection measures, the transfer is blocked from reaching the memory/peripheral. A fault exception is then raised to handle the issue.

In Arm processors, interrupts (e.g., IRQs generated by peripherals) are a subset of exceptions. Exceptions also include fault event handling and OS supporting exceptions. In Cortex-M processors, exceptions (including interrupts) are handled by the built-in Nested Vectored Interrupt Controller (NVIC).

The words “Nested” and “Vectored” in NVIC mean:
Nesting of interrupt services is automatically handled by the processor without any need for software intervention. For example, during the execution of a low priority interrupt service a high priority interrupt can be serviced as normal.

Cortex-M33:
• Number of interrupt inputs: 1–480
• Non-Maskable Interrupt (NMI) input: Yes
• Width of priority level registers: 3-bit (8 programmable levels) to 8-bit (256 programmable levels)
• Interrupt masking registers: PRIMASK, FAULTMASK, and BASEPRI
• Interrupt latency in number of clock cycles (assuming a zero wait state memory system is being used): 12
• Vectored interrupt handling: The starting program address of interrupt service routines (ISRs) is obtained automatically from a vector table by the processor’s hardware. There is no need to use software to determine which interrupt request needs servicing, which reduces the latency of the interrupt service(s).

If the TrustZone security extension is implemented, each of the interrupt sources can be programmed as Secure or Non-secure. Because there are two vector tables, the Secure and Non-secure vector tables are separated and are respectively placed in Secure and Non-secure memory spaces.

Architecturally, Cortex-M processors support sleep and deep-sleep modes.

Wakeup Interrupt Controller (WIC): This is a small hardware block separated from the NVIC to allow interrupt requests to be detected and will “wake up” the system even when the clock signals to the processor has stopped, or when the processor is placed in a powerdown state (e.g., when state-retention power gating is used).

State Retention Power Gating (SRPG) support: SRPG, is used with sleep modes, powers down most of the digital logic hardware in the processor. During SRPG sleep, only a smallnumber of transistors are powered to keep the states (0/1) of the processor’s registers. In this way, when an interrupt arrives, the processor is able to very quickly resume operations.

Cortex-M33 processor are designed to support a wide range of embedded Operating Systems (OSs) (this includes Real-Time OS (RTOS)). The OS support features include:
• Banked stack pointers to enable easy context switching.
• Stack-limit registers for stack-limit checking.
• The ability to separate between privileged and unprivileged states.
• Memory Protection Unit(s) (MPUs): The OS can use the MPU to restrict access permissions of unprivileged threads.
• Exception types dedicated to OS support: Including SuperVisor Call (SVCall) and Pendable SuperVisor call (PendSV).
• A small 24-bit system tick timer called SysTick for periodic OS interrupt generation. If the TrustZone security extensionisimplemented there can be two SysTick timers in the processor.

The Cortex-M33 processor supports an optional coprocessor interface to allow chip designers to add hardware accelerators that are directly coupled to the processor. The coprocessor interface can be used in many ways. For example, it can be used for connecting accelerators for mathematical operations and for cryptography. The key features of this interface:
• Includes the support of 32-bit and 64-bit transfers between the processor and the coprocessor’s registers in a single clock cycle.
• Using a single instruction, a custom-defined operation command can be transferred with data simultaneously.
• Include the ability to support up to eight coprocessors, with each of them able to support a number of coprocessor registers.
• Include support for TrustZone technology. Each coprocessor can be assigned as Secure or Non-secure. At the interface level, there is also a security attribute to allow the fine grain security control of each individual coprocessor register/operation.

The Arm Custom Instructions (architecturally known as Custom Datapath Extension) is a new feature that was not available in previous Arm processors. It accelerates processing tasks. The Cortex-M33 processor is the first Arm processor to support the Arm Custom Instructions feature.

Unlike the coprocessor instructions, which require the hardware accelerators to include their own coprocessor registers, Arm Custom Instructions allows chip designers to create customer accelerator(s) which can then be integrated into the processor’s data-path. This arrangement speeds up specialized data processing operations by directly using the processor’s registers. This enables lower latency when using hardware accelerator(s). By architectural definition, the operations in Arm Customer Instructions can support 32-bit, 64-bit, and vector data (including integer, floating-point, and vector operations). Not all of these instructions  are included in the Cortex-M33 implementation.

There are many enhancements when one compares the Cortex-M33 processor with the Cortex-M3/M4 range of processors (Fig. 3.7). A number of the aforementioned enhancements are similar to those that are found in the Cortex-M23 processor:
• TrustZone: An optional security extension.
• MPU (Memory Protection Unit): The programmer’s model of the MPU has been updated. Additionally, the maximum number of MPU regions has been increased from 8 to 16.
• MTB (Micro Trace Buffer): A low-cost instruction trace solution. Previously this was not available in the Cortex-M3 and Cortex-M4 processors.
• Breakpoints and watchpoint units: A new programmer’s model has been introduced in the Armv8-M architecture to provide better flexibility.
• NVIC (Nested Vectored Interrupt Controller): The maximum number of interrupts  supported in the Cortex-M33 has increased to 480 compared to 240 in the Cortex-M3/M4 processor.
• SysTick timer: A small 24-bit system tick timer for OS period interrupts or for other timing purposes. An Armv8-M processor can support up to two SysTick timers —one for Secure operations and the other for Non-secure operations.
• Stack limit checking: Detects stack overflow errors in both Secure and Non-secure stack pointers and triggers a fault exception to handle the issue.
• Floating point unit (FPU): The architecture of the floating-point instructions has been updated from FPv4 to FPv5.
• The DSP/SIMD instruction set is optional, making the processor more configurable than before.
• Coprocessor interface: A new interface allowing chip designers to add hardware accelerators to the chip that are closely coupled to the processor.
• Arm Custom Instructions: This feature allows silicon designers to add custom data processing instructions to a Cortex-M33 processor. This feature is to be added in revision 1 of the Cortex-M33 design during mid-2020.
• There are also a number of instruction-set enhancements (Table 3.7).
• The Cortex-M33 processor allows the initial addresses of the vector tables to be defined by chip designers. This is not configurable in the Cortex-M3 or Cortex-M4 processors.

For software developers that develop Secure firmware with TrustZone technology, there are new C language extension features known as Cortex-M Security Extension (CMSE), is part of the Arm C Language Extension (ACLE). ACLE is an open specification and is supported by many compiler vendors.

see Table 3.8.

IMP: see ( FIG. 3.8 )

why TrustZone security technology is needed.
• Since application threads run at unprivileged level, they do not have direct access to interrupt management and, therefore, privileged software must provide interrupt management services to these threads. The system services are typically handled via the SuperVisor Call (SVCall) exception—a process that increases software complexity and overhead in execution timing. 
• Software vulnerabilities in privileged codes like peripheral drivers (including interrupt handlers) can potentially allow hackers to gain privileged execution level and hence have full access to the system.
• Microcontrollers with preloaded on-chip firmware might need to be protected against untrusted software developers as hackers could pose as software developers, purchase the chips and then try to reverse engineer them.
• peripheral interrupt handlers can have bugs and this could lead to vulnerabilities. Because interrupt handlers execute in a privileged state, if a hacker manages to successfully attack and compromise a peripheral interrupt handler, the hacker would then be able to disable the MPU; and would also be able to access other address spaces that are privileged access only and thus compromise the system.
• some microcontrollers have included communication protocol software stacks and various software features that enable secure IoT connections. This makes it easier for software developers to create IoT solutions (Fig. 3.9), but does lead to new challenges:
	• Firmware protection features are needed to allow microcontroller vendors to protect their preloaded firmware from being copied or reverse engineered, especially when that software is licensed from a third-party company.
	• Secure storage features are needed to protect data used for establishing secure IoT connections. For example, secret keys or certificates could be stored on the chip. These protection features are needed to prevent device cloning and to prevent the reverse engineering of authentication details.
	• Because privileged access to these devices is essential to software developers and therefore has to be allowed, the MPU solution will not be of any use for protecting the firmware assets or the secret keys as previously mentioned.

Similar to TrustZone available in the Cortex-A processors, software running in the Secure world can access both Secure and Non-secure memories and resources; but the Non-secure world can only access Non-secure memories and resources. In Cortex-M33 processors, the TrustZone security extension is optional. If it is not implemented (the decision is made by the chip designer), then only the Non-secure world exists.

The normal execution environment (Non-secure world) is mostly unchanged from previous Cortex-M processors, minimal modifications are required (e.g., RTOS would need to be updated). The additional protected environment (Secure world) is also similar to the normal environment. In fact, for most bare metal applications, the same code can run in either world. The Secure world does, however, provide additional control registers for security management. Additionally, there are a number of hardware resources (e.g., SysTick timers, MPUs) available for each of the two worlds. The separation of Secure and Non-secure world provides a way for security-critical operations and resources to be protected.

At the same time, however, because the architecture allows direct function calls to take place between  security domain boundaries (Fig. 3.11), with only a very small amount of software overhead. Security features can still be accessed efficiently by normal applications via a range of protected Application Programming Interfaces (APIs). To make the API call mechanism secure, a function call from a Non-secure to a Secure function is only allowed when the first instruction is an Secure Gateway (SG) instruction and is in a secure memory address marked with a Non-secure Callable (NSC) attribute. This prevents Non-secure code from branching into the middle of a secure API or other secure memory locations. Similarly, switching from a Non-secure to a Secure state when returning from a Non-secure function call is also protected, but by way of a different mechanism: it is called FNC_RETURN (function-return).

The Armv6-M/Armv7-M architecturally defined memory map in the 4GB address space remains unchanged in the Armv8-M architecture. But the security extension divides the memory map further into Secure and Non-secure spaces so that both worlds contain its own program memory, data memory, and peripherals. This partitioning is defined by a new block called the Security Attribution Unit (SAU) and, optionally, an Implementation Defined Attribution Unit (IDAU) (Fig. 3.12). The exact memory partitioning is up to the chip designer and the creators of Secure firmware (who define the memory partitioning configurations in the programming of the SAU).

The security state of the processor is determined by the security attribute of the program address:
• When executing Secure firmware in the Secure memory the processor is in a Secure state.
• When executing codes in the Non-secure memory the processor is in a Non-secure state.

Switching of the processor state is monitored by hardware to ensure that there are no illegal state transitions. To ensure the integrity of each world, the stack address spaces and vector tables of the Secure and the Non-secure worlds are separate. As a result, the stack pointers are banked between security states. To facilitate stronger security, a stack limit check feature is used for both secure and non-secure. Because of the need to have both Secure and Non-secure peripherals, each of the interrupts can be assigned as Secure or Non-secure by the secure software. The security state transitions can be triggered by exception sequences, such as exception preemption and exception return (Fig. 3.13).

Since Secure and Non-secure software use the same physical registers (except stack pointers), Secure register contents are protected automatically by the processor’s exception handling sequences to prevent the leaking of Secure information. To enable Root-of-Trust security, the processor starts up in Secure state. After security management blocks are programmed (e.g., configuration of memory partitioning and interrupt assignments), the Secure software is then able to execute the start-up code in the Nonsecure world (Fig. 3.14). Applications running in the Non-secure world operate in almost the same way as they do  in traditional Cortex-M systems. They have full control of Non-secure (NS) memories, NS peripherals, NS interrupt management registers, and the NS Memory Protection Unit (MPU).

In addition, it is also possible to make use of other APIs provided in the secure firmware to access other features (e.g., cryptography functions). Secure firmware can, optionally, also make use of APIs (e.g., I/O driver libraries) that can be placed in the Non-secure memory.

In some of the latest IoT microcontroller designs, the chips have a range of preloaded firmware for IoT connectivity. This firmware might include preloaded security certificates or security keys, which allow software developers to create applications that establish secure connections to cloud services by accessing APIs in the preloaded firmware. TrustZone technology is a very good fit in such instances and Fig. 3.15 ( IMP ) demonstrates an example of this fit. In such TrustZone based systems, it is expected that:
• The security keys (including crypto keys) are not accessible from the Non-secure world— all cryptography operations are handled by the preloaded firmware.
• Security resources, such as secure storage, unique ID and True Random Number Generator (TRNG) are also protected. TRNG needs to be protected as it might contain entropy for session keys generation (session keys are used for protecting a secure internet connection).
• The firmware update mechanism is also protected. When the protection feature is enabled, only program images that are validated (e.g., correctly signed using crypto operations) can be used to update. Such protection is used with the Life Cycle State (LCS) management support of the product and with the debug authentication feature. An example of LCS management can be defined at chip level as (Table 3.9).
• The chip contains Non-volatile memory (NVM) for LCS management. NVM’s have a protection mechanism to prevent the reversing of the LCS.
• The Secure software would, optionally, implement system health check services that run in the background when the system is deployed. This can be triggered by a Secure timer interrupt so it is run periodically. The priority level of this timer interrupt can be configured at a higher level than the other Non-secure interrupts so that it cannot be blocked by Non-secure software.

In a TrustZone capable IoT microcontroller, since the security critical resources are protected, the hacker:
• Cannot reprogram/erase the flash memory
• Cannot steal the secret keys
• Cannot clone the device
• Cannot stop Secure software services (e.g., health checking services)

If a health checking service is implemented, it could potentially detect the attack (or detect abnormal system behavior) and trigger system recovery actions. Since the flash memory would not have been modified, the system would be able to recover by simply restarting.

In addition to IoT microcontrollers, TrustZone is used for:
• Firmware protection: In some instances, microcontroller vendors need to integrate thirdparty software components into a device and need to ensure that the firmware assets cannot be reverse engineered. TrustZone technology enables the firmware assets to be protected, while still allowing software developers to make use of the software components.
• Protecting the operations of a certified software stack: Since the operation of critical Secure operations can be protected, some of the certified software like Bluetooth software stacks can use TrustZone to protect its operations. Even if a Non-secure application was programmed incorrectly or crashes, the protected Bluetooth operations remain functional and its certification is not voided.
• Consolidation of multiple processors into one: Previously, in some of the complex SoC designs, there were multiple Cortex-M processor subsystems to isolate Secure and Nonsecure data processing. With the TrustZone capability available in the Cortex-M23 and Cortex-M33 processors, it is now possible to merge some of those processor systems.
• Providing a sandboxed software execution environment: In some operating system designs, the security partitioning feature enables the OS to execute software components in a sandboxed environment.
