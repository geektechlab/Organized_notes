	- EZI2C deepsleep: Played with WFE and WFI and frequent IPC from other core for logs was not allowing it to enter deepsleep. We disable all peripherals and enabled Primask to disable all and it worked. Then we used BASEPRI and changed it;s level and found when IPC interrupt was blocked it worked. IPC interruot was occuring rarely so we didn't notice it. Then we updated other core's logic to use different method for generating logs. Modified another core to pass logs using GPIO configured as UART bitbanging.

	- SDIO communication with DMA was failing after each 51 thread call. First we thought there was some issue that thread might be allocating extra heap memory and malloc NULL check might be missing. But after some debugging we found it was not a case. Then we checked if normal SDIO works. Then we focused on DMA. Because only 51 thread call was using shared data with core. DMA was acting as a bus master and D-Cache were not invalidated. So, added a call to invalidate D-cache only for DMA case and to maintain performance gain from cache and keep DMA happening.

	- Wanted to reduce interrupt latency and interrupt handler. We can't control much about interrupt latency in ARM core but few things can be changed. We ensured interrupt priority is high enough to not get masked/tail chained by other priority interrupt and also used FPU lazy stacking so that FPU stack area gets allocated but FPU register stacking happens only if FPU is used. Also modified logic to NVIC mux.
		Then put a code into ITCM so that DMA also can happen but interrupt code from DMA is not much useful ( to say or avoid because ITCM might not be known ). Then added it to cache and modified code to support cache because it was sending some array. add inline ?

	- While integrating with RTOS, whenever SVC instruction was called, we got hardfault handler. We weren't getting secure fault so we were sure that it is not related to branching to S from NS without NSC. Then we checked few registers from system control block ( SCB ) to get information about fault causes like memmanage, fault and bus error. From there we got to know that bus error was escalated ?. Then we checked what instruction was at SVC handler and found that due to some issue in linker script, part of vector table was overwritten/replaced by other sections. So, other interrupts were working correctly but only SVC handler had issue. After correcting linker script, issue got fixed.

	- SPI to support different length of transmission and reception. Since it is master driven, when Rx is larger, Tx has to send extra filler data to keep bus alive and extra data can be discarded at slave side. When Tx is larger than Rx, it is not an issue because if Rx sedns something or doesn't send, data received at Tx can be discarded because clock control is on master side.

	- In USB device middleware, middleware was failing to connect for some vendor specific device implementation. While debugging through wireshark we found that all configurations were set correctly but it failed at end. After some debugging and taking snapshot of protocol handling via ellysis USB analyzer, we found that it failed after setting some configuration in middleware. So, by code walk we found that vendor specific implementation didn't use any data endpoints and it was hanging. Same could have been case in bill board device. So, we update middleware to check if endpoints will be used and configure only if required. W-9694

	