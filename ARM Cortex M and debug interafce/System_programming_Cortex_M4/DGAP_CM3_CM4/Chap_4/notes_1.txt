The Cortex-M3 and Cortex-M4 processors have two operation states and two modes. In addition, the processors can have privileged and unprivileged access levels. These are shown in Figure 4.1. The privileged access level can access all resources in the processor, while unprivileged access level means some memory regions are inaccessible, and a few operations cannot be used. In some documents, the unprivileged access level might also be referred as “User” state, a term inherited from ARM7TDMI.

Operation states
    • Debug state: When the processor is halted (e.g., by the debugger, or after hitting a
      breakpoint), it enters debug state and stops executing instructions.
    • Thumb state: If the processor is running program code (Thumb instructions), it
      is in the Thumb state. Unlike classic ARM processors like ARM7TDMI, there
      is no ARM state because the Cortex-M processors do not support the ARM instruction set.

Operation modes
    • Handler mode: When executing an exception handler such as an Interrupt Service Routine (ISR).
      When in handler mode, the processor always has privileged access level.
    • Thread mode: When executing normal application code, the processor can be
      either in privileged access level or unprivileged access level. This is controlled by
      a special register called “CONTROL.”
      Software can switch the processor in privileged Thread mode to unprivileged
      Thread mode. In simple applications, the unprivileged Thread mode can be unused can use priviledge mode only.
      However, it cannot switch itself back from unprivileged to privileged.
      If this is needed, the processor has to use the exception mechanism to handle the switch.

The separation of privileged and unprivileged access levels allows system designers to develop robust embedded systems by providing a mechanism to safeguard memory accesses to critical regions and by providing a basic security model. For example, a system can contain an embedded OS kernel that executes in privileged access level, and application tasks which execute in unprivileged access level. In this way, we can set up memory access permissions using the Memory Protection Unit (MPU) to prevent an application task from corrupting memory and peripherals used by the OS kernel and other tasks. If an application task crashes, the remaining application tasks and the OS kernel can still continue to run.

Besides the differences in memory access permission and access to several special instructions, the programmer’s model of the privileged access level and unprivileged access level are almost the same. Note that almost all of the NVIC registers are privileged access only.

Similarly, Thread mode and Handler mode have very similar programmer’s models. However, Thread mode can switch to using a separate shadowed Stack Pointer (SP). Again, this allows the stack memory for application tasks to be separated from the stack used by the OS kernel, thus allowing better system reliability. By default, the Cortex-M processors start in privileged Thread mode and in Thumb state. In many simple applications, there is no need to use the unprivileged Thread model and the shadowed SP at all (see Figure 4.2). Unprivileged Thread model is not available in the Cortex-M0 processor, but is optional in the Cortex-M0+ processor.

The debug state is used for debugging operations only. This state is entered by a halt request from the debugger, or by debug events generated from debug components in the processor. This state allows the debugger to access or change the processor register values. The system memory, including peripherals inside and outside the processor, can be accessed by the debugger in either Thumb state or debug state.

Similarly to almost all other processors, the Cortex-M3 and Cortex-M4 processors have a number of registers inside the processor core to perform data processing and control. Most of these registers are grouped in a unit called the register bank. In the ARM architecture, if data in memory is to be processed, it has to be loaded from the memory to registers in the register bank, processed inside the processor, and then written back to the memory, if needed. This is commonly called a “load-store architecture.” By having a sufficient number of registers in the register bank, this arrangement is easy to use, and allows efficient program code to be generated using C compilers. For instance, a number of data variables can be stored in the register bank for a short period of time while other data processing takes place, without the need to be updated to the system memory and read back every time they are used.

The register bank in the Cortex-M3 and Cortex-M4 processors has 16 registers. Thirteen ( R0-R12 ) of them are general purpose 32-bit registers. Other three have special uses ( R13- SP, R14-LR, R15-PC ). See in Figure 4.3. Registers R0 to R12 are general purpose registers. The first eight (R0 - R7) are also called low registers. Due to the limited available space in the instruction set, many 16-bit instructions can only access the low registers. The high registers (R8 - R12) can be used with 32-bit instructions, and a few with 16-bit instructions, like MOV (move). The initial values of R0 to R12 are undefined. R13 is the Stack Pointer. It is used for accessing the stack memory via PUSH and POP operations. Physically there are two different Stack Pointers: the Main Stack Pointer (MSP, or SP_main in some ARM documentation) is the default Stack Pointer. It is selected after reset, or when the processor is in Handler Mode. The other Stack Pointer is called the Process Stack Pointer (PSP, or SP_process in some ARM documentation). The PSP can only be used in Thread Mode. The selection of Stack Pointer is determined by a special register called CONTROL. In normal programs, only one of these Stack Pointers will be visible. Both MSP and PSP are 32-bit, but the lowest two bits of the Stack Pointers (either MSP or PSP) are always zero, and writes to these two bits are ignored. In ARM Cortex-M processors, PUSH and POP are always 32-bit, and the addresses of the transfers in stack operations must be aligned to 32-bit word boundaries. For most cases, it is not necessary to use the PSP if the application doesn’t require an embedded OS. Many simple applications can rely on the MSP completely. The PSP is normally used when an embedded OS is involved, where the stack for the OS kernel and application tasks are separated. The initial value of PSP is undefined, and the initial value of MSP is taken from the first word of the memory during the reset sequence.

R14 is also called the Link Register (LR). This is used for holding the return address when calling a function or subroutine. At the end of the function or subroutine, the program control can return to the calling program and resume by loading the value of LR into the Program Counter (PC). When a function or subroutine call is made, the value of LR is updated automatically. If a function needs to call another function or subroutine, it needs to save the value of LR in the stack first. Otherwise, the current value in LR will be lost when the function call is made. During exception handling, the LR is also updated automatically to a special EXC_RETURN (Exception Return) value, which is then used for triggering the exception return at the end of the exception handler.

R15 is the Program Counter (PC). It is readable and writeable: a read returns the current instruction address plus 4 (this is due to the pipeline nature of the design, and compatibility requirement with the ARM7TDMI processor). Writing to PC (e.g., using data transfer/processing instructions) causes a branch operation. Since the instructions must be aligned to half-word or word addresses, the Least Significant Bit (LSB) of the PC is zero. However, when using some of the branch/memory read instructions to update the PC, you need to set the LSB of the new PC value to 1 to indicate the Thumb state. Otherwise, a fault exception can be triggered, as it indicates an attempt to switch to use ARM instructions (i.e., 32-bit ARM instructions as in ARM7TDMI), which is not supported. In high-level programming languages (including C, C++), the setting of LSB in branch targets is handled by the compiler automatically. ( See table 4.1 ) In most cases, branches and calls are handled by instructions dedicated to such operations. It is less common to use data processing instructions to update the PC. However, the value of PC is useful for accessing literal data stored in program memory. So you can frequently find memory read operations with PC as base address register with address offsets generated by immediate values in the instructions.

Besides the registers in the register bank, there are a number of special registers (Figure 4.4). These registers contain the processor status and define the operation states and interrupt/exception masking. Special registers are not memory mapped, and can be accessed using special register access instructions such as MSR and MRS.
    • MRS <reg>, <special_reg>; // Read special register into register
    • MSR <special_reg>, <reg>; // write to special register
Do not confuse these special registers with “special function registers (SFR)” in other microcontroller architectures, which are commonly referred to as registers for I/O control.

The Program Status Register is composed of three status registers ( collectively called xPSR ) ( see figure 4.4,4.5,4.6 ) ( see table 4.5 ):
• Application PSR (APSR)
• Execution PSR (EPSR)
• Interrupt PSR (IPSR)

These three registers (Figure 4.5) can be accessed as one combined register, referred to as xPSR in some documentation. In ARM assembler, when accessing xPSR (Figure 4.6), the symbol PSR is used. For example:
• MRS r0, PSR ; // Read the combined program status word
• MSR PSR, r0 ; // Write combined program state word

You can also access an individual PSR (Figure 4.5). For example:
• MRS r0, APSR ; // Read Flag state into R0
• MRS r0, IPSR ; // Read Exception/Interrupt state
• MSR APSR, r0 ; // Write Flag state

The PRIMASK, FAULTMASK, and BASEPRI registers are all used for exception or interrupt masking. Each exception (including interrupts) has a priority level where a (figure 4.8) smaller number is a higher priority and a larger number is a lower priority. These special registers are used to mask exceptions based on priority levels. They can only be accessed in the privileged access level (in unprivileged state writes to these registers are ignored and reads return zero). By default, they are all zero, which means the masking (disabling of exception/interrupt) is not active. The PRIMASK register is a 1-bit wide interrupt mask register. When set, it blocks all exceptions (including interrupts) apart from the Non-Maskable Interrupt (NMI) and the HardFault exception. Effectively it raises the current exception priority level to 0 ( table 4.9 ), which is the highest level for a programmable exception/interrupt. The most common usage for PRIMASK is to disable all interrupts for a time critical process. After the time critical process is completed, the PRIMASK needs to be cleared to re-enable interrupts.

The FAULTMASK register is very similar to PRIMASK, but it also blocks the HardFault exception, which effectively raises the current exception priority level to -1 ( table 4.9 ). FAULTMASK can be used by fault handling code to suppress the triggering of further faults (only several types of them) during fault handling. For example, FAULTMASK can be used to bypass MPU or suppress bus fault (these are configurable). This potentially makes it easier for fault handling code to carry out remedial actions. Unlike PRIMASK, FAULTMASK is cleared automatically at exception return.

In order to allow more flexible interrupt masking, the ARMv7-M architecture also provides the BASEPRI, which masks exceptions or interrupts based on priority level. The width of the BASEPRI register depends on how many priority levels are implemented in the design, which is determined by the microcontroller vendors. Most Cortex-M3 or Cortex-M4 microcontrollers have eight programmable exception priority levels (3-bit width) or 16 levels, and in these cases the width of BASEPRI will be 3 bits or 4 bits, respectively. When BASEPRI is set to 0, it is disabled. When it is set to a non-zero value, it blocks exceptions (including interrupts) that have the same or lower priority level, while still allowing exceptions with a higher priority level to be accepted by the processor. The FAULTMASK and BASEPRI registers are not available in ARMv6-M (e.g., Cortex-M0).

You can also access these exception masking registers with assembly code:
• MRS r0, BASEPRI ; Read BASEPRI register into R0
• MRS r0, PRIMASK ; Read PRIMASK register into R0
• MRS r0, FAULTMASK ; Read FAULTMASK register into R0
• MSR BASEPRI, r0 ; Write R0 into BASEPRI register
• MSR PRIMASK, r0 ; Write R0 into PRIMASK register
• MSR FAULTMASK, r0 ; Write R0 into FAULTMASK register

In addition, the Change Processor State (CPS) instructions allow the value of the PRIMASK and FAULTMASK to be set or cleared with a simple instruction.
• CPSIE i ; Enable interrupt (clear PRIMASK)
• CPSID i ; Disable interrupt (set PRIMASK)
• CPSIE f ; Enable interrupt (clear FAULTMASK)
• CPSID f ; Disable interrupt (set FAULTMASK)

The CONTROL register (Figure 4.9) defines:
• The selection of stack pointer (Main Stack Point/Process Stack Pointer)
• Access level in Thread mode (Privileged/Unprivileged)
• For Cortex-M4 processor with a floating point unit, one bit of the CONTROL register indicates if the current context
  (currently executed code) uses the floating point unit or not.

The CONTROL register can only be modified in the privileged access level and can be read in both privileged and unprivileged access levels. After reset, the CONTROL register is 0. This means the Thread mode uses the Main Stack Pointer as Stack Pointer and Thread mode has privileged accesses. Programs in privileged Thread mode can switch the Stack Pointer selection or switch to unprivileged access level by writing to CONTROL (Figure 4.10). However, once nPRIV (CONTROL bit 0) is set, the program running in Thread can no longer access the CONTROL register. ( Read table 4.3 ).

A program in unprivileged access level cannot switch itself back to privileged access level. This is essential in order to provide a basic security usage model. For example, an embedded system might contain untrusted applications running in unprivileged access level and the access permission of these applications must be restricted to prevent security breaches or to prevent an unreliable application from crashing the whole system. If it is necessary to switch the processor back to using privileged access level inThread mode, then the exception mechanism is needed. During exception handling, the exception handler can clear the nPRIV bit (Figure 4.11). When returning to Thread mode, the processor will be in privileged access level.

When an embedded OS is used, the CONTROL register could be reprogrammed at each context switch to allow some application tasks to run with privileged access level and the others to run with unprivileged access level. In most simple applications without an embedded OS, there is no need to change the value of the CONTROL register. The whole application can run in privileged access level and use only the MSP (Figure 4.12). The settings of nPRIV and SPSEL are orthogonal. Four different combinations of nPRIV and SPSEL are possible, although only three of them are commonly used in real world applications, as shown in Table 4.4.

There are two points that you need to be aware of when changing the value of the CONTROL register:
• For the Cortex-M4 processor with floating point unit (FPU), or any variant of ARMv7-M processors with (FPU), the FPCA bit can be set automatically due to the presence of floating point instructions. If the program contains floating point operations and the FPCA bit is cleared accidentally, and subsequently an interrupt occurs, the data in registers in the floating point unit will not be saved by the exception entry sequence and could be overwritten by the interrupt handler. In this case, the program will not be able to continue correct processing when resuming the interrupted task.
• After modifying the CONTROL register, architecturally an Instruction Synchronization Barrier (ISB) instruction (or __ISB() function in CMSIS compliant driver) should be used to ensure the effect of the change applies to subsequent code. Due to the simple nature of the Cortex-M3, Cortex-M4, Cortex-M0+,Cortex-M0, and Cortex-M1 pipeline, omission of the ISB instruction does not cause any problem.

To access the Control register in assembly, the MRS and MSR instructions are used:
• MRS r0, CONTROL ; Read CONTROL register into R0
• MSR CONTROL, r0 ; Write R0 into CONTROL register

You can detect if the current execution level is privileged by checking the value of IPSR and CONTROL:
	int in_privileged(void)
	{
		if (__get_IPSR() != 0)
		{
			return 1; // True
		}
		else if ((__get_CONTROL() & 0x1)==0)
		{
			return 1; // True
		}
		else
		{
			return 0; // False
		}
	}

The Cortex-M4 processor has an optional floating point unit. This provides additional registers for floating point data processing, as well as a Floating Point Status and Control Register (FPSCR).

S0 to S31/D0 to D15:
Each of the 32-bit registers S0 to S31 (“S” for single precision) can be accessed using floating point instructions, or accessed as a pair, in the symbol of D0 to D15 (“D” for double-word/double-precision). For example, S1 and S0 are paired together to become D0, and S3 and S2 are paired together to become D1. ( figure 4.13 ) Although, the floating point unit in the Cortex-M4 does not support double precision floating point calculations, you can still use floating point instructions for transferring double precision data.

The FPSCR contains various bit fields (Figure 4.14) for a couple of reasons:
• To define some of the floating point operation behaviors
• To provide status information about the floating point operation results

By default, the behavior is configured to be compliant with IEEE 754 single precision operation. In normal applications there is no need to modify the settings of the floating point operation control. Table 4.5 lists the descriptions for the bit fields in FPSCR. Note: The exception bits in FPSCR can be used by software to detect abnormalities in floating point operations.

Memory-mapped floating point unit control registers:
	In addition to the floating point register bank and FPSCR, the floating point unit also introduces several additional memory-mapped registers into the system. For example, the Coprocessor Access Control Register (CPACR) is used to enable or disable the floating point unit. By default the floating point unit is disabled to reduce power consumption. Before using any floating point instructions, the floating point unit must be enabled by programming the CPACR register (Figure 4.15).In the C programming environment with a CMSIS-compliant device-driver:
		SCB->CPACR j= 0xF << 20; // Enable full access to the FPU
	In assembly language programming environment, you can use the following code:
		LDR R0,=0xE000ED88 ; R0 set to address of CPACR
		LDR R1,=0x00F00000 ; R1 = 0xF << 20
		LDR R2 [R0] ; Read current value of CPACR
		ORRS R2, R2, R1 ; Set bit
		STR R2,[R0] ; Write back modified value to CPACR
