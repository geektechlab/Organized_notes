Fault address registers (BFAR, MMFAR, and SFAR)
In addition to fault status registers, Armv8-M Mainline processors also provide fault address registers (Table 13.11). These registers allow fault handlers to determine the address
values of the transfers that trigger the fault. Because this information is not always available,
the values of these address registers need to be quantified by a valid bit in the corresponding
fault status register.
The reset values of these registers are unpredictable.
Armv8-M architecture permits these fault address registers to share physical register resources, and because of this, a valid fault address could be replaced by another fault address
of a higher priority fault. This happens when a lower priority fault handler is running and
when a higher priority fault occurs in the middle of the lower priority fault handler (i.e., a
nested fault situation). The processor design takes account of this situation by ensuring:
(a) that the valid status bits of the shared fault address register are either one-hot or zero, and
(b) that it does not leak information between security states.
Due to the possibility of the nested fault situation occurring, software must take this into
account when reading the fault address register by handling the read as follows:
(1) Software reads the fault address register (either MMFAR, BFAR, or SFAR, with the read
depending on which fault exception handler is running), then
(2) Software reads the corresponding valid status bit; if the valid bit is 0, then the value of the
fault address register must be discarded.
If the memory access that triggered the fault is unaligned the following could occur: the
memory access could be divided into multiple transactions at the bus interface level, and,
if a fault has taken place, the address value placed into the fault address register could be
the generated bus transaction address instead of the original address (i.e., different from
the address value used in the program code).

What is Lockup?

When an error condition occurs, one of the fault handlers will be triggered. If another fault
happens inside a Configurable Fault handler, then either:
• Another Configurable Fault handler is triggered and executed (if the fault is different from
the one already triggered and if it has a higher priority than the current level fault), or
• The HardFault handler is triggered and executed.
However, what happens if another fault event occurs during the execution of the
HardFault handler? (it is a very unlikely situation, but can happen). In this case, a lockup
situation will take place.
Lockups can occur if:
– A fault occurs during the execution of the HardFault or the Non-Maskable Interrupt (NMI)
exception handler
– A bus error occurs during the vector fetch for the HardFault or NMI exceptions
– The SVC instruction is accidentally included in the HardFault or in the NMI exception
handler
– The Vector fetches during the startup sequence
During lockup, the processor stops executing the program and asserts an output signal
called LOCKUP. How this signal is used inside the chip depends on the system level design
of the chip. In some cases, it can be used to automatically generate a system reset.
If the lockup is caused by a fault event inside the HardFault handler (a double fault condition) at priority level 1, it is still possible for the processor to respond to an NMI (priority
level 2) and execute the NMI handler. But, after the NMI handler finishes, it will return to
the lockup state and the priority level will return to 1. If, however, the system is in the Secure
HardFault when the AIRCR.BFHFNMIS is set to 1 (i.e., the priority level of the Secure
HardFault is 3), or if the processor has entered LOCKUP state from within an NMI handler
(priority level 2), the processor will not be able to respond to the NMI event.
There are various ways to exit the lockup state:
– By way of a system reset or power on reset
– If the lockup happens during a debug session, the debugger can halt the processor and
clear the error state(s) (e.g., by using reset or by clearing the current exception handling
status, and by updating the program counter value to a new starting point, etc.).
Usually, a system reset or power-on reset are the best methods for exiting the lockup state
as they ensure that the peripherals, and all the interrupt handling logic, return to the reset
state.
