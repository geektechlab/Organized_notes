The System Control Block (SCB) is a group of hardware registers inside the Cortex-M processor which handles the processor’s control functions. They are accessible by the privileged
software and by the debugger.

If the TrustZone security extension is implemented, some of these registers are banked between security states:
• When in Secure state, privileged software access to the SCB data structure sees the Secure
view of the SCB registers.
• When in a Non-secure state, privileged software access to the SCB data structure sees the
Non-secure view of the SCB registers.
• When in Secure state, privileged software can see the Non-secure view of the SCB registers
using Non-secure alias (SCB_NS) address 0xE002EDxx (Fig. 10.13).

A debugger with permission to debug the Secure world software can access both the Secure and the Non-secure SCB data structures. However, the alias method used by Secure software, which allows the registers to be accessed with the SCB and the SCB_NS views, is not
suitable for the aforementioned debugger. Because the SCB data view at address 0xE000EDxx
is dependent on the processor’s security state, the SCB view is, as a result, frequently changed
(Note: When the processor is running, it can frequently switch between Secure and Nonsecure states). Instead of using the same alias method that is used by software, the debug tool
uses the SBRSEL (Secure Bank Register Select) and the SBRSELEN control bits in the DSCSR
(Debug Security Control and Status Register) to decide which SCB view to use. With this arrangement, even though the processor often switches between the Secure and Non-secure
states, the processor’s state does not affect the debugger’s access to the SCB. This ensures that
the debugger is always able to access the desired SCB register.

If the TrustZone security extension is not implemented, there is only a Non-secure view of
the SCB and, as a consequence, SCB_NS alias does not exist.

( imp: TABLE 10.8 SCB registers for Armv8.0-M. )

Inside the System Control Block (SCB) there is a register called CPU ID Base Register
(Table 10.9). It is a read-only register containing the processor’s ID value and revision number. The address of this register is 0xE000ED00 (it is privileged access only). In C language
programming this register can be accessed using the “SCB->CPUID” symbol.
Software and debug tools read this register to detect which Cortex-M processor is in the
device. For reference, the CPU ID values of previous Cortex-M processors are as per
Table 10.10.
If TrustZone is implemented and if the processor is in Secure privileged state, software
running on the processor can read the Non-secure alias of the CPU ID base register at
0xE002ED00 (using symbol SCB_NS->CPUID). By reading SCB_NS->CPUID, privileged
software can detect whether it is running in a Secure or a Non-secure state: if it is in the Secure
state, the read value is nonzero. If it is in the Non-secure state, the read value is zero because
Non-secure software does not see the SCB’s Non-secure alias addresses.

One of the key usages of the Application Interrupt/Reset Control Register (SCB->AIRCR,
see Section 9.3.4) is to allow software or the debugger to trigger a system reset. This is needed:
• When an error is detected in the system (e.g., a fault handler is triggered) and the software
decides to recover it using a self-reset.
• When during a debug session, the system reset is either requested by the software
developer via the debugger interface or by the debug tools generating a system reset when
establishing a debug connection.
The SYSRESETREQ bit (bit 2 of SCB->AIRCR) is used for generating a system reset request. For the request to be accepted, several conditions must be met:
• That bit 2 of the write data (SYSRESETREQ) is 1.
• That the upper 16 bits of the write data is a key-value (i.e., 0x05FA. If the upper 16 bits is not
this key value, the write is ignored).
• That one of the following permission conditions exist:
• That write is triggered from a debug connection, or
• That write is generated by Secure privileged software, or
• That write is generated by Non-secure privilege software and SYSRESETREQS (bit 4 of
SCB->AIRCR) is not set to 1 by the Secure software. If the Cortex-M23/M33 device does
not have TrustZone implemented, privileged software is always able to generate a
system reset request.
To access the AIRCR register (including accessing the SYSRESETREQ feature), the program
must be running in a privileged state.

The Data Memory Barrier (DMB) instruction is needed so that previous data memory accesses are completed before the reset happens. When writing to the AIRCR, the upper 16 bits
of the write value should be set to 0x05FA: this key-value was introduced in the architecture to
prevent a self-reset request from accidentally being generated.
The SCB->AIRCR register has other bit fields and, to prevent problems, it is recommended
that a read-modify-write sequence is used to request the reset.
Depending on the design of the reset circuitry in the microcontroller, after writing 1 to
SYSRESETREQ, the processor could continue to execute several instructions before the reset
takes place. To overcome this problem it is advisable, therefore, to add an endless loop after
the system reset request.

The self-reset logic in Armv8-M has several differences when compared to Armv7-M.
These are:
• The VECTRESET bit available in Armv7-M processors (e.g., Cortex-M3/Cortex-M4) has
been removed.
• The addition of the SYSRESETREQS bit, which allows Secure privileged software to stop
Non-secure software from generating a self-reset by setting SYSRESETREQS to 1.
In some instances, you might want to set PRIMASK so it disables interrupt processing before starting the self-reset operation. This is to ensure that if the system reset takes some time
to trigger, that an interrupt occurring during the delay does not result in the execution of an
interrupt handler. Otherwise, the system reset could happen in the middle of an interrupt
handler which might be undesirable for some applications.

During halt mode debugging, when the processor is halted within an exception handler
(e.g., a Fault exception), a software developer might want to force the processor to jump directly into a piece of code outside the handler. Although changing the PC (program counter)
and resuming the program’s execution is quite straight forward, a problem could arise if the
processor continues while still in exception Handler mode. If the code was written for Thread
mode, the code might not work when the processor is in Handler mode (e.g., executing an
SVC might not be possible when the processor is in Handler mode with a high interrupt priority level).
Fortunately, the VECTCLRACTIVE bit in the Application Interrupt/Reset Control Register
(SCB->AIRCR, Section 9.3.4) allows the interrupt state in the processor to be cleared for the
aforementioned debugging scenario. When using the VECTCLRACTIVE feature, the upper
16 bits of the write data must be set to 0x05FA when writing to the AIRCR (i.e., the same requirement when using the SYSRESETREQ bit in the AIRCR).
Since the VECTCLRACTIVE feature does not reset the rest of the system, generating a full
system reset via SYSRESETREQ is, generally speaking, a much better option. This feature is
for use with debug tools and should not be used by application software.
