You might wonder whether there is enough region ID space for complex designs. Well, since the SAU is limited to 8 regions (certainly in the current Armv8-M processors) and the IDAU to 256, and because the two pieces of hardware work together in an overlapping region arrangement, it is certainly true that there is a limit on the number of regions that can be created. Although presently most microcontrollers have less than 50 peripherals, it should, in theory in the future, be possible to create microcontroller devices which have hundreds of peripherals.

The limit of the region ID ranges is a big problem for advanced memory partitioning. For example, an embedded flash with several MBs could be divided into thousands of flash pages (a flash page ranges from 256 bytes to 1KB). If part of the flash memory is being used as a file system, it is quite possible that we would need to handle the flash memory partitioning on a page by page basis. In such an example, the IDAU region numbers could easily run out. Fortunately, there is another way to handle address partitioning without having to utilize a large number of region ID values. This method is based on a memory alias technique and uses a protection controller to divide the memory device––or a group of peripherals––into sections and provides a hardware control to define the accessibility of each section in the Secure and Non-secure alias.

By way of an example, consider a microcontroller with 256KB of embedded flash memory which is connected via a Memory Protection Controller (MPC, Fig. 7.10), with a page size of 512 bytes (256KB/512 bytes¼512 pages). The embedded flash is accessible via a Non-secure alias (0x00000000) and a Secure alias (0x10000000). The MPC is then used to decide which flash pages are visible in the Secure address range and which other pages are visible in the Non-secure address range. The MPC contains a lookup table that defines the security attribute of each flash memory page and uses this attribute for each access to decide whether a transfer is to be allowed or is to be blocked. In the following diagram (Fig. 7.11), the MPC partitions the embedded flash memory into four parts. Using thismethod,we only need one region ID value for the Non-secure address rangein the embedded flash, despite the address range containing multiple holes (i.e., flash pages that are  blocked). It also prevents a race-condition problem from occurringinmulticore systems where:
• One processor changes a memory page from Non-secure to Secure, while
• Another processor running a Secure API treats that memory page as Non-secure (A pointer check would have been carried out when the page was Non-secure).

( IMP: FIG. 7.11 The MPC defines whether each flash page is accessible from either the Secure or the Non-secure alias. )

MPC operations are often based on one of the following partitioning methods:
• Partitioning on a page-by-page basis, which needs one configuration bit per page. Or
• If there is only a need to partition the memory device into one Secure and one Non-secure range (i.e., only one boundary), an MPC can be designed to use a watermark level scheme that defines the page number of the boundary. Such a design would require fewer configuration bits in the hardware.

Using the same technique as that used for the MPC operations, a Peripheral Protection Controller (PPC, Fig. 7.12) can be designed to assign a large number of peripherals into the Secure and the Non-secure domains. This is achieved by not having to use a large number of SAU and IDAU region ID values. In addition to the access control feature based on the security attribute of the transfers, the PPC can also be designed to determine access permissions based on the privileged level. In this way, privileged software is able to control whether a peripheral is accessible by an unprivileged software component. In short,
• the SAU and the IDAU define the security attributes of the address regions, whereas
• the MPC and the PPC define the effective address for each memory page or for each peripheral. The operation of the MPC and the PPC is handled by masking the memory page or peripheral from one of the Secure or Non-secure alias addresses.

( FIG. 7.12 The PPC defines whether each of the peripherals is accessible from either the Secure or the Non-secure alias. )

Please note, when using this method, the base address of a peripheral when it is being used as Secure and when it is being used as Non-secure is different. Normally, a peripheral’s security state is set up at the bootup of the device and is, as a result, unlikely to be dynamically changed. Thus, it is unlikely to cause an issue with the peripheral control codes. However, in the situation where a peripheral’s security state can be changed dynamically, the peripheral control codes might need to detect the security state of the peripheral before accessing it. When software access to a peripheral is blocked by the PPC, there are two possible responses:
• Bus error (this will trigger a fault exception)
• Read as Zero/write ignored (RAZ/WI)

Both are valid arrangements for Armv8-M systems. Some might argue that the bus error response is more secure as it gives the Secure software a chance to intercept the fault exception and detect whether the Non-secure software that is running is trying to attack the security of the system. But, in many microcontroller device families, which have a range of chip products, with each having a different set of peripherals, it is common practice to allow the software to detect the availability of the peripherals (e.g., by reading the peripheral’s ID registers in those peripheral address ranges). In this way, the software is able to ascertain whether a certain peripheral is available.
