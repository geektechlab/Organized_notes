see ( FIG. 3.8 )

Whilst this security arrangement is suitable for a wide range of applications, there are some instances why this is not sufficient; that is why TrustZone security technology is needed.
• First of all, there are restrictions on the application threads. Since application threads run at unprivileged level, they do not have direct access to interrupt management and, therefore, privileged software must provide interrupt management services to these threads. The system services are typically handled via the SuperVisor Call (SVCall) exception—a process that increases software complexity and overhead in execution timing. 
• Unfortunately, in some cases, the peripheral interrupt handlers can have bugs and this could lead to vulnerabilities. Because interrupt handlers execute in a privileged state, if a hacker manages to successfully attack and compromise a peripheral interrupt handler, the hacker would then be able to disable the MPU; and would also be able to access other address spaces that are privileged access only and thus compromise the system.
• Recently, some microcontrollers have been delivered with on-chip software libraries that have included communication protocol software stacks and various software features that enable secure IoT connections. This makes it easier for software developers to create IoT solutions (Fig. 3.9), but does lead to new challenges:
• Firmware protection features are needed to allow microcontroller vendors to protect their preloaded firmware from being copied or reverse engineered, especially when that software is licensed from a third-party company.
• Secure storage features are needed to protect data used for establishing secure IoT connections. For example, secret keys or certificates could be stored on the chip. These protection features are needed to prevent device cloning and to prevent the reverse engineering of authentication details.
• Many software engineers do not have the technical knowledge to create secure connections for IoT devices. Using a prepackaged solution is much easier and can reduce the risk of incorrect implementations (which could lead to vulnerabilities).
• Because privileged access to these devices is essential to software developers and therefore has to be allowed, the MPU solution will not be of any use for protecting the firmware assets or the secret keys as previously mentioned. As a result, we need to find a new mechanism for security management, i.e., TrustZone technology. In Cortex-A processors, TrustZone technology has been available for a long period of time and some concepts of the TrustZone operations can be of benefit for IoT microcontroller applications. As a result, Arm has adopted some of the TrustZone concepts, which have been optimized for Cortex-M based systems. This has become TrustZone for Armv8-M and has been implemented on the Cortex-M23 and Cortex-M33 range of processors.

TrustZone for Armv8-M is integrated into all aspects of the processor’s architecture, including the programmer’s model, the interrupt handling mechanism, debug features, bus interfaces, and memory system designs. (Fig. 3.10 )

Similar to TrustZone available in the Cortex-A processors, software running in the Secure world can access both Secure and Non-secure memories and resources; but the Non-secure world can only access Non-secure memories and resources. In Cortex-M33 processors, the TrustZone security extension is optional. If it is not implemented (the decision is made by the chip designer), then only the Non-secure world exists.

The normal execution environment (Non-secure world) is mostly unchanged from previous Cortex-M processors, with many applications written for previous Cortex-M processors being able to run in the Non-secure world without the need for any modification. Where they cannot, minimal modifications are required (e.g., RTOS would need to be updated). The additional protected environment (Secure world) is also similar to the normal environment. In fact, for most bare metal applications, the same code can run in either world. The Secure world does, however, provide additional control registers for security management. Additionally, there are a number of hardware resources (e.g., SysTick timers, MPUs) available for each of the two worlds. The separation of Secure and Non-secure world provides a way for security-critical operations and resources to be protected. At the same time, however, because the architecture allows direct function calls to take place between  security domain boundaries (Fig. 3.11), with only a very small amount of software overhead. Security features can still be accessed efficiently by normal applications via a range of protected Application Programming Interfaces (APIs). To make the API call mechanism secure, a function call from a Non-secure to a Secure function is only allowed when the first instruction is an Secure Gateway (SG) instruction and is in a secure memory address marked with a Non-secure Callable (NSC) attribute. This prevents Non-secure code from branching into the middle of a secure API or other secure memory locations. Similarly, switching from a Non-secure to a Secure state when returning from a Non-secure function call is also protected, but by way of a different mechanism: it is called FNC_RETURN (function-return).

The Armv6-M/Armv7-M architecturally defined memory map in the 4GB address space remains unchanged in the Armv8-M architecture. But the security extension divides the memory map further into Secure and Non-secure spaces so that both worlds contain its own program memory, data memory, and peripherals. This partitioning is defined by a new block called the Security Attribution Unit (SAU) and, optionally, an Implementation Defined Attribution Unit (IDAU) (Fig. 3.12). The exact memory partitioning is up to the chip designer and the creators of Secure firmware (who define the memory partitioning configurations in the programming of the SAU).

The security state of the processor is determined by the security attribute of the program address:
• When executing Secure firmware in the Secure memory the processor is in a Secure state.
• When executing codes in the Non-secure memory the processor is in a Non-secure state.

Switching of the processor state is monitored by hardware to ensure that there are no illegal state transitions. To ensure the integrity of each world, the stack address spaces and vector tables of the Secure and the Non-secure worlds are separate. As a result, the stack pointers are banked between security states. To facilitate stronger security, a stack limit check feature is used to support Secure stack pointers in both the Cortex-M23 and Cortex-M33 processors, with the Cortex-M33 processor also supporting stack limit checks for Non-secure stack pointers. Because of the need to have both Secure and Non-secure peripherals, each of the interrupts can be assigned as Secure or Non-secure by the secure software. The security state transitions can be triggered by exception sequences, such as exception preemption and exception return (Fig. 3.13).

Since Secure and Non-secure software use the same physical registers (except stack pointers), Secure register contents are protected automatically by the processor’s exception handling sequences to prevent the leaking of Secure information. To enable Root-of-Trust security, the processor starts up in Secure state. After security management blocks are programmed (e.g., configuration of memory partitioning and interrupt assignments), the Secure software is then able to execute the start-up code in the Nonsecure world (Fig. 3.14). Applications running in the Non-secure world operate in almost the same way as they do  in traditional Cortex-M systems. They have full control of:
• its Non-secure (NS) memories,
• its NS peripherals,
• its NS interrupt management registers, and
• the NS Memory Protection Unit (MPU).
In addition, it is also possible to make use of other APIs provided in the secure firmware to access other features (e.g., cryptography functions). Secure firmware can, optionally, also make use of APIs (e.g., I/O driver libraries) that can be placed in the Non-secure memory.
