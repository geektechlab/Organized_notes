Stack overflow is a common software error and is where an application, or an application
task within a multitasking system, consumes more stack space than it is allocated. Such an
occurrence might end up corrupting other data and, in turn, might cause an application to
fail (e.g., getting incorrect results or making it crash). It could also negatively impact on
the security of IoT applications.
Prior to Armv8-M architecture, software was able to use the MPU to define the memory
space allocation for stacks to detect stack overflow. Some RTOS products support stack overflow detection in application threads using software steps during context switching. In
Armv8-M architecture, a dedicated stack limit checking feature has been added. By having
stack limit registers (Fig. 11.7), privileged software is able to define the maximum stack sizes
allocated to both the main and the process stacks.
The lowest 3 bits of the Stack Limit Registers are tied to 0, which means that stack limits are
always double word aligned.
If the value of a stack pointer goes below the stack limit, and if a stack-related operation
occurs when using the stack pointer, the stack operation violation would be detected and will
trigger a fault exception as follows:
For Armv8-M Mainline, the UsageFault exception is triggered and the STKOF fault status
bit in the UsageFault Status Register is set to 1 to reflect this fault condition. The UsageFault
exception can be either Secure or Non-secure, depending on whether the stack overflow
violation is related to the Secure or to the Non-secure stack. If the UsageFault was not
enabled, or if the priority level of the UsageFault was insufficient for it to be triggered, the
fault event would be escalated to HardFault.

A stack overflow fault exception is synchronous, whichmeans, as soon as the faultis detected,
the processor is unable to execute any further instructions in the current context. The only instance where the processor would continue to execute is when a higher priority interrupt
(e.g., an NMI) arrives at the same time; in which cause the fault exception will stay in a pending
state and will only execute when the ISR of the higher priority interrupt has been completed.
Stack-related operations that can trigger a stack overflow fault include:
• Stack push/pop
• Memory access instructions that update the stack pointers (e.g., load/store instructions
that update a stack pointer because of a base register update)
• Add/sub/move instructions that update the stack pointer
• Exception sequences (e.g., exception entry, tail-chaining from a Secure to a Non-secure
ISR)
• Secure code calling a Non-secure function (e.g., some secure states being pushed into the
current selected Secure stack)
Please note:
• Changing the stack limit registers using the MSR instruction, or
• Changing the Secure stack pointer using the MSR instruction
will not immediately trigger a fault exception for violating the stack overflow. By not triggering a fault exception until a stack-related operation is taking place, it is easier to design the OS
context switching software. For example:
• The RTOS running in the Non-secure world only needs to update the PSPLIM_NS and then
the PSP_NS in a context switch, even though the new PSPLIM_NS value could be higher
than the previous PSP_NS, that is, there is no need to set PSPLIM_NS to zero to disable the
stack limit check during the PSP update.
• Secure privileged software can update the MSP_S/PSP_S and its MSPLIM_S/PSPLIM_S
registers in any order.

To access the stack limit registers, MSR and MRS instructions are used. The register symbols for the access are shown in Table 11.8.

The benefit of applying a stack limit checking feature on the Process Stack Pointers (PSPs)
(e.g., using the PSPLIM_NS for stack overflow protection in the RTOS and the PSPLIM_S forstack protection for Secure libraries) is easily understood. This security measure is easily
implemented and is deployed in multiple RTOS products and in other security software
(e.g., Trusted Firmware-M). The stack limit check feature is also used for protecting the Main
Stack Pointer(s) (MSP) from stack overflow. This is needed because a stack overflow can occur
because of either a software error or because the number of nested exception levels is higher
than expected.
When using the stack limit checking on the Main Stack Pointer(s), there is a need to ensure
that the fault handler can execute (Note: the fault handlers also uses the MSP). There are several ways to handle this:

1. By adding assembly wrappers to the HardFault and UsageFault handlers to update the
MSPLIM before starting the C/C++ portion of the fault handler
When setting the stack limit, you need to make sure that extra RAM space is available after
the stack limit and then reserve that for the UsageFault/HardFault handlers. The
UsageFault/HardFault handlers require an assembly wrapper to update the MSPLIM in order that the C/C++ portion of the fault handler can execute (Fig. 11.8).
This method can be used in all Armv8-M processors.
2. By using the Secure HardFault handler to handle the stack overflow in the MSP_NS
(Non-secure MSP)
For Cortex-M systems with TrustZone, by default the HardFault targets the Secure side––
which uses the MSP_S during the execution of the fault handler (Fig. 11.9). So, even when the
Non-secure main stack has been corrupted, or the MSP_NS points to an invalid memory, the
fault handler can still execute.

( imp: FIG. 11.9 MSP_NS overflow handling with a handler using the MSP_S. )

( imp: FIG. 11.10 MSP overflow handling. )

3. By reserving stack space for the fault handler and the NMI and by setting the
STKOFHFNMIGN bit in SCB->CCR
When STKOFHFNMIGN (bit 10 of SCB->CCR, see Section 10.5.5) is set to 1, the stack limit
check is ignored when executing either the HardFault or the NMI handler(s). By so doing, it
allows software developers to reserve additional stack space for the HardFault handler that
deals with the stack overflow (Fig. 11.10).
The STKOFHFNMIGN bit is reset to 0 and banks between security states. It is only available in Armv8-M Mainline only.
