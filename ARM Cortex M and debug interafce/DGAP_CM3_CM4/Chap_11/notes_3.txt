Most simple applications do not require an MPU. By default the MPU is disabled and the system works as if it is not present. Before using the MPU, you need to  work out what memory regions the program or application tasks need to (and are allowed to) access:
• Program code for privileged applications including handlers and OS kernel, typically privileged accesses only
• Data memory including stack for privileged applications including handlers and OS kernels, typically privileged accesses only
• Program code for unprivileged applications (application tasks), full access 
• Data memory including stack for unprivileged applications (application tasks), full accesses
• Peripherals that are for privileged applications including handlers and OS kernel, privileged accesses only
• Peripherals that can be used by unprivileged applications (application tasks), full accesses

When defining the address and size of the memory region, be aware that the base address of a region must be aligned to an integer multiple value of the region size. For example, if the region size is 4KB (0x1000), the starting address must be “N x  0x1000” where N is an integer (Figure 11.3). If the goal for using the MPU is to prevent unprivileged tasks from accessing certain memory regions, the  background region feature is very useful as it reduces the setup required. You only need to set up the region setting for unprivileged  tasks, and privileged tasks and handlers have full access to other memory spaces using the background region.

There is no need to set up memory regions for Private Peripheral Bus (PPB) address ranges (including System Control Space, SCS) and the vector table. Accesses to PPB (including MPU, NVIC, SysTick, ITM) are always allowed in privileged state, and vector fetches are always permitted by the MPU.  You also need to define the fault handler for either the HardFault or MemManage (Memory Management) fault. By default the MemManage exception is disabled, and you can enable this by setting the MEMFAULTENA bit in the System Handler Control and State Register (SCB->SHCSR):
	SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk; // Set bit 16
The HardFault handler (void HardFault_Handler(void)) should always be defined even if you have enabled the MemManage exception. The MemManage handler (void MemManage_Handler(void)) should also be defined if the MemManage exception is enabled. By default, the vector table in the startup code should  contain the exception vector definition for these handlers. If you are using the vector table relocation feature, you might need to ensure that the vector table is set up accordingly. More information about using fault handlers is covered in Chapter 12.

( look into code 366 - 372 )

( FIGURE 11.4 - Example step to set up the MPU )

Memory barrier and MPU configuration
In the examples shown, we have added a number of memory barrier instructions in the MPU configuration code:
• DMB (Data Memory Barrier). This is used before disabling the MPU to ensure that there is no reordering of data transfers and if there is any outstanding transfer, we wait until the transfer is completed before writing to the MPU Control Register (MPU->CTRL) to disable the MPU.
• DSB (Data Synchronization Barrier). This is used after enabling the MPU to ensure that the subsequent ISB instruction is executed only after the write to the MPU Control Register is completed. This also ensures all subsequence data transfers use the new MPU settings.
• ISB (Instruction Synchronization Barrier). This is used after the DSB to ensure the processor pipeline is flushed and subsequent instructions are re-fetched with updated MPU settings.

The use of these memory barriers is based on architecture recommendations. Omitting these memory barriers on the Cortex-M3 and Cortex-M4 processors does not cause any failure due to the simple nature of the processor pipeline: the processor can only handle one data transfer at any time. The only case where an ISB is really needed is when the MPU settings are updated and the subsequent instructions access can only be carried out using the new MPU settings. However, from a software portability point of view, these memory barriers are important because their use allows the software to be reused on all Cortex-M processors. If the MPU is used by an embedded OS, and the MPU configuration is done inside the context-switching operation, which is typically within the PendSV exception handler, the ISB instruction is not required from an architecture point of view because the exception entrance and exit sequence also have the ISB effect.
