Due to the exception priority structure in the Cortex-M processors, you can only have one instance of SVC exception happen at a time: You cannot execute  an SVC instruction inside an SVC handler, or when the current priority is the same or higher than the SVC exception. Otherwise a fault exception will be triggered. You can therefore implement semaphore control accesses using SVC services. In  this way you can guarantee that only one application task in a system is accessing the semaphore.

( there are other interesting topics also, but those are very deep. If you like to understand those, go read those ).

For the majority of microcontroller products which use flash for program memory, the flash patch feature is not needed because the program memory can be updated easily. For some low-cost devices, the program memory could be implemented as a mask ROM programmed by the chip manufacturer, or One-Time Programmable (OTP) ROM, which can only be programmed once.

Since the ROM contents cannot be changed by the user, if a software bug is found after the devices are programmed, fixing the code can be costly. In some cases, a microcontroller with mask ROM or OTP ROM will also include a small user-programmable ROM such as flash, EEPROM, etc. Since the size of this ROM is small, the impact to the device cost is relatively small when compared to replacing a whole batch of unusable devices programmed with firmware that has a serious defect.

If you believe that your project might require a flash patch, you should include a conditional branch in the startup code so that it can check to see if patch data is available (Figure 23.8). To do this, you need to know what the values are in the flash  emory if nothing is programmed in it (typically it would be 0xFFFFFFFF).

( check given example )

The FPB has only a small number of comparators and therefore can only patch a limited number of program locations. So if a function has a bug, the most likely arrangement is to patch the branch instructions that called the function rather than trying to patch the function (Figure 23.9). Or if the required change is small enough that only a couple of bytes in the program code need to be patched, you can also apply the patch directly. When the processor reads an address in the program ROM and the address matches one of the FPB comparator setups and if the comparator is set to the REMAP function, then the access is remapped to an address location in SRAM, as specified by the REMAP register in the FPB (Figure 23.10).

After you have developed the replacement for the incorrect function, the next step is to create the setup code for FPB. You need to carry out the following tasks:
1. Set up the replacement values (patches) into a remap table in SRAM. The remap table contains a maximum of eight words and must be placed in a 32-byte aligned location in the SRAM region. The first six words are used for patching instructions, and the last two are used for patching literal data.
2. Set up the comparators in FPB. In maximum configurations of Cortex-M3 and Cortex-M4 processors there are eight comparators. The values programmed are the address values of the instructions to be patched. The first six are for patching instructions and the last two are used for patching literal data.
3. Set up the FPB REMAP register to point to the remap table in SRAM.
4. Enable the FPB.

( check given example )

If the instruction being patched is 32 bits in size and is unaligned and if both halfwords need to be changed, then we need to use two comparators in the FPB and two entries in the remap table to patch this instruction. Please note that the flash patch feature uses the same hardware for breakpoint functionality. So if the microcontroller is connected to a debugger, the debugger can overwrite the patch configuration and therefore a device with the flash patch setup cannot be debugged. The flash patch is a processor implementation-specific feature and is not available on the Cortex-M0 and Cortex-M0+ processors.
