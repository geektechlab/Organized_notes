All Cortex-M processors provide a Nested Vectored Interrupt Controller (NVIC) for interrupt handling. In addition to interrupt requests, there are other events that need servicing and we called them “exceptions.” In ARM terminology, an interrupt is one type of exception. Other exceptions in Cortex-M processors included fault exceptions and other system exceptions to support the OS (e.g., SVC instruction). The pieces of program code that handle exceptions are often called exception handlers. They are part of the compiled program image.In a typical Cortex-M microcontroller, the NVIC receives interrupt requests from various sources, as shown in Figure 7.1.

The Cortex-M3 and Cortex-M4 NVIC supports up to 240 IRQs (Interrupt Requests), a Non-Maskable Interrupt (NMI), a SysTick (System Tick) timer interrupt, and a number of system exceptions. Most of the IRQs are generated by peripherals such as timers, I/O ports, and communication interfaces (e.g., UART, I2C). The NMI is usually generated from peripherals like a watchdog timer or Brown-Out Detector (BOD). The rest of the exceptions are from the processor core. Interrupts can also be generated using software.

In order to resume the interrupted program, the exception sequence needs some way to store the status of the interrupted program so that this can be restored after the exception handler is completed. In general this can either be done by a hardware mechanism or a mixture of hardware and software operations. In the Cortex-M processors, some of the registers are saved onto the stack automatically when an exception is accepted, and are also automatically restored in an exception return sequence. This mechanism allows the exception handlers to be written as normal C functions without any additional software overhead.

Exceptions are numbered 1e15 for system exceptions and 16 and above for interrupt inputs (inputs to the processor, but not necessarily accessible on the I/O pins of the package). Mostof the exceptions, including all interrupts, have programmable priorities, and a few  system exceptions have fixed priority. Different Cortex-M3 or Cortex-M4 microcontrollers can have different numbers of interrupt sources(from 1e240) and different numbers of priority levels.

The exception number is used as the identification for each exception and is used in various places in the ARMv7-M architecture. For example, the value of the currently running exception is indicated by the special register Interrupt Program Status Register (IPSR), or by one of the registers in the NVIC called the Interrupt Control State Register (the VECTACTIVE field).

( IMP
table 7.1
IMP )

The system exceptions use negative values in the enumeration, as shown in Table 7.3.

The Cortex-M processors have a number of programmable registers for managing interrupts and exceptions. Most of these registers are inside the NVIC and System Control Block (SCB). (Physically the SCB is implemented as part of the NVIC but the CMSIS-Core defines the registers in separated data structures.) There are also special registers inside the processor core for interrupt masking (e.g., PRIMASK, FAULTMASK,and BASEPRI).

The NVIC and SCB are located inside the System Control Space (SCS) address range from 0xE000E000, with a size of 4KB. The SCS also contains registers for the SysTick timer, Memory Protection Unit (MPU), debug registers, etc. Almost all of the registers in this address range can only be accessed by code running in privileged access level. The only exception is a register called the Software Trigger Interrupt Register (STIR), which can be set up to be accessible in unprivileged mode.

After reset, all interrupts are disabled and given a priority-level value of 0. Before using any interrupts, you need to:
• Set up the priority level of the required interrupt (this step is optional)
• Enable the interrupt generation control in the peripheral that triggers the interrupt
• Enable the interrupt in the NVIC
In most typical applications, this is all you need to do. When the interrupt triggers, the corresponding Interrupt Service Routine (ISR) will execute (you might need to clear the interrupt request from the peripheral within the handler). The name of the ISR can be found inside the vector table inside the startup code, which is also provided by the microcontroller vendor. The name of the ISR needs to match the name used in the vector table so that the linker can place the starting address of the ISR into the vector table correctly.

In the Cortex-M processors (both ARMv6-M and ARMv7-M), whether and when an exception can be accepted by the processor and get its handler executed can be dependent on the priority of the exception and the current priority of the processor. A higher-priority (smaller number in priority level) exception can pre-empt a lower-priority (larger number in priority level) exception; this is the nested exception/interrupt scenario. Some of the exceptions (reset, NMI, and HardFault) have fixed priority levels. Their priority levels are represented with negative numbers to indicate that they are of higher priority than other exceptions. Other exceptions have programmable priority levels, which range from 0 to 255. The design of the Cortex-M3 and Cortex-M4 processors support three fixed highest-prioritylevels and up to 256 levels of programmable priority (with a maximum of 128 levels of pre-emption).

The actual number of available programmable priority levels is decided by silicon chip designers. Most Cortex-M3 or Cortex-M4 chips have fewer supported levels e for example, 8, 16, 32, and so on. This is because having large number of priority levels can increases the complexity of the NVIC and can increase power consumption and reduce the speed of the design. In most cases, applications only require a small number of programmable priority levels. Therefore silicon chip designers need to customize their processor design based on thenumber of priority levels in the targeted applications.

Interrupt-priority levels are controlled by priority-level registers, with width of 3 bits to 8 bits. For example, if only 3 bits of priority level are implemented in the design, a priority-level configuration register will look like Figure 7.2.

The reason for removing the least significant bit (LSB) of the priority-level registers instead of the most significant bit (MSB) is to make it easier to port software from one Cortex-M device to another. In this way, a program written for devices with 4-bit priority configuration registers is likely to be able to run on devices with 3-bit priority configuration registers. If the MSB is removed instead of the LSB, you might get an inversion of the priority arrangement when porting an application from one Cortex-M chip to another. For example, if an application uses priority level 0x05 for IRQ #0 and level 0x03 for IRQ #1, IRQ #1 should have higher priority. But when MSB bit 2 is removed, IRQ #0 will become level 0x01 and have a higher priority than IRQ #1. ( figure 7.4 )

Using a configuration register in the System Control Block (SCB) called Priority Group (a part of the Application Interrupt and Reset Control register in the SCB, section 7.9.4), the priority-level configuration registers for each exception with programmable priority levels is divided into two halves. The upper half (left bits) is the group (pre-empt) priority, and the lower half (right bits) is the sub-priority (Table 7.6).

The group priority level defines whether an interrupt can take place when the processor is already running another interrupt handler. The sub-priority level value is used only when two exceptions with same group-priority level occur at the same time. In this case, the exception with higher sub-priority (lower value) will be handled first.

As a result of the priority grouping, the maximum width of group (pre-empt) priority is 7, so there can be 128 levels. When the priority group is set to 7, all exceptions with a programmable priority level will be in the same level, and no preemption between these exceptions will take place, except that hard fault, NMI, and reset, which have priority of -1, -2, and -3, respectively, can pre-empt these exceptions. When deciding the effective group-priority level and sub-priority level, you must take these factors into account:
• Implemented priority-level configuration registers
• Priority group setting
For example, if the width of the configuration registers is 3 (bit 7 to bit 5 are available) and priority group is set to 5, you can have four levels of group/ pre-empt priority levels (bit 7 to bit 6), and inside each group/pre-empt level there are two levels of sub-priority (bit 5) (Figure 7.5). With settings as shown in Figure 7.5, the available priority levels are illustrated in Figure 7.6.

For the same design, if the priority group ( table 7.6 ) is set to 0x1, there can be only eight group priority levels and no further sub-priority levels inside each pre-empt level. (Bit [1:0] of priority level register is always 0.) The definition of the priority level configuration registers is shown in Figure 7.7, and the available priority levels are illustrated in Figure 7.8.

When two interrupts are asserted at the same time with exactly the same group/ pre-empt priority level and sub-priority level, the interrupt with the smaller exception number has higher priority. (IRQ #0 has higher priority than IRQ #1.) To avoid unexpected changes of priority levels for interrupts, be careful when writing to the Application Interrupt and Reset Control Register (address 0xE000ED0C). In most cases, after the priority group is configured, there is no need to use this register except to generate a reset.

When the Cortex-M processor accepts an exception request, the processor needs to determine the starting address of the exception handler (or ISR if the exception is an interrupt). This information is stored in the vector table in the memory. By default, the vector table starts at memory address 0, and the vector address is arranged according to the exception number times four (Figure 7.10).

The vector table used in startup also contains the initial value of the main stack pointer (MSP). It is needed because some exception such as NMI could happen as the processor just came out from reset and before any other initialization steps are executed.
