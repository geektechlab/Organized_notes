As the processor enters the exception handler or Interrupt Service Routine (ISR), the value of the Link Register (LR) is updated to a code called EXC_RETURN. The  alue of this code is used to trigger the exception return mechanism when it is loaded into the Program Counter (PC) using BX, POP, or memory load instructions (LDR or LDM).

Some bits of the EXC_RETURN code are used to provide additional information about the exception sequence. The definition of the EXC_RETURN value is shown in Table 8.1. The Valid values of the EXC_RETURN are shown in Table 8.2.

As a result of the EXC_RETURN number format, you cannot perform an interrupt return to an address in the 0xF0000000 to 0xFFFFFFFF memory range. However, since this address range is in the system region that is defined as non-executable in the architecture, it is not a problem.

Exception entrance and stacking When an exception occurs and is accepted by the processor, the stacking sequence starts to push the registers into the stack, forming the stack frame, as shown in Figure 8.5.

The Cortex-M3 and Cortex-M4 processors have multiple bus interfaces (as shown in Figure 6.2). In parallel to the stacking operation (usually on the System bus), the processor can also start the vector fetch (typically through the I-CODE bus), and then start the instruction fetch. As a result, the Harvard bus architecture allows the interrupt latency to be reduced because the stacking operation and flash memory accesses (vector fetch, instruction fetches) can take place in parallel. If the vector table is relocated to SRAM or if the exception handlers are also stored in SRAM, then this can increase the interrupt latency slightly.

Please note that the exact order of stack accesses during stacking is NOT the same order as the registers in the stack frame. For example, the Cortex-M3 processor stacks the PC and xPSR first, as shown in Figure 8.6, before other registers in the register banks so that the PC can be updated sooner with the vector fetch. Due to the pipeline nature of the AHB Lite interface, the data transfer lags behind the address by at least one clock cycle.

The stack being used in the stacking operations can either be the Main stack (using Main Stack Pointer, MSP) or the Process stack (using Process Stack Pointer, PSP). If the processor was in Thread mode, and was using MSP (bit 1 of the CONTROL register is 0, as in the default setting), the stacking operation is carried out in the main stack with MSP (as shown in Figure 8.7). If the processor was in Thread mode, and was using the process stack (bit 1 of the CONTROL register is 1), then the stacking operation is carried out in the process stack with PSP. After entering Handler mode, the processor must be using the MSP, so the stacking operation of all nested interrupts are carried out with the main stack with MSP (as shown in Figure 8.8).

At the end of an exception handler, the bit 2 of the EXC_RETURN value generated at the exception entrance is used to decide which stack pointer should be used to extract the stack frame. If bit 2 is 0, the processor knows that the main stack was used for stacking, as shown in Figure 8.9. If bit 2 is 1, the processor knows that the process stack was used for stacking, as shown in the second unstacking operation in Figure 8.10. At the end of each unstacking operation, the processor also checks the bit 9 of the unstacked xPSR value, and adjusts the stack pointer accordingly to remove the padding space if it was inserted during stacking, as shown in Figure 8.11. To reduce the time required for the unstacking operation, the return address (stacked PC) value is accessed first, so that instruction fetch can start in parallel with the rest of the unstacking operation.
