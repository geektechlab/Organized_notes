All the ARM Cortex-M processors are based on Thumb-2 technology, which allows a mixture of 16-bit and 32-bit instructions to be used within one operating state.

Early ARM processors (prior to the ARM7TDMI processor) supported a 32-bit instruction set called the ARM instruction set. it often requires more program memory when compared to 8-bit and 16-bit architecture.

Then ARM introduced a new operation state that runs a new 16-bit instruction set. This 16-bit instruction set is called “Thumb”. The ARM7TDMI can operate in the ARM state, the default state, and also in the Thumb state. During operation, the processor switches between ARM state and Thumb state under software control. Parts of the application program are compiled with ARM instructions for higher performance, and the remaining parts are compiled as Thumb instructions for better code density. By providing this twostate mechanism, the applications can be squeezed into a smaller program size, while maintaining high performance when needed. In some cases, the Thumb code provides a code size reduction of 30% compared to the equivalent ARM code. 

Although the Thumb instruction set can provide most of the same commonly used functionality as the ARM instructions, it does have some limitations, such as restrictions on the register choices for operations, available addressing modes, or a reduced range of immediate values for data or addresses.

Then, ARM announced Thumb-2 technology, a method to combine 16-bit and 32-bit instruction sets in one operation state. In Thumb-2, a new superset of the Thumb instructions were introduced, with many as 32-bit size, hence they can handle most of the operations previously only possible in the ARM instruction set. However, they have different instruction encoding to the ARM instruction set. Unlike earlier ARM processors, it does not support the ARM instruction set. 

Most of the instructions in ARMv6-M are 16-bit, and some are available in both 16-bit and 32-bit format. When an operation can be carried out in 16-bit, the compiler will normally choose the 16-bit version to give a smaller code size. The 32-bit version might support a greater choice of registers (e.g., high registers), larger immediate data, longer address range, or a larger choice of addressing modes. However, for the same operation, the 16-bit version and the 32-bit version of an instruction will take the same amount of time to execute.

Assembly tools from different vendors (e.g., the GNU toolchain) have different syntaxes. In most cases, the mnemonics of the assembly instructions are the same, but assembly directives, definitions, labeling, and comment syntax can be different.

With ARM assembly the following instruction formatting is used:
	label
	mnemonic operand1, operand2, . ; Comment

The “label” is used as a reference to an address location. It is optional; some instructions might have a label in front of them so that the address of the instruction can be obtained by using the label. Labels can also be used to reference data addresses. For example, you can put a label for a lookup table inside the program. After the “label” you can find the “mnemonic,” which is the name of the instruction, followed by a number of operands:
• For data processing instructions written for the ARM assembler, the first operand is the destination of the operation.
• For a memory read instruction (except multiple load instructions), the first operand is the register which data is loaded into.
• For a memory write instruction (except multiple store instructions), the first operand is the register that holds the data to be written to memory. Instructions that handle multiple loads and stores have a different syntax. The number of operands for each instruction depends on the instruction type. Some instructions do not need any operand and some might need just one.

Some mnemonics can be used with different types of operands, and this can result in different instruction encodings. In assembler for ARM processors, some instructions can be followed by suffixes. A data processing instruction can optionally update the APSR (flags). If using the Unified Assembly Language (UAL) syntax, we can specify if the APSR update should be carried out or not. For example, when moving a data from one register to another, it is possible to use
	MOVS R0, R1 ; Move R1 into R0 and update APSR
Or
	MOV R0, R1 ; Move R1 into R0, and not update APSR

The second type of suffix is for conditional execution of instructions. Processor supports conditional branches, as well as conditional execution of instructions by putting the conditional instructions in an IF-THEN (IT) instruction block. By updating the APSR using data operations, or instructions like test (TST) or compare (CMP), the program flow can be controlled based on conditions of operation results.

With the new instructions in Thumb-2 technology, some of the operations can be handled by either a Thumb instruction or a Thumb-2 instruction. With UAL, you can specify which instruction you want by adding suffixes:
	ADDS R0, #1 ; Use 16-bit Thumb instruction by default for smaller size
	ADDS.N R0, #1 ; Use 16-bit Thumb instruction (N=Narrow)
	ADDS.W R0, #1 ; Use 32-bit Thumb-2 instruction (W=wide)
The .W (wide) suffix specifies a 32-bit instruction. If no suffix is given, the assembler tool can choose either instruction but usually defaults to the smaller option to get the best code density. Depending on tool support, you may also use the .N (narrow) suffix to specify a 16-bit Thumb instruction. When the compilation is optimized for speed, the C compiler might also use 32-bit instructions to adjust the branch target addresses to 32-bit aligned for better performance.

32-bit Thumb-2 instructions can be half-word aligned. For example, you can have a 32-bit instruction located in a half-word location (unaligned) (Figure 5.4):
	0x1000 : LDR r0,[r1] ;a 16-bit instructions (occupy 0x1000-0x1001)
	0x1002 : RBIT.W r0 ;a 32-bit Thumb-2 instruction (occupy 0x1002-0x1005)
Most 16-bit instructions can only access registers R0 to R7; 32-bit Thumb-2 instructions do not have this limitation. However, use of PC (R15) might not be allowed in some of the instructions.

The instructions in the Cortex-M3 and Cortex-M4 processors can be divided into various groups based on functionality:
• Moving data within the processor
• Memory accesses
• Arithmetic operations
• Logic operations
• Shift and Rotate operations
• Conversion (extend and reverse ordering) operations
• Bit field processing instructions
• Program flow control (branch, conditional branch, conditional execution, and
function calls)
• Multiply accumulate (MAC) instructions
• Divide instructions
• Memory barrier instructions
• Exception-related instructions
• Sleep mode-related instructions
• Other functions

In addition, the Cortex-M4 processor supports the Enhanced DSP instructions:
• SIMD operations and packing instructions
• Adding fast multiply and MAC instructions
• Saturation algorithms
• Floating point instructions (if the floating point unit is present)

The most basic operation in a microprocessor is to move data around inside the processor. For example, you might want to:
• Move data from one register to another
• Move data between a register and a special register (e.g., CONTROL, PRIMASK, FAULTMASK, BASEPRI)
• Move an immediate constant into a register For the Cortex-M4 processor with the floating point unit, you can also:
• Move data between a register in the core register bank and a register in thefloating point unit register bank
• Move data between registers in the floating point register bank
• Move data between a floating point system register (such as the FPSCR eFloating point Status and Control Register) and a core register
• Move immediate data into a floating point register ( Table 5.4 shows some examples of these operations. )

Usually the assembler groups various literal data (e.g., DCD 0x12345678 in the above example) together into data blocks called literal pools. Since the value of the offset in the LDR instruction is limited, a program will often need a number of literal pools so that the LDR instruction can access the literal data. Therefore we need to insert assembler directives like LTORG (or .pool) to tell the assembler where it can insert literal pools. Otherwise the assembler will try to put all the literal data after the end of the program code, which might be too far away for the LDR instruction to access it.

Memory access instructions

Immediate offset (pre-index)
	The memory address of the data transfer is the sum of a register value and an immediate constant value (offset).
	For example:
		LDRB R0, [R1, #0x3] ; Read a byte value from address R1+0x3, and store the read data in R0.
	This addressing mode supports write back of the register holding the address. For example:
		LDR R0, [R1, #0x8]! ; After the access to memory[R1+0x8], R1 is updated to R1+0x8

PC-related addressing (Literal)
	A memory access can generate the address value from the current PC value and an offset value (Table 5.11). This is commonly needed for loading immediate values into  a register, also known as literal pool accesses.

Register offset (pre-index)
	Another useful address mode is the register offset. This is often used in the processing of data arrays where the address is a combination of a base address and an offset calculated from an index value. For example:
		LDR R3, [R0, R2, LSL #2] ; Read memory[R0+(R2 << 2)] into R3 The shift operation is optional. You can have a simple operation like
		STR R5, [R0,R7] ; Write R5 into memory[R0+R7]

Post-index
	Memory access instructions with post-index addressing mode also have an immediate offset value. However, the offset is not used during the memory access, but is used to update the address register after the data transfer is completed. For example:
		LDR R0, [R1], #offset ; Read memory[R1], then R1 updated to R1+offset
	The post-index address mode can be very useful for processing data in an array.

Multiple load and multiple store
	One of the key advantages of the ARM architecture is that it allows you to read or write multiple data that are contiguous in memory. The LDM (Load Multiple registers) and STM (Store Multiple registers) instructions only support 32-bit data.

Stack push and pop
	Stack push and pop are another form of the store multiple and load multiple. They use the currently selected stack pointer for address generation. The currently selected stack pointer can either be the Main Stack Pointer (MSP), or the Process Stack Pointer (PSP), depending on the current mode of the processor and the value in the CONTROL special register (see Chapter 4). Instructions for stack push and stack pop are shown in Table 5.18. The register list syntax is the same as LDM and STM. For example:
		PUSH {R0, R4-R7, R9} ; PUSH R0, R4, R5, R6, R7, R9 into stack
		POP {R2, R3} ; POP R2 and R3 from stack
		PUSH {R4-R6, LR} ; Save R4 to R6 and LR (Link Register) at the beginning of a subroutine. LR contains the return address processing in the subroutine

SP-relative addressing
	Besides being used for the temporary storage of registers in functions or subroutines, the stack memory is very often also used for local variables, and accessingthese variables requires SP-relative addressing.

Load and store with unprivileged access level
	There is a set of load and store instructions to allow program code executing in privileged access level to access memory with unprivileged access rights, as shown in Table 5.20. These instructions might be needed in some OS environments where an unprivileged application can access an API function (running within the privileged access level) with a data pointer as an input parameter, and this API operates on memory data specified by the pointer. If the data access is carried out using normal load and store instructions, the unprivileged application task will then have the ability to modify data that is used by other tasks or OS kernel using this API. 

Exclusive accesses
	The exclusive access instructions are a special group of memory access instructions for implementing semaphores or MUTEX (Mutual Exclusive) operations. Exclusive access instructions include exclusive loads and exclusive stores.

Arithmetic operations
		ADD R0, R0, R1 ; R0 = R0 + R1
		ADDS R0, R0, #0x12 ; R0 = R0 + 0x12 with APSR (flags) update
		ADC R0, R1, R2 ; R0 = R1 + R2 + carry

Logic operations
	The Cortex-M3 and Cortex-M4 processors support various instructions for logic operations such as AND, OR, exclusive OR and so on. Like the arithmetic instructions, the 16-bit versions of these instructions update the flags in APSR.

Shift and rotate instructions
	( vbery important ) as shown in Table 5.25, and illustrated in ( imp Figure 5.6 ). If the S suffix is used, these rotate and shift instructions also update the Carry flag in the APSR. If the shift or rotate operation shifts the register position by multiple bits, the value of the carry flag C will be the last bit that shifts out of the register. You might wonder why there are rotate right instructions but no instructions for rotate left. Actually, a rotate left operation can be replaced by a rotate right operation with a different rotate amount. For example, a rotate left by 4 bits can be written as a rotate right by 28 bits. This gives you the same result in the destination register (note that the C flag will be different from rotate left).

Data conversion operations (extend and reverse ordering)
	a number of instructions are available for handling signed and unsigned extensions of data; for example, to convert an 8-bit value to 32-bit, or from 16-bit to 32-bit. The signed and unsigned instructions are available in both 16-bit and 32-bit forms (Table 5.26).

	For example, if R0 is 0x55AA8765:
		SXTB R1, R0 ; R1 = 0x00000065
		SXTH R1, R0 ; R1 = 0xFFFF8765
		UXTB R1, R0 ; R1 = 0x00000065
		UXTH R1, R0 ; R1 = 0x00008765
	These instructions are useful for converting between different data types.

	Another group of data conversion operations is used for reversing data bytes in a register, listed in Table 5.28 and illustrated in Figure 5.7. These instructions are usually used for converting data between little endian and big endian.

	Bit-field processing instructions
	listed in Table 5.29

Compare and test
	The compare and test instructions are used to update the flags in the APSR, which may then be used by a conditional branch or conditional execution.
