IMP: Big endian and little endian is only for byte ordering in a number. It doesn't have to do anything with bit ordering within a byte.

The Inline assembly code is used to write pure assembly code inside a 'C' program. Basically, we use a inline assembly code in order to access the processor core register such as General purpose registers or special registers, or the stack pointers. To use inline assembly code you have to follow the compiler inline assembly syntax, that is very important. Because, different compilers have different syntaxes. GCC has one kind of syntax. IAR compiler has one kind of syntax and the syntax on ARM compiler may be different. First, the inline assembly statement should start with a keyword called __asm or you can omit this __ and you can just write the asm.  And after that, this is an optional type qualifier volatile, after that you have to write your instruction inside a parentheses and inside the double quotes, and you have to terminate the inline assembly statement with a semicolon.

volatile attribute is used to instruct the compiler not to optimize the assembler code. Sometimes what happens is, when you enable the optimization then compiler may optimize the code what you have included here. If you don't want compiler to do any optimization on your inline assembly code, then use the volatile.

__asm volatile("MOV R0,R1");

That's a syntax used by the ARM GCC compiler. If you want to include these instructions in a 'C' function let's say, then you have to write like this using inline assembly syntax of the GCC compiler.
	__asm volatile("LDR R0,[R1]");
	__asm volatile("LDR R1,[R2]");
	__asm volatile("ADD R0,R0,R1");
	__asm volatile("STR R0,[R2]");
Instead of using 4 separate inline assembly statements, you can do it in one using a syntax something like this.
	__asm volatile(
					"LDR R0,[R1]\n\t"
					"LDR R1,[R2]\n\t"
					"ADD R0,R0,R1\n\t"
					"STR R0,[R2]\n\t"
				  );
You can finish it of in only one statement, but every instruction you have to cover in double quotes. That instruction should be terminated by \n and \t.Just observe that there is no comma, just include every instruction inside the double quotes and terminate it by \n and \t. This syntax also valid, or for simplicity you can use this. 

__asm volatile(code : output operand list : input operand list : clobber list);
This is a general format of an inline assembly statement. This format applies only to the ARM GCC compiler. This format may be different if you move to different compilers such ARM CC or IAR. Apart from assembly mnemonics it has 3 other parts. What we call as operand list and a clobber list. In the operand list there are two types of operands. Output operand and input operand. Clobber list follows input operand list, and the clobber list is mainly used it to tell the compiler about modifications done by the assembler code.

Let's say I have only code block. We saw this instruction "MOV R0,R1". This is an example of inline assembly code which has only code block.There is no output operand, input operand or the clobber list. That's a reason you can write something like this.It doesn't have any operand list or the clobber list, or you can also write like this. This implies that there is no output operand, no input operand, and no clobber list. That's why, __asm volatile("MOV R0,R1"); and __asm volatile("MOV R0,R1":::); both are same.

__asm volatile("MOV R0,%0"::"r"(val):);

Each input and output operand is described by a constraint string followed by a C expression in parentheses. Basically, this is a procedure how we mix the ARM instruction and the 'C' variable. The constraint string is collection of a two more things, that is constraint character + constraint modifier.'C' variable val is an input operand and this is one input operand. Constraint string which should be written in double quotes.

Now the constraint string is collection of two things, one is constraint character plus constraint modifier. Here there is no constraint modifier, you only see constraint character "r". After that, in the parentheses you have to mention the 'C' variable name, that is Val. In the code section this refers to the first operand. This is used for operand indexing.Here, %0 refers to the first operand. This is a first operand. If you use %1, then that refers to the next operand. If it is there, like that. In our case, we don't have any output operand, that's why, you have to leave that space empty here and we have only one input operand. That's why, compiler will replace this by the first operand, which it finds in either output operand list or in input operand list.

"r" actually tells the compiler to use general registers for the instructions which it is going to generate.  Let's just build this project. After you build here you can see that for this inline assembly statement it generated 2 instructions. What it did was, first get the data from this variable to a register R3 and after that copy the content of R3 to R0. Because, the variable what we created is in the stack memory, it is in the RAM. That's why, this is a memory load.A variable data is loaded to R3 and this is a data copy. That's a beauty of using inline assembly code. If you don't use this inline assembly code, then you have to write this yourself. Instead of writing this, writing this is much easier. This constraint string "r" tells the compiler to use registers for the data manipulation. 

Let's say I use I, then it's a immediate value. Now you can see that the instruction is modified. And you can see that for this field no register is used, it's an immediate value. In the earlier case, for this field register was used. One register was utilized. But in this case it is replaced by the immediate value.

Let's  Move the content of CONTROL register to 'C' variable "control_reg". Here, control register is a special register of the ARM core. To read a special register there are some separate instructions in the instruction set. There are two instructions MRS and MSR. These instructions you have to use in order to manipulate the special registers. Whenever you are using output operands you have to use this is equal to operator as constraint modifier. That tells the compiler that the operand is write only. That means, the register what compiler has chosen for that operand will be write only. 

	__asm volatile("MRS %0,CONTROL": "=r"(control_reg) );

Let's use "r", it tells the compiler to use register for this instruction. So, you cannot use "i" here.Because, MRS takes only register as destination.
