We have user task now and we are going to schedule them using a scheduler. We'll be using simple round robin pre-emptive scheduling in this application. Preemptive means, switching out of a running task and switching in of the new task or the next task which is in the ready state. In this application, we do not consider any task priority. There will be no priority values for the user task. The scheduler will be executing for every 1 millisecond in this application.

Scheduler is nothing but our systick handler, that we would consider as a scheduler in this application. That's why, you have to configure the systick timer to generate exception for every 1 milliseconds. For example, let's say a task T1 is running on the CPU. We can launch task T1 manually. After that, after 1 milliseconds systick expires and it triggers the systick exception. And the systick handler runs, there we can switch out a this task and switch in this task. Like that, after T2, T3. T4 and after T1 it should revert back to T1 like that. What exactly is the scheduling? Scheduling is actually an algorithm which takes the decision of pre-empting a running task from the CPU and takes the decision aboutwhich task should run on the CPU next.

That means, scheduler algorithm decides what should be the next task. The decision could be based on priority of task, it could be based on shared resource access, that means, if a task which is getting switched out is holding any key to access the shared resource, then scheduler may take some dynamic decisions or it could be a simple round robin method.

What exactly is a context switching? The Scheduler does context switching. Context switching involves switching out and switching in procedure. Context switching is the procedure of switching out of the currently running tasks from the CPU after saving task's execution context or state and switching in the next task's to run on the CPU by retrieving the past execution context or state of the task. That's what we call as context switching.

What exactly is execution context or state of a taskt. We have a microcontroller, inside a microcontroller we have a processor or CPU, and in this case the CPU is ARM Cortex M4 or M3. Inside the processor we have processor core. A processor core is a collection of various units. For example, ALU( arithmetic logic unit).Processor core also has a couple of general purpose registers to store your operands, that is instruction operands and in order to store result, intermediate results you know the processor uses the internal a processor core registers. For example, let's say you have an instruction to add two numbers. Two numbers will be fetched from the memory and it will be stored inside the processor core registers. Then, ALU adds them and the result is stored back into the general purpose registers. After that, the result is return back to the memory. That's why, a processor core has all these units. It has ALU, general purpose registers, status registers, which actually gives the snapshot of the instruction execution like it has zero flag, carry flag, and negative flag etc.. That gives a snapshot of the last instruction execution. Also a processor core has some special registers such as program counter, stack pointer registers, and various other things. That is part of the processor core. Apart from this a processor also has its own peripherals such as NVIC, which controls a interrupts and exceptions coming from various parts of the microcontroller. Usually interrupts come from various parts of the microcontroller peripheral such as USB,Ethernet, SPI, I2C, Timer, etc.. And processor also has it's internal exceptions, everything is controlled by the peripheral called NVIC. That is the peripheral of the processor remember. And apart from that a processor has memory protection unit in order to guard the memory locations, it has system control block, it may contain a floating point unit, debug unit, etc.. These are peripherals of the processor. When the task is running on the processor, it will be using, I mean the instructions of the task handler will be using various general purpose registers, it could be using a status register and it could be using some special register. That's why, the collection of general purpose registers, some special registers, and a status register is collectively called as state of a task.

When the scheduler wants to switch out a task, then it should save its intermediate results of the operation which are already stored in general purpose registers and it should also store the status register value and some special register values into the private stack of the task. After that only scheduler can switch out a task. That's why, the collection of general purpose registers,some special registers, and status register is actually called as state of a task.

Let's revisit ARM Cortex Mx processors core registers. We have got R0 to R12, 13 general purpose registers, this is very important, this is part of the task's state, after that PC is very important. Because, when the Scheduler was preempting or switching out a task, the PC will be holding the address of the next instruction of that task handler. When the scheduler wants to switch in that task some time later it should know where it should return. So, that information that address is stored in the PC. That's why, you have to store PC also. Scheduler also preserve the value of PC. That's why, PC is also part of state of a task. And the link register. This is also very important. Because, that reveal some of the important information about the task handler, it's stack pointer selection, and other things. One more important thing is the current value or the current state of task private stack, that is also important and that is stored in PSP. Because, we are using PSP as a stack pointer for user task. That's why, we have to preserve the value of current state or current consumption state of task private stack That's why, we also should preserve PSP. After that PSR. That is also important, because that gives the snapshot of the current state like whether the zero flag has set or not or whether the negative flag has set or not, all those a state is stored in the program status register. That's why, we have to preserve program status register also. After that, all these privileged registers are not important. Because they are used for some special purpose like to turn off the interrupt globally and for other things. These are privileged registers. And most of the time user task maybe running with unprivileged access level. Saving of these registers doesn't make any sense. Because, the kernel or the scheduler is the one who is going to alter these a registers. User task should never touch these aregisters. That's why, it doesn't make any sense.

In summary, state of a task is the values of general purpose registers from R0 to R12, the stack pointer register in this case PSP, link register and program counter, and the program status registers.

( see diagram at 1:25 in lec 78 )
( see diagram at 3:11 in lec 78 )
( see diagram at 3:51 in lec 78 )
( see diagram at 5:08 in lec 78 ) - see which registers are saved automatically which we need to save manually
