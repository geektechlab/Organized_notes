There are 15 system exceptions and 240 interrupts or external exceptions. ARM Cortex Mx processor there is room for 15 system exceptions. Exception one is always reset exception. You can also call it as reset system exception. In M4, Only 9 are implemented as system exceptions. There is a room for 15 system exceptions, but only 9 are implemented in the hardware and 6 are reserved for future implementations. And the exception number 16 is called as IRQ1 are interrupt 1. in the generic user guide of the ARM Cortex M processor in the section exception model, you will find one section subsection , a exception types. If you just browse through this document, here you'll find one nice table and first 15 are the system exceptions, different system exceptions. Reset, NMI, HardFault, memory manage, BusFault, UsageFault, SVCall or SVcall, PendSV and SysTick are system exceptions. So, these are system exceptions, and from exception number 16 onwards these are interrupts or IRQs.

Reset is a system exception which is triggered or invoked on power on reset or warm reset. So, the power of reset is nothing but that is one reset circuitry in your hardware board, so that means, when you give supply to your board that a reset circuitry will trigger the reset exception or it will you know assert the reset signal of the microcontroller which will end up causing this exception inside the processor. Warm reset means, you know, you can also triggered this exception by pressing a button a reset button on the board. So, that what we call as warm a reset. So, that is you do the reset by pressing a button. whenever you reset a processor a reset handler will be triggered. So, the processor will start executing the reset handler and from there control reaches to the main function of the application. when reset is asserted, the operation of the processor stops, potentially at any point in an instruction. And when reset is deasserted, execution starts from the address provided by the reset entry in the vector table. So, the meaning of this sentence is, when reset is deasserted, execution starts from the reset handler. So, remember, reset handler execution is always in thread mode but it is privileged. Because, processor by default will always start in privileged access mode with thread mode.

non maskable interrupt is not actually a system exception, so this is a exception triggered by the peripheral. you can also trigger this exception by software. In fact, any exception you can trigger by a software. A non maskable interrupt can be signaled by a peripheral or triggered by software. So, this is the highest priority exception other than reset. So, reset has got the highest priority and it is permanently enabled and has a fixed priority of -2 and NMIS cannot be disabled or masked. Like the fault mask or a free mask registers they cannot mask out the NMI interrupt. So, it's a non maskable interrupt.

So, remember that, hardfault is an exception that occurs because of an error during exception processing. Let's say, you are already in some exception handler and if you come it any you know illegal instruction or any illegal code access, or any illegal instruction execution, then at that time the hardfault exception will be triggered. And it can also be triggered, because of an exception cannot be managed by any other exception mechanism. Take an example of your a T-Bit experiment. In the T-Bit experiment, you tried to execute an instruction by keeping T-Bit is equal to 0. So, that should actually trigger the usage fault exception of the ARM Cortex M processor. But, at that time you didn't enable the usage fault exception, isn't it? So, that's why, the exception will be escalated and it will trigger the hardfault. If there are no exception handlers enabled in order to handle a particular exception, then by default hard fault will be triggered. All right. So, and you need not to enable hard fault exception, it will be enabled by default in the processor. HardFaults have fixed priority of minus one and meaning they have higher priority than any exception with configurable priority.

memory manage fault is an exception that occurs because of memory protection related fault. So, this is to do with a memories. If your core tries to access some protected memory, then memory management or memory manage fault exception will be triggered, and this happens when you enabled the memory protection unit of the processor to guard some of the you know memories. For example, consider a real time operating system or embedded OS in which the kernel code can restrict user applications or user task to touch some memories. So, if your task tries to read or write into that memory location, MemManage you know exception will be triggered, and memory management exception will be triggered and the RTOS can forcefully end that task or it can take any other action. So, in that cases you know memory manage exception can be used.

Bus fault exception usually happens because of the bus errors and this we encounter very rarely in our program.

Usage fault can be a triggered for any of this reasons like undefined instruction. In our T-Bit experiment. We try to execute instruction by keeping T-Bit is equal to 0. So, when T-Bit is equal to 0 the processor thinks that, that instruction belongs to ARM instruction set. So, that's actually an undefined instruction for the ARM Cortex M processor. So, if you try to execute any instruction by keeping T-Bit is equal to 0, that is considered as undefined instruction for the processor. The usage fault can also be triggered a during unaligned data access.

SysTick exception is an exception the system timer generates when it reaches zero. SysTick timer is a peripheral of the ARM Cortex M processor. It is one of the peripheral. ARM Cortex M processor come with internal SysTick timer and you can use that timer in order to generate interrupts for a fixed time interval. All right.So, you can use it just like your any other timer peripheral of the microcontroller. And whenever that counter value of the timer reaches 0, the SysTick timer will generate an exception. And in OS environment, the processor can use this exception as system tick. For example, in your real time operating system or embedded OS you can use this SysTick feature of the ARM Cortex M processor in order to implement the kernel ticking. So, in order to perform context switching or in order to implement blocking call etc.. So, you can use this as a kernel tick timer. SVCall stands for supervisory or supervisor call, this is an exception that is triggered by the SVC instruction.

in an OS environment, applications can use SVC instruction to access OS kernel functions and device drivers. A you have a kernel code which is privileged and you will be having couple of tasks which are unprivileged. So, whenever the unprivileged a task or code blocks, if they want to take any you know if they want to touch any device drivers or any peripherals, then they cannot directly go and touch the restricted resources. So, because peripherals in those cases will be a you know considered as restricted resources. For example, memory is also a restricted resource. So, in that case, application can request for service from the kernel, and for that purpose the SVC instruction is used. So, the application has to execute the SVC instruction along with the service number. So, all SVC instructions will be executed with service number. And that execution of SVC instruction will cause SVC exception, and the mode of the processor will be changed to handler mode, and SVC handler will run in the kernel mode, and in that, that SVC number will be you know decoded and respective services will be provided to the application. So, it is to implement that system call interface layer.

pendSV is also a OS friendly exception given in the ARM Cortex M processor, and this is used for context switching in the operating system like Free RTOS or Open RTOS.
