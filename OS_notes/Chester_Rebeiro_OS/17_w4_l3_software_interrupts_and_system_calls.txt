In this video, we look at an important type of interrupts known as Software Interrupts and their applications in system calls. In the previous video, we had looked at hardware interrupts. We had seen how a device such as a keyboard or a network card could assert a particular signal in the CPU and this would cause the CPU to asynchronously execute an interrupt handler corresponding to the device. So, as we have seen in the previous videos, this device would typically send a signal to the CPU through an intermediate device such as a PIC or a programmable interrupt controller.

In much the similar way, we have what is known as a Software Interrupt. However, unlike having an external device which causes the interrupt, here an instruction in the program would trigger the interrupt. In this particular case, for example, an instruction such as INT would cause the interrupt to occur and the operating system to execute. So, here the instruction is INT x, so x here is the interrupt number. It typically has a value less than 256, and it is used to specify or distinguish between software interrupts.

So, where is the software interrupt used? So, software interrupts are used to implement system calls. So, as we know a user process could invoke a system call to perform some Kernel operation. For example, it could be to read a file or to write a file, to print something to a monitor, or to send a packet through the network and so on. More specifically, all operating systems implement system calls through one particular software interrupt. For example, in the Linux operating systems, the software interrupt 128 is used to specify system calls. Therefore, in a Linux OS, if I have a INT 128 which is executed in the user process, it would lead to an interrupt that occurs and cause the kernel or the operating system to execute, and thereafter the OS would execute code depending on the interrupt. In xv6, the software interrupt used to implement system calls is 64 or instruction like INT 64 in the user process would be meant to implement a system call.

So to take an example, let us consider that our application has a printf statement present in it. So, printf would print this string to the standard output, which typically is the monitor. Now printf is a function present in the library libc and it would cause the libc function to be invoked. Now in the libc function there is a call to the write system call with the specifier STDOUT. So, the STDOUT here is the file descriptor; and it is a special file descriptor which is meant for the standard output or the monitor. So in the write function, it would invoke INT 64 in xv6 or INT 128 in Linux and cause a software interrupt to occur. So, the software interrupt as we know would cause the transformation from the User space to the Kernel space and would it would result in the operating system executing. The OS would then determine that the interrupt was in fact due to a system call and then it would determine what system call it was from; in this case, it was from a write system call and it was a write to the STDOUT - the standard output. So the operating system would then invoke the handler for the write system call, and this handler would take care of communicating with the various devices such as the video card to display the string onto the monitor. So, after this handler completes execution, the IRET instruction is executed which would result in a transformation back from Kernel space to the User space and the program will continue to execute.

Now, typically operating systems support several different types of system calls. So, this particular table over here shows the various system calls supported by xv6. So, in a previous video we had seen some of them. For example, we had seen the fork, exit, wait so on. And you are also familiar with several types of system calls such as open, read, write, close, change directory, make directory and so on. So, each of these system calls would be executed by having a software interrupt such as INT 64, because it is the xv6, so it is 64. So, each time any of these system calls are invoked by a user process, it would trigger the operating system to execute.

Now, the next obvious question that one would ask is from the OS perspective, how does the OS distinguish between the various system calls? So, we mention that all the system calls will use either INT 64 for xv6 and INT 128 for Linux. So how does the OS determine whether the system call was with respect to fork, wait, sleep, exit, and so on. Essentially this distinguisher comes from the user process itself. What happens is that, before the INT 64 instruction, the user process will move a system call number to the eax register. So, for example, this instruction mov x, eax will move the system call number to the eax register. Now each system call in the operating system will have a unique number, system call number. Now the operating system when triggered by the INT instruction would look up the eax register, and then determine what system call was invoked. For example, in xv6, if we look up these particular header files, we would see the various system call numbers defined. For example, over here, we have each system call given a specific number, for example SYS underscore fork given 1, SYS underscore exit giving 2 and so on.

Now when the OS gets trigger due to the INT 64 instruction getting executed, the OS will determine the system call using this system call numbers and then invoke the corresponding system call handler. So, each of the system calls also have a corresponding system call handler. This is shown over here, corresponding to each of the system call numbers SYS underscore fork that is 1, SYS underscore exit it is 2 and so on. So, these are system call functions present in the operating system which gets triggered based on the type of the system call. For example, if eax had a value of 11, the operating system will look in to the eax register and determine that this corresponded to the getpid system call being invoked. And then it would look into this particular table and see that the getpid system call is handled by this function sys underscore getpid, and therefore it will then invoke this sys underscore getpid function.

Now, let us look at the typical prototype of a system call. So, of course, it has a system call name that is a function name and then it is passed some resource descriptor and parameters and typically would return an integer. So, the resource descriptor specifies what operating system resource is the target here. For example, it could be a file or a device; and as we have seen in the previous slides it could also specify a particular monitor. For example, if the resource descriptor is STDOUT then the resource in use here is the monitor. So, some system calls also do not specify this resource descriptor; in such a case, the system call is meant for that resource itself. For example, if we use the sleep system call, we only specify the time and no specific descriptor such as the file, a device and so on. This means that the current process wants to sleep for that given interval time. The next part is the parameters. So, these parameters are specific for the system call.

For example, if we invoke read, write, open or close or any other system call, the parameters specified here is going to be very specific for each of these system calls. For example, the write system call has the parameter buf that is a void pointer and the count. So, the open or the close or any other system call would have different set of parameters. So, essentially these parameters are very specific to the type of the system call. The return type is typically int or integer, and sometimes it is a void. So, ‘int’ is typically used because in this way the operating system will be able to send the completion status of the system call, whether it had executed successfully or it had failed and so on. So, sometimes the return is also used to specify certain specific information about the system call. For example, in write the return is size underscore t which in fact, is typdef to integer and it specifies number of bytes that have been written to the file, specified int fd. So, the return type could also vary depending on the type of system call.

The next thing what we will look at is how these parameters that is the resource descriptor and the parameters pass to the system call are sent to the kernel. So, note that system calls are invoked very differently from a standard function call. So, in a function call, as we know the instruction call would be used and the call would specify a address which is where the function would reside and the various parameters for the call are passed through the local stack. Similarly, the int return which is returned from the function call would be returned through the eax register. So, system calls on the other hand work very differently from function calls. So, as we have seen system calls invokes the kernel by the INT 64 instruction as in the case of xv6. So, how are the parameters such as the resource descriptor and the other parameters passed to the kernel?

So essentially, there are three ways of doing so. The first is by pass by registers which is typically done in Linux; the second way is by passing through the user mode stack which is done in xv6; and the third way is by passing through a designated memory region. So, in this particular case, what is done is that in the user process itself, a designated region most likely in the heap would be used to save the various parameters that is needed to be passed to the system call; and the address to this region in the heap is passed through the registers. So, we will look at the other two cases that is pass by registers and pass via user mode stack in more detail.

Now Pass by Registers which is used by Linux system calls would use the registers present in the processor to pass parameters to the kernel. So, we know we have already seen an example of this, of how the eax register is used to pass the system call number from the user process to the operating system. In a similar way, other registers such as the ebx, ecx, esi, edi, and ebp are used to pass the various parameters of the system call from the user process to the kernel. If the system call has more than 6 arguments then a pointer to a block structure containing the argument list is passed to the kernel.

Now, let us look at the second case that is Pass via the User Mode Stack and this is what is done in xv6. So, in this particular way, before the int 64 instruction is present various parameters in the system call are pushed onto the stack. For example, if the system call had 3 parameters; param 1, param 2, and param 3, so these three parameters are pushed into the user space stack and then the system call number as we have seen is moved into the eax register. So, this here is the user space stack in of the user process containing the three parameters. Now, when the INT instruction is executed, as we know, it triggers an interrupt causing the switch from the user space into the kernel space. Also as a result of this interrupt execution, as we have seen, there is the switch in the stack from the user space stack to the kernel space stack. And what we have seen in the previous video that this kernel stack is used to create what is known as the trapframe. So, this trapframe is shown over here. So, what we have seen in the previous video that some of these entries in the trapframe are pushed into the stack automatically by the CPU. So, in particular, these registers specified in capitals are all pushed onto the kernel stack that is on to the trapframe by the CPU. Now, the SS and ESP here is important for us. So, these are the stack segment and the stack pointer, and these registers correspond to the user space stack. So, as we know before the INT 64 has been executed, the last known stack pointer was pointing to this particular location. And therefore, the contents of ESP will also point to this location in the user space stack. So, in this way, the kernel will then use the SS and the ESP from the trapframe to determine the various parameters for the system call. The next thing we will look at is how the return value is passed from the system call back to the user process. Again we will recollect that the entire reason for creating this trapframe in the kernel stack for the process is due to the reason that when the interrupt or the system call completes its execution, the entire state in the trapframe is restored back into the corresponding CPU registers, and it would result in the user process continuing to execute from where it had stopped, and also the context of the user process is restored with the help of the trapframe.

Now, in order to return a value from the system call which is executing in the kernel space back to the user space, so what is done is that the eax register in the trapframe is modified; essentially, we had seen that the eax register because of this particular instruction would contain the system call number. Now this system call number is overridden by the return value of the system call. So, this could be a negative number like minus 1 or a positive number as we have seen in the earlier slide. So, now when the system call executes and completes its execution and the context is transferred back to the user process, the entire trapframe including the new value of eax in the trapframe is restored back in to the registers of the CPU. The process continues to execute from this particular instruction with the new value of eax, which contains the return from the system call.
