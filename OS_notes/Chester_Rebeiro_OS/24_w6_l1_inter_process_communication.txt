In this video we will look at Inter Process Communication. Essentially, when we write large applications it is often quite useful to write them as separate processes. So in order to have an efficient communication between these processes, in order to make things happen efficiently we use inter process communication. In this particular video, we will look at a brief introduction to IPC's that is Inter Process Communication and we will see a few examples of the same.

So we had seen this Virtual Memory View of a process. We said when a process is executing it sends out virtual addresses which get mapped into this virtual memory map. And we had seen that there is an MMU which uses page table stored in the memory and converts these virtual addresses into physical addresses. Now we have also seen that each process that executes in the CPU will have it is own virtual memory map. The use of virtual memory map provides some level of abstraction. Essentially, the executing process would only know its virtual addresses and with that virtual addresses, it can only access the user space of the virtual memory map. We had seen that the MMU then transfers this mapping into corresponding physical addresses.

So, the executing process will have no way to determine what the corresponding physical address for its memory accesses are. So for instance, if you declare an integer ‘i’ in your program you can print out the virtual address corresponding to ‘i’ for example, with a printf ampersand i. However, it is not possible for you in the user space to determine what the corresponding physical address is for that particular variable ‘i'. The second thing what the virtual memory map provides is that the executing process could only have access to its own virtual memory map. If there is another process it has with its own table, now in user space there is no way for the executing process to determine anything of the other process.

So, when there is a context switch and a new process executes it is the second processes virtual address map or virtual memory map which is then used. So this process has no way to determine any other processes virtual address map. So the thing to conclude from these two slides is that, a process has no way to determine any information or any data about another process. So given this, how does one process communicate with another process?

So in order to do this, there is a mechanism known as Inter Process Communication. Essentially with IPC's or inter process communication, two processes will be able to send and receive data between themselves. The advantage of IPC is that the processes could be return to be modular. So essentially each process is meant to do a single job and processes could then communicate with each other through IPC's.

For an example, let us say we have a data acquisition system and a control system. Essentially we could write one process which acquires data from the external world, such as the temperature, pressure, or the speed, and then it could then send this information or the data collected to a second process which then analyzes the data and determine some particular parameters. So these parameters could be sent to a third process which then actuates some external data, for instance it could open a valve or close a valve or adjust the temperature of the room and so on. Thus, we see we are able to achieve a modular structure in our application.

Each processes job is to only focus on a single aspect. The communication between the processes is achieved by inter process communication. In typical operating systems there are three common ways in which IPC's are implemented. These are through Shared memory, Message passing and Signals. So let us look at each of these things.

So, with a shared memory we have one process which creates an area in RAM which is then used by another process. So essentially, the communication between process 1 and process 2 is happening through this particular shared memory. Both processes can access the shared memory like a regular working memory, so they could either read or write to this particular shared memory independent of each other. The advantage with this is that the communication is extremely fast, there are no system calls which are involved. And, the only requirement is that you could define an array over here and then fill the array in the shared memory which can then be read by the other process. The limitation of the shared memory approach is that it is highly prone to error; it requires the two processes to be synchronized. So, we will take a small example of how shared memory is implemented in Linux.

So essentially, in a shared memory in the Linux operating system, we have three system calls which are used. First is the ‘shmget’ or the shared memory get, which takes three parameters; a key, size, and flags. So this system call creates a shared memory segment. It returns an ID of the segment that is ‘shmid’ - the shared memory ID of the segment. So the parameters key is a unique identifier for that shared memory segment, while size is the size of the shared memory. So this is typically rounded up to the page size that is 4 kilobytes. So, this is how a shared memory gets created in a particular process.

Now an other process could attach to this shared memory by this particular system call that is shared memory attach - ‘shmat’. So, this particular call requires the shared memory ID, and address, and flags. So, essentially system call would attach the shared memory to the address space of the calling process. The address is a pointer to the shared memory address space. So we will understand more of this through an example. The opposite of the shared memory attach is the shared memory detach where a process could detach the shared memory from it is user space. So, the detach system call takes the shared memory ID.

Let us see the, an example of shared memory with this example. So, let us say we have written this particular program called server dot c and we create a shared memory in this. So we define a key called 5678 this is some arbitrary value for key, but the requirement is that this key should uniquely identify the shared memory. So we could use this key to invoke this function shmget, we pass it the key, we pass it shm size that is shm size is defined here as the size of the shared memory which we want to create. Note that; this size although we specified as only 27 bytes, we will get extended to a page that is we will create a page of 4 kilobytes corresponding to this. The third parameter is the permissions, that is we are given it as IPC_CREAT that is we are creating this particular shared memory and these are the permissions: read, write, execute permissions. And of course, if this function fails then it enters over here and exits. Otherwise, if it executes successfully we get a valid shared memory ID.

The next part is to invoke the shared memory attach - shmat providing this particular ID and we will get a pointer to this particular shared memory. So, shm so we have like char star shm this is a pointer to the shared memory. Now the shared memory attach would return a pointer to this particular shared memory. Now in case it returns minus 1 then it is due to an error and we are exiting. Now at this particular point we have obtained a pointer to the shared memory and we can use that particular pointer just as a standard pointer as we use in a C program. So for instance, over here we have moved the pointer to this variable s which is defined as char star s and we have put alphabets from - a to z in this thing. And finally, we have ended it with a null termination and then we are going in an in a loop continuously sleeping, so we will come back to these two statements later on.

Now, let us look at the client side of this code. So we invoke this shmget and give it a key, that is key is the same 5678, the shared memory size is as before 27 and we are providing the permissions. Note that we do not require to give CREAT over here because the shared memory region is already created. Then we attach to this particular shared memory segment as before, we invoke the function shared memory attach - ‘shmat’ and we pass it the shared memory ID. Then we get a pointer ‘shm’ which is a pointer to this shared memory location. So, essentially both the server as well as the client are pointing to the same physical memory page. Now we could actually read data from this particular shared memory region. So remember that the server has put values from a to z that is a b c d to z, while in this case we could read the values a to z into this particular pointer s and print it out in the screen. So once we have completed reading all data from the shared memory we put this star into the shared memory location. This is the first location in the shared memory.

Now recall that over here in the server we have put a while loop which continuously loops until the first parameter pointed to in the shared memory is a star. So when we obtain a star it means that the client has completed reading all data and therefore the server can exit. In a similar way the client can exit as well. So, you see that we have these two processes; one is server, one a client. And these two processes are having their own virtual address space, but by the use of this shared memory which is created by the shared memory get and shared memory attach, we have able to create a shared memory region which is common between the server and the client. Then we have obtained a pointer to that particular shared memory region that is s on shm and the server could put data into the shared memory region while the client could read data, the vice verse is also possible. And at the end of it we required to note that there is a synchronization required between the server and client. So this synchronization requirement should be explicitly program into this particular server client modules.

Next, we will look at the Message Passing. Unlike the shared memory that we just seen where the shared memory is created as part of the user space, in message passing the shared memory is created in the kernel. Essentially we would then require system call such as send and receive in order to communicate between the two processes. If a process 2 wants to send data to process 1, it will invoke the send system call. So this would then cause the kernel to execute and it would result in the data return into the shared memory. While, when process 1 invokes receive, data from the shared memory would be read by process 1.

The advantage of this particular message passing is that the sharing is explicit. Essentially both process 1 and process 2 would require support for the kernel to transfer data between each other. The limitations is that it is slow, each call for the send or receive involves the marshalling or demarshalling of information. And as we know in general a system call has significant overheads. Therefore, message passing is quite slow compared to shared memory. However, it is less error prone then shared memory because the kernel manages the sharing, and therefore would be able to do the synchronization between the process 1 and process 2.

Another very common application or message passing is the use of Pipes. Now pipes are used between parent and child processes only. Essentially, you can only communicate data from a parent process to a child process and vice verse. Another aspect of pipes is that it is unidirectional. Now when a pipe is created generally there are two file descriptors which are associated with it that is fd [0] which is used to read from the pipe, while fd [1] is used to write to the pipe. So we know the unidirectional nature of this particular IPC. So, fd [1] is exclusively used to write to the pipe buffer, while fd [0] is used to read from the pipe buffer.

So in order to obtain two way communication between the parent and the child, we would require two pipes to be obtained; pipe 0 and pipe 1. So, when pipe 0 is opened it would create two file descriptors; one to write into pipe 0 and the other one to read from pipe 0. Similarly, there are two file descriptors to write to pipe 1 and read from pipe 1. Similarly there are two pair of file descriptors for pipes in the child process.

Now you note that these additional descriptors are not required, therefore we could actually close the extra file descriptors to obtain something like this. Now in order that the parent sends some information to the child, the parent will write to pipe 0 while the child will read from pipe 0. In order to that the child sends some information to the parent, the child will write to pipe 1 while the parent will read from the pipe 1.

So let us see an example of the user pipes. So this again is a standard Linux example and as we have said, so we create a parent and child process so that there is a uni directional communication from the parent to the child. So let us look at this particular thing. First we invoke this particular system call called pipe and give it this pipefd. So pipefd is defined over here and taking two elements and then we invoke the system called fork. So as we have studied the fork system call would create a child process which is the exact duplicate of the parent process. So in the parent process the value of a pid that is the value what fork returns is the child's pid value, and it is a value which is greater than 0. On the other hand in the child process the value return by fork is 0.

So, let us see what happens in the child process first. So in the child process because the pid value is 0 so it would come over here and the first thing what we do is we close pipefd [0]. So, closing pipefd [0] would mean that we are closing the read pipe to the child, that is so we are we having like two pipes over here corresponding to pipe 0 and we have just closing the read pipe while the pipe 1 that is the right file descriptor is still open. Now let us see what happens in the child process, in the child process the value of pid returned by fork is 0, therefore it will result in this particular code being executed. So in this code first, there is we are closing the pipefd [0]. So this means that the file descriptor corresponding to the read pipe is closed.

Second, we are then opening a second file called fdopen corresponding to file descriptor 1 and it is opened in the write mode and we could then use fprintf out “Hello world”. So essentially what we are doing is to this pipe with descriptor 1 we are writing “hello world”. So if you go back to this particular thing, so what we are seeing is that we are writing “hello world” into this pipe 1. Now in the parent process which would execute over here because fork would return with the value which is greater than 0, so we are closing the write pipe and opening using fdopen, the read pipe. So we are then using fscanf to read whatever has been pushed into the pipe, in this case it is “hello world” and printing it to the screen.

So, essentially what we have implemented in the program is this lower part. So the child opens this pipe in the write mode and puts “hello world” into this pipe while the parent then opens the pipe 1 in the read mode and reads the string “hello world” from the pipe. Thus, the string “hello world” has been transferred from the child to the parent. So you can actually try to implement this particular program and execute in a Linux system.

Besides, the message passing, shared memory and pipes that we have studied so far. A Third way of inter process communication is by what is known as Signals. So, signals are asynchronous unidirectional communication between processes. The operating system defines some predefined signals and these signals could be sent from the operating system to a process, or between one process to another. Signals are essentially small integers, for instance you would an each of these integers has a predefined meaning. For instance, 9 would mean to kill a process, while 11 would mean a segmentation fault and so on.

So in order to send a signal to the process we could for instance have kill send it to this pid and we could send this particular signal number which is an integer. In order that the process handles that signal it is to define this particular function called signal, which takes the signal number for instance 9 or 11 and then the handler. So, handler is a pointer to the signal handler for that particular number. So as a result we could send signals from one process to an other and depending on the type of the signal the corresponding handler would be executed.

In this video we had seen a brief introduction to IPC's. Essentially, we had seen different types of IPC's like, message passing, shared memory, pipes and asynchronous transfers using signals. These IPC's are used extensively in systems to communicate between processes. And therefore, we are able to achieve or built applications which are extremely modular with small programs, with each program focusing on only a certain aspect in the entire system.
