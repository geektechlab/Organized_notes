In today's video we will look at interrupts, which forms a crucial part in all modern day operating systems. So, unlike normal software or normal programs that we write, operating systems are event based that is whenever an event occurs only then the operating system executes.

So suppose you have a user process that is running, so as we have seen before user process runs in user space and in the Intel nomenclature this is in ring 3. Now this user process continues to execute on the processor until an event occurs. So, when this event occurs it would trigger the operating system to execute. So, this triggering of the operating system will also result in a change in the privilege level. So the system would no longer be executing in the user space, but rather it will be in privilege level 0 or that is executing in the Kernel space. So the operating system would essentially execute and service this particular event and at the end of that execution, the control is fed back to user space and the process will continue to execute. So the User space process which would execute after the OS completes could be the same process that is User process 1 or some other User Process, in this example it is User process 2.

Let us look at how events are classified. So, various literature categorizes events in different ways, but what we will do is we will follow the categorization of events based on this particular book called the Art of Assembly Language Programming which can be downloaded from this website. So, in this book events are classified into 3 different types; these are Hardware Interrupts, Traps and Exceptions. So Hardware Interrupts or sometimes just called as Interrupts are raised by external hardware devices. For example, the network card when it receives a packet could possibly raise an interrupt or other devices such as the keyboard, mouse or a USB device when plugged in could raise in hardware interrupt. So, these hardware interrupts are asynchronous and can occur at any time.

Besides hardware interrupts there are Traps and Exceptions. Traps are sometimes known as software interrupts, they are raised by user programs in order to invoke some operating system functionality. For instance, if a user program wants to print something on the monitor it would invoke a trap, which essentially would be a system call to the operating system and the OS will then take care of writing the particular text or writing the particular data on to the screen.

The third type of event is known as Exceptions. These events are generated automatically by the processor itself as a result of an illegal instruction. So, there are 2 types of exceptions these are Faults and Aborts. A very common example of a fault is a page fault. So, faults are essentially exceptions from which the processor could recover. For instance, when there is a page fault that occurs when a process is executing, it would result in the OS or in the operating system executing and loading the required page from the swap space into the RAM. On the other hand, an exception which is of the form abort would be very difficult to recover, such as a divide by 0 exception. So when a divide by 0 exception occurs in a program, typically the program would be terminated. Essentially the operating system has no way to recover from such a divide by 0 exception. Exceptions are further classified into Faults and Aborts.

So, we will now take a specific case of interrupts that is of Hardware Interrupts. So, let us look at Hardware Interrupts. In general, processors today have a dedicated pin on the IC known as the Interrupt pin. So, this pin is often shortened or just called by the INT pin or in some processors as the INTR pin. So, devices such as the keyboard will be connected to the processor through the INT pin. When a particular key is pressed on the keyboard it would result in an interrupt being generated to the processor.

Now, let us see how this particular interrupt takes place and what happens in the processor. So, the processor typically would be executing a program and would be executing some instructions. Now, when a key is pressed, an interrupt is generated to the processor and that would result in a switch in the processor to what is known as the Interrupt Handler Routine. So, in this particular case since it is the keyboard which has resulted in the interrupt, the keyboard interrupt handler routine would be invoked. The processor would then begin to execute this keyboard handler routine until an instruction such as the IRET is obtained. When the IRET instruction gets executed, the context is switched back to the program which was originally being run. So, in this way we see that interrupts could occur any time during the programs execution, it would result in a new context being executed and at the end of that execution the processor goes back to the original context.

So typically systems do not have just one device connected to the processor, there could be several devices. For instance systems could have timers, USB drives, keyboards, mouse, network cards and so on. However, as we have seen previously the processor just has a single interrupt pin. So how is it possible then that several devices share the single interrupt pin? In order to achieve this, a special hardware is used in systems. So, this is known as the Interrupt Controller. The job of the Interrupt Controller is to ensure that the single pin of the interrupt is shared between multiple devices. So, the interrupt controller would receive interrupts from each of these devices and then channelize that interrupt to the INT pin of the processor. The processor would then communicate with the interrupt controller to determine which of these devices had actually generated the interrupt. As a result, the processor would then execute the corresponding interrupt handler routine. For instance, if the timer had resulted in the interrupt then the timer interrupt handler routine would be invoked. On the other hand, if a USB device had resulted in the interrupt, the USB interrupt handler routine would be invoked and so on. Thus, the interrupt handler routine invoke is going to be very specific to the device that cause the interrupt to occur.

So, one commonly used interrupt controller is known as a Programmable Interrupt Controller. So, it is numbered as 8259 and pictorially this is how it gets connected. So, the 8259 has two sides, this is the input side and the output side. The output is connected to the INT pin of the CPU, there is also an INTA pin which is an interrupt acknowledge pin. On the other side we have 8 IRQ lines. IRQ stands here for Interrupt Requests. So, on the input side there are up to 8 devices that can be connected to the 8259. These devices are labeled device 0 to device 7, all these devices could independently request an interrupt from the CPU. The 8259 would then channelize that interrupt through the INT pin of the CPU. The CPU would acknowledge the interrupt through the INTA pin and also determine which of these 8 devices had requested the interrupt.

Now, what would happen if two devices request the interrupt at exactly the same time? In such a case, 8259 would use some priority encoding algorithm to determine which of these devices should be given the privilege to request for the interrupt first. Another feature of the 8259 is that it can be cascaded to support more than 8 devices, thus more than 8 devices could cause interrupts to the CPU. So in Legacy computers typically there are two 8259 controllers present - one is configured as the master, while the other is configured as the slave. The slave 8259 controller is connected to one of the input channels of the master 8259. So, if any of these devices connected to the slave 8259, request an interrupt, this interrupt is channelized to the master 8259 and the master 8259 would then channelize this interrupt to the CPU.

So, one limitation of this legacy configuration of the 8259s is the limited IRQs. So, each device could as we sink and support only 8 devices and therefore, if you have large number of devices in your system then you would require several 8259 controllers to be present. Another major limitation of this configuration is that, the support from multi-processor and multi-core platforms is difficult. Essentially as we seen over here, there is only one CPU that is connected to the master 8259 programmable interrupt controller. This particular INT pin cannot be sent to an other CPU, which may result in some problems.

In current systems, the 8259 programmable interrupt controller is replaced by something known as APIC or Advanced Programmable Interrupt Controller. The configuration for the APICs in modern systems is as shown over here. So, each CPU in a multi-core or multiprocessors system would have a local APIC as shown here. So, Processor 1 has a local APIC, Processor 2 has its own APIC, Processor 3 has its own local APIC and so on. In addition to this, there is something known as an I/O APIC which is present in the System Chip Set. Now, external devices such as keyboards, mouse, network cards, and so on, would request interrupts through the I/O APIC which is then channelized to one of the local APICs in each CPU. Thus interrupts can be distributed and prioritized between CPUs. Also the local APICs as well as the I/O APICs communicate through interrupt messages and IPIs that is Inter Processor Interrupts. So the local APIC receives interrupts from the I/O APIC and routes it to the corresponding local CPU. The local APIC can also receive some local interrupts such as interrupts from the thermal sensor which is present on the CPU, an internal timer and so on. So, the local APIC could also send and receive IPIs which is Inter Processor Interrupts, which allows interrupts between processors that it allows processors to do system wide functions like booting, load distribution, and so on. The I/O APIC is present in the System Chip Set which is sometimes known as North Bridge. This particular APIC is used to route external interrupts into the local APIC.

So, we have seen so far that we have multiple devices which are connected to an interrupt controller which could be either an APIC or in legacy systems based on the 8259 controller. When any of these devices request an interrupt, the interrupt is channelized to the processor and it would result in the corresponding interrupt handler routine to be invoked. How does the processor know the location of the Interrupt Handler Routine? So, the interrupt handler routine, just like all other software codes or all other codes, so the important question that one needs to ask here is how does the processor know the location of the interrupt handler routine. So, the interrupt handler routine is just like any other software code is also executed from the RAM. So, the question that we are posing here is how does the processor know the starting location or the address of the interrupt handler routine.

So in order to achieve this, what happens is the following; so each of the devices that are connected to the interrupt controller is also has a dedicated number known as the IRQ number. So, when a device, request an interrupt and the INT pin in the processor gets asserted, the processor would then obtain the IRQ number from the interrupt controller. In this way the processor now determines which of these devices has requested for the interrupt. We will now see how the processor uses the IRQ number. In the memory of the system, a table known as the interrupt descriptor table or IDT is stored. So this IDT table is pointed to by a register stored in the processor known as the IDTR. This is interrupt descriptor table register. So, each entry in this descriptor table contains information of where in memory the corresponding interrupt handler routine is present. So, the processor would use the IRQ number to look into the interrupt descriptor table, from this descriptor the corresponding location of the interrupt handler routine is obtained and there after the processor can then execute instructions from this handler routine.

So, what is the contents of the interrupt descriptor table? In the x86 systems, since it also has segmentation. So therefore, the each interrupt descriptor would contain the segment selector as well as the offset. The segment selector as we have seen is of 16 bits and while the offset is of 32 bits. So, bits 0 to 15 are here and the bits 16 to 31 are present over here. There are other aspects in the interrupt descriptor such as the Present bit and the Descriptor Privilege Level.

So let us see how this Interrupts Descriptors are used in reality. So, the processor would obtain the IRQ number or the interrupt vector from the programmable interrupt controller or the APIC, and as we have seen this interrupt vector is used to index into the IDT table, and the corresponding interrupt or trap gate contains the segment selector as well as the offset. The segment selector is then used to index into the GD or the LDT table from which, the base address of the code segment is obtained. The offset part is then taken and added, to the base address to obtain the final address where the interrupt procedure is present. So the Intel x86 systems supports 56 different types of events. Some of these events are used internally for faults and aborts, while others can be configured for hardware interrupts as well as for software interrupts.

So, this particular table gives some of these interrupts and exceptions that are supported by Intel x86 systems. Especially we would like to see that interrupt with vector number 0 to 31 are internal to the processor, of these the vector number 0 to 20 are used for various faults or aborts. The interrupt vector numbers from 32 to 255 can be user defined. So, some of these user defined interrupts are configured as hardware interrupts, while others are used as software interrupts.
