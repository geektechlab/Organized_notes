In a  previous video, we had seen about several important system calls related to process management. So, we had seen these system calls such as the fork, exec, wait and exit. So in this video, we will look at how these system calls are implemented within the operating system. So in particular, we will see about how the system calls are implemented in the OS xv6. So, we will be referring the xv6 source code, which can be downloaded in the form of a booklet from this particular website. Please download the revision number 8, so that it matches with the particular video.

let us start with the fork system call. In the previous video, we had seen that when the fork system call gets invoked it creates a child process. The return value of fork that is pid over here will have a value of 0 in the child process; as a result, these green lines are what is executed exclusively by the child process. While in the parent process, the value returned by fork will be greater than 0 essentially the value returned by fork will be the child process’s pid value, thus these purple lines are what is going to be executed by the parent process. Inside the operating system, the fork essentially creates a new process control block and fills it. Recollect that in xv6, the process control block or PCB is defined by a struct proc as shown over here.

So, essentially what fork does is that it is going to fill up the various elements of the struct proc corresponding to the new child process created. Recollect also that there is a ptable that is defined in the xv6 operating system. The ptable essentially contains an array of procs, the size of the array is NPROC which is the total number of processes get that, can run at a single time in the xv6 OS. So, every process is allocated one entry in this particular ptable. The implementation of fork in xv6 is as shown over here. So, this can be seen in the source code listing in line number 2554. So the first thing you would notice over here is that we are declaring a pointer called ‘np’ which is defined as a struct proc pointer. So, this is a pointer corresponding to the new process that is been created or rather the new child process.

Now the first step that fork does is to invoke allocproc. So, what allocproc does that is what this function does is that it is going to parse through the ptable and find a proc structure which is unused; once this proc structure is found, then it is going to set the state as EMBRYO. So, recollect that in xv6 EMBRYO means a new process which is not yet ready to be executed, also which is set is the pid for the new child process. Other things which are done in allocproc is the allocation of a kernel stack and filling the kernel stack of the new child process with a things like the trapframe pointer, the trapret as well as the context.

The next step in the fork implementation is this, call to this function called copyuvm. So, essentially what the copyuvm function does is that it copies the page directory from the parent process to the child process. This copyuvm takes two parameters; it take the parent page directory which is represented by proc point pgdir; and the parent size that is represented by ‘sz’, and what is returned by this function is a pointer to the new processes page directory.

if this function fails then everything is reverted. First, the kernel stack which has been allocated previously in allocproc gets freed, and the value of np kstack is set to 0 and the state is set back set to UNUSED again. Remember that allocproc had set the state to EMBRYO, now over here the state is set to unused. Then fork is going to return with minus 1. So, this minus 1 is sent back to the user process that is the process which had invoked forked.

The next step in the fork implementation is to copy some of the parameters of the parent onto the child; of these steps the most important one is the third one where in the entire trapframe of the parent process is copied onto the trapframe of the child process. Now recollect that the trapframe is used or rather recollect that a trapframe is created whenever a hardware interrupt occurs or a system call gets invoked. If we go back over here when the fork system call gets invoked, it triggers the operating system to execute as well as its going to create a trapframe for this process in the kernel stack.

Now the trapframe is used, so that when the fork system call completes executing in the operating system it will return back to this point. Now by copying the entire trapframe of the parent process to the child process, it will allow that the child process also continues to execute from this point; thus when fork returns in the child process, the child process will execute from this point. Also, recollect that the difference between the return types of the parent process as well as the child process is that the pid value in the child process is 0; while in the parent process, it has a value that is greater than 0. So, we will next see how this is achieved. So essentially in the fork implementation, we see that in the trapframe of the new process the value of “eax” is set to 0. So, this will ensure that in the child process, the return value of fork is set to 0. We will see later how the return value in the parent process is set to the child’s pid.

In this part of the fork implementation, other things are copied from the parent process onto the child process. Other things include the executable name, cwd that is the current working directory and copy of file pointers from the parent. Now that the proc structure for the child process is completely filled, the state is switched from EMBRYO to RUNNABLE. So, setting the state to runnable would imply that a scheduler could actually select this child process and allocate it to CPU. Thus the child process would be able to run and execute code on the CPU. The return from the fork implementation is pid, the value of pid is set over here. So, essentially the pid is np pid that this is the child process’s pid value. And this pid value goes as the return to the fork in the parent process. Thus, in the parent process in the user space, fork would return with the pid value of the child process, while as we have seen in this line over here in the child process, fork would return with the value of 0.

When it comes to the CPU registers, all register values in the child process is exactly identical to that of the parent process except for two registers. As we have seen before, one is the eax register. So, in the child process the eax register is set to 0 so that when fork returns, it returns with the value of 0 in the child process. And other thing which is changed in the child process is the eip or the instruction pointer. So the instruction pointer is set to forkret which is a function which is exclusively executed by the child process and not by the parent. So, forkret is a function in the xv6 code as you can see.

Now, we will recall the exit system call internals. So, when a exit system call gets executed, these are the six things which occur inside the operating system. Essentially, there would be a decrement in the usage count of all the open files. Further, if the usage count goes to 0 then the file is closed. Second, there is a drop in reference for all in-memory inodes. Third, there is a wakeup signal sent to the parent process; essentially, if the parent state is sleeping then the parent is made runnable. Why is this needed? Essentially this is needed because a parent may be sleeping due to a wait system call and therefore, making it runnable would ensure that the wait system call becomes unblocked. The fourth point is that the exiting process will make init, recollect that init is the first process ever created by the OS. So the init process is made to adopt all the children of the exiting process, and the exiting process is going to be set to a state called a ZOMBIE state. This setting of state to ZOMBIE is used, so that the parent process would then determine that one of its child processes is exiting. So, we will see more on this in the wait system call. And lastly it is going to force a context switch in the scheduler.

We will next see the wait system call. Recollect that when the wait system call is invoked in the parent, it is going to be blocked until one of its child process exits. So, if no child exits then it will continue to be blocked. On the other hand, if the parent process has no child at all, then it will return with minus 1. Now we will see the internals of the wait system call. So this is the implementation of the wait system call in the xv6 operating system. So, this listing is obtained from the proc dot c file of the xv6 source code. Essentially, you would see that it has an infinite loop by this that is for semicolon semicolon which starts over here and ends at this point. So, within this particular infinite loop, there is an inner for loop which is from here to here. So, essentially this inner for loop parses through the ptable. So, recollect that the ptable is an array of procs; and each and every process which is in some state in the xv6 OS has an entry in the ptable. So, by parsing through all elements of the ptable, this particular loop will be able to check every process that is present in the xv6 OS in this particular instant.

So the first check that it does is to find out whether the current proc is the parent of this particular entry in the ptable, which is p. So, it is going to find out if the current proc which has invoked the wait is the parent of p. If it is not the parent then it just continues; otherwise it comes over here. So, at this particular point, in the implementation, we are ensure that the p is a child of the process which has invoked the fork. The next check is to determine the state of p. So, if the state happens to be ZOMBIE, it indicates that the child process has exited, and therefore, it will enter this particular if condition and it will do various freeing such as it is going to free the kernel stack, set the state to unused, set pid to 0, and so on. The return is that this point, so this would result in the break of the infinite loop and it will result in the wait to exit and the return would be the pid; essentially pid is the child process’s pid value.

So, you may have noticed two things; first the kernel stack of the exiting child is cleared or rather is freed at this particular point, second the page directory corresponding to the exiting child is freed at this particular statement. So, freeing this child processes stack as well as page directory would allow the parent process to peek into the exited child’s process. So, this enables better debugging facilities of the child process. For instance, if the child happens to have crashed then the parent process could look up the stack as well as the page directory, and therefore into the physical pages of the child process and we will be able to get information about why the child process has crashed. Next during the entire for loop, if we have found no children for the particular process then we just return minus 1. So, wait will again return to the user process, but with a value of minus 1. So, execution comes to this particular line that is the sleep, when we have a child process which is not in a ZOMBIE state. So, in such a case this wait statement is going to sleep until it is woken up by an exiting child.

So we will now look at the internals of the exec system call. Recollect that the exec system call would load a program into memory and then execute it. In this particular code distinct, the parent process would invoke the fork system call which would result in a child process being created. The child process in this particular example would execute the exec system call; and as a result, it would cause a new program to be executed in the system. In this particular example, the new program is the 'ls' program, which lists all the files in the current directory. Now, 'ls' is an executable. It has a current a particular format known as the ELF format or Executable Linker Format. So, this particular format is what is interpreted internally by the exec system call within the operating system and this format is essentially understood and used to load ‘ls’ from the hard disk into the RAM.

So let us see what actually is present in the ELF format. So, every time we actually compile or link a program, it creates an ELF executable or an ELF object. For instance, with the example that we took that is - slash bin slash ls, this is an ELF executable. So, it has a format has shown over here, so at least this is part of the format, and more details about the format can be obtained from these particular references. What we will do now is we will go through some important components of this ELF executable, and see how this is going to be useful for us that is, from an OS perspective.

So, we will start with the ELF header. The ELF header contains various parameters and these are just a few of the parameters which are present. So the ELF header starts with an Identifier. So, this identifier essentially is a magic number which is used to identify whether this file is indeed an ELF file. Second, there is the type so a type would tell that the type of this ELF file, so the type would have a value of executable or relocatable object or shared object or core file and so on.

Another important entry is the Machine Details. So it would tell information about whether this ELF executable or the ELF object could run on a certain machine. For instance, ELF this machine details could have values such as i386, x86_64, ARM, MIPS and so on. Then we have an Entry value in the ELF header, this entry value will tell the virtual address at which the program should begin to execute. So, beside this we have a pointer to the program header, number of program headers which are present, pointer to section headers and the number of section headers which are present.

let us take this particular example of our hello world program written in C, and we compile it with the minus c option. So, when you say gcc hello dot c minus c, it creates the object file hello dot o. So, this is an ELF object, we then use a utility readelf with an option minus h with the object file hello dot o. So the minus h option would print the ELF header. So, this is the ELF header, so it has a magic number which essentially is the identifier and it is used to distinguish this particular object file from any other file. So, it is used to say that this particular object file is indeed an ELF file. Then another thing which we have seen is the Type of the ELF header which it could be for instance a relocatable object and so on. So, this in this particular example, since we used a dot using a hello dot o that is a object file, it is a relocatable object file and you can actually see it over here REL which is a relocatable object file.

And another thing is the machine details, which over here which specified as Machine in this case it is the AMD x86-64. So, which indicates that this object file is for x86-64 bit machines, then we have seen the Entry point in this case is 0. So, other things we have seen is the Start of the program headers which is 0 (bytes into the file), this one pointer to program headers. And we have seen the Number of program headers in this particular object file is 0. In the other two aspects are the pointer to the section headers and the number of section headers. So the pointer to section headers is the Start of section headers it is 368, and the Number of section headers is 13. So, in this way, we can actually see the various contents of the ELF header. Now, we will look more into detail about the Section Headers, so in order to get a listing of the section headers you could use readelf minus S hello dot o, which will print all the section headers present in the relocatable object hello dot o. So, this is actually shown over here. So, we will not go into too much details of this because not much is applicable for us, but just give an explanation about the various columns. So, this particular column that is the second column over here is the name of the sections, while the third column gives you the type of the sections. So the type could be one of these, these are the PROGBITS which is information defined by the program, SYMTAB which is a symbol table, NULL or NOBITS essentially is the section which occupies no bits, and RELA which is a relocatable table. Then we have here the address which is a virtual address for where the section should be loaded. In this particular case, it is all 0’s because it is a dot o file, it is an object file and it could be relocated. Then here you have the offset and the size of the sections, while here you have a table size if there is a table then you have a non-zero value; however, if no table is present then you have a 0 value. Next, we will look at the Program Header Contents So, program header also has several parameters such as the type of the program header, the offset, the virtual address essentially the virtual address where the segment needs to be loaded, and you have a p address offset which is essentially ignored.

So, in order to get the program headers for our hello world program, so we use readelf minus l hello. So note that, we are giving the executable over here and not the object. So these are the parameters which are printed related to the program headers. So, essentially we have the type of the header, the offset, the virtual address where it needs to be loaded, physical address, the memory size and the flags. Now that we have some idea about ELF executable files and exec elf objects. Essentially how they are stored and the various components in the ELF images, we are equipped to see how exec system call is implemented in the xv6 OS. So, this is actually listed over here. And you could also look it up in the xv6 source code in this particular file, that exec dot c. So, also shown in the slide is the virtual memory map. So, recollect that the exec system call gets invoked by the child process. So first, there is a parent process which forks and in the child process, the exec system call that gets invoked. So, when the child process is created by forking, there is a virtual memory map which is created for the child process. And we as we have seen the top half or the top area regions of this virtual memory map comprises of the kernel code, while the lowest half comprises of the user code and data. Also we have seen that, during the process of forking there is the kernel stack which gets created. So, this kernel stack is specific for this child process.

Now, we will see how as exec function executes this virtual memory map changes. So, to start with let us look at the exec parameters which are taken. So, in this case there are two parameters which are taken that is the path and the argv, so path specifies the path to the executable. So, in our example we have used slash bin slash ls. So, this would be specified in the path while argv is the parameter which you are passing to the particular program. So, for instance ls if you are taking could have arguments such as ls minus l or ls minus t and so on. So the minus l and minus t are arguments which are passed over here. So the first thing that is done is that we get a pointer to the inode of the executable. Now inode is a metadata which has information about where the particular executable is stored on the secondary storage device such as the hard disk. So, for instance, in our particular case, where we are using slash bin slash ls, so this particular function namei would return the inode for the ls executable. Next, what we are doing is we are using this function called readi, which reads from that inode that is from the secondary storage device, the ELF header. So, we are reading the ELF header from this particular inode. So, elf header or just mention as elf over here is defined over here as elf header. So, we are then looking up into this ELF header and checking the identifier, we are checking the magic number and we are verifying whether this magic number is indeed correct.

So, this essentially is a sanity check and this magic number for ELF should have this particular value that is, it should have \x7fELF. So, this is this is the 7f is the hexadecimal value, while ELF is the alphabets. The next step is a call to the setupkvm, where we setup kernel side page tables again. So this essentially may not be required, but it is done in xv6, though it is not a necessity since, we have already done it during the fork process. So this particular slide shows a continuation of the exec implementation. So the next thing is we continue to read from the inode. We read various things like the program headers and we begin to load code and data from the ELF image which is present on the hard disk into RAM, and consequently we are actually filling up the virtual address space corresponding to the code and data. So, this is done over here.

the basic idea is that, we are going to the hard disk looking into the inode corresponding to that particular executable and loading the code and the read only data into the physical memory map and we are also creating page table and page directory entries corresponding to that code and data. So, this is actually present, so therefore, you get this mapping present over here. The next step in the exec implementation is to create the stack for the user process. So, this stack as opposed to the kernel stack is used by the code for storing of local variables as well as for function calls. So, in order to create this stack, we rather the exec implementation allocates two contiguous pages. So, it one is used for the stack while the other one is used as a guard page. So the guard page is made inaccessible; essentially this is used to protect against stack overflows. So, what does it means is that as we keep using the stack, the stack size keeps increasing and it would eventually hit the guard page; and as a result, we would know that the stack overflow has occurred.

The next step in the exec implementation is to fill the user stack. So, essentially we have created the stack over here and now we are actually filling the stack. So we fill the stack with command line arguments. So, we know that any program that we write could take command line arguments and these arguments are actually filled into the stack. So, we have like command line argument 0 to N, followed by a null termination string and then we have pointers to these arguments like pointer to argument 0, pointer to argument 1, and so on. So these pointer to arguments, forms the argv of your program. So, you know that a main function takes argc and argv, so these pointers from the argv of your programs input and after these argv is the argc, which is the number of such parameters and followed by this, there is a dummy return location for main. Now, we have seen that we have actually created the code for the user process, we have the data for the user process and these two have actually been taken from the secondary storage device and loaded into physical RAM. And also a page directory and page table entries have been created thus we are able to see it in the virtual main memory map. And also we have created a stack for this user process and we have filled the stack with command line arguments, right creating the argc and argv. The only thing next to do is to actually start executing the process.

So this is done by filling the trapframe for this current process with elf entry. So, essentially the tf eip that is the instruction pointer in the trapframe is stored with elf dot entry, which essentially is a pointer to the main of the user program or main function of the user program. Similarly, the stack pointer is set to sp, so we are creating the trapframe esp is set to sp. Now when this particular exec system call returns to the user process, the trapframe gets restored into the registers as a result the eip gets the value of the main address while the stack pointer the esp gets the value of the user space stack and therefore, execution will start from the main program. The stack pointer will have the pointer to the various arguments for argc and argv, which will then be used in the main program. 