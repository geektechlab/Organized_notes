( didn't understand much, too theoratical )

In the previous video we had looked about Access Control Techniques, and in particular we had looked into the DAC or the Discretionary Access Control. So, we had seen that DAC is very efficient in giving certain access rights to a particular subject with respect to a set of objects. However, what we seen was the drawback of DAC was that it was incapable of preventing information flow.

So, in this video, what we are going to see is information flow techniques and the MAC that is the Mandatory Access Control. In Information Flow Policies, every object in the system is assigned to a particular security class. As such the system is divided into a fixed number of security classes and each security class is then given a particular category. For example you have a security class which is high, a security class which is low, and so on.

Now each object in the system is assigned to one of the security class. Similarly each subject in the system that is the entities which actually operate or access these objects they also are given a particular security class. Next we will define how information flows between the classes. Note that here about information flow, we are not concerned about how information about one object flows to another object or flows to a subject. But rather a concern is more about classes.

So, what we are going to see is that how information from one class flows to another class. So, formally this is represented by this following triple. So, this triple is a 3 triple, it contains the SC that is a security class. It has this arrow operator which shows the flow relation, and it has the join operator which is the join relation. So, an operator like this B arrow to A implies that information from B can flow to A. Similarly this example C arrow B to arrow A shows that information from C flows to B, and information from B flows to A. In other words information from C can also flow to A. Now based on this there is another technique of representing, which is by this particular symbol the greater than equal to symbol. So, what it means is that A dominates B and B dominates C.

Now, let us look at the join relation. So, essentially the join relation is used to determine how to label information, after information from 2 classes is combined. So, for instance, let us say we are creating a new object say a new file, and this file is for instance created by concatenating an object present in the security class C and an object in security class B. So now, the question that arises is to which class should the new file that we have just created be present in, should it be in security class C or security class B or in the A security class? So, in order to formally write this, the join operator is used. So, join is defined as a function between 2 classes. So, it takes the security class and another security class and it will actually give us what is the resulting security class. So, we will see and understand more about this with an example.

Now what we see is that for the system, these security classes are fixed. So, during the design time itself for instance we would say that our system has for instance just the security class A, B and C, also the flow operations is fixed at the design time itself. So, we can design various scenarios saying that information can flow to C and from C to B and from B to A and so on. So this is also a design time construct, also the join operation is fixed at design time. So, what changes over time is the position of the objects. For instance we may have object which is present in the security class A, and after a while this object becomes for instance less important or it becomes public domain and it can be moved to the security class C. To take an example from real life, what we see is that some top secret documents would be initially categorized as highly secure documents, but over a period of time this becomes public information and therefore, that particular document could then go to a lower security class.

So, you see that while the security classes are fixed as well as the flow of information is fixed among the security classes, the objects as such could move between security classes over a period of time. So let us take some examples about information flow. Let us start with a very trivial case, which also is the most secure example for information flow, essentially because it does not allow information flow between classes. So, let us take this example of a system where the security classes are defined by this particular set SC and it has ‘n’ security classes. Out of these the security class A1 is the lowest while security class An is the highest, then we need to define the flow operator in this case it is Ai flows to Ai. In other words what it means for every value from 1 to ‘n’, information can only flow within the class.

In other words, it is not possible for information to flow from one class to another class. The third requirement is to define the join operator. So, in this particular case it is quiet trivial to know that if you combine a particular information from one class with an other information from the same class, will result in a new object which also belongs to the same class. Now let us look at a less stringent example, which is less secure than the previous case, which allows information only to flow from the low to high and not anywhere else. So the security classes are defined as in the previous case. So, we had ‘n’ security classes and A1 is a lowest An is the highest and information can only flow from Aj to Ai where j is less than equal to i. So, what this means is that information can flow only from a lower class to a higher class, but the opposite direction from a high to low is not possible.

Also while defining the join operator that is when we take information from a low class and join combine it with information from a higher class, that is Ai with Aj we will get some new information which also belongs to the higher class that is the Ai class. So, to repeat that if we take some information from a low class and combine it with an information in a higher class for instance A2, then the new object that we create will also be in the A2 security class. Think of what would happen, if instead of Ai over here we had Aj. So, I leave that to you to think about. So now, let us come to the Mandatory Access Control Mechanism. So, essentially over here, the access mechanism or policies are based on regulations which are sent by a centralized authority. So, the most common form is the MLS or Multilevel Security policy.

Essentially in this policy we have several access classes like the unclassified, confidential, secret and top secret. So, every object in the system needs a particular classification level. So, every object could be classified as either one of these 4. Similarly every subject in the system also needs a clearance level. So, the clearance levels are also unclassified, confidential, secret and top secret, so one of these 4.

Now, a subject with clearance X can only access all objects in X and below X and not vice-versa, that is information can only flow upwards but cannot flow downwards. To take an example suppose we have a particular subject that is a user who has a clearance level secret, now what it means is that this particular user can access all the secret objects, all the objects which are classified as secret, all objects which are classified as confidential as well as unclassified, but this user will not be able to access any top secret objects. In other words information about from a top secret object cannot flow to a user with clearance secret, while the upward direction of information flow is possible. Now there are 2 types of MAC control techniques. And the first we will see is the Bell LaPadula model.

So, this was developed in 1974 and has is a formal model for access control. It gives four access modes read, write, append and execute. And it has 2 MAC properties that is No read up which is also known as the SS property or simple security property and No write down which is the star property. So, let us look at what these two properties are? So, what this means that is the No read up that is the first property what we seen here, is that if we have a user with clearance confidential then that user can read all the objects which are confidential as well as all the objects which are unclassified. In the sense she cannot read any object which is classified as secret and any object which is classified as top secret. So, this particular mechanism does not allow read up.

On the other hand the second policy’s states that there is no write down. In other words this particular user with clearance confidential is allow to write or modify an object which is classified has confidential as well as this user can modify objects of classified as secret as well as top secret. She is able to write upwards, but what is not possible is that she is not allowed to write downwards. So, she is not allowed to change or modify any object which is unclassified. Now this would seen very strange. So, let us see why such a mechanism was present. Essentially let us consider this particular scenario, where we have a process which is a confidential process with clearance confidential which is executing.

Therefore, as we know it could read data or read an object which is also classified as confidential. Now let us assume that there is a trojan host that is present. So, what we have seen is that when a trojan executes it’s going to inherit all the clearance levels of the process. So in this case the trojan is also going to get a clearance confidential. Now assume that write down was allowed, in such a case it will not be very difficult for the trojan to read at particular file or a particular object which is marked confidential and write it down to the unclassified, that is it could be made as a public domain information. So, you see that this causes a flow of information from high a confidential level to a low confidential level, essentially through that particular Trojan. Therefore, this particular model does not permit write down.

So, we look at the limitations of the Bell-LaPadula model, essentially what the Bell-LaPadula model does not prevent is that it allows a user with clearance confidential to write data upwards. So, this particular user with clearance confidential could essentially modify a particular top secret document or a secret document. In other words the BLP model does not address the integrity issues that are present. So, in order to cater to the integrity issues, there was another model which was used. So, this is the Biba model. So, Biba model is the Bell-LaPadula model upside down. So while, the Bell-LaPadula model just focuses on confidentiality and ensures that no information flows from a high to a low. The Biba model on the other hand ignores confidentiality all together and deals only with integrity. So, the main goal of the Biba model is to prevent unauthorized users from making modifications to a particular document. Also it prevents authorized users from making improper modifications in a document. So, this Biba model is incorporated in Microsoft windows vista operating system.

So, what the Biba model defines is that the user can first of all read and write to any object within the same security class, and the user could write to a object in a lower security class, and read from an object present in a higher security class. This particular object can be read, this particular object can be modified because it’s in a lower security class, this can be read because it’s in a higher security class, while objects in the same security class can be read and written. Please follow the arrows in this particular case. So, what it does not allow is that the lower security class be read from. Thus essentially a user cannot read from the lower security class and cannot write to a higher security class. So, you see this is exactly the opposite of what the Bell-LaPadula model tells us. So, the properties of the Biba model, is that there is no read down and no write up this is the star integrity theorem and while the no read down is a simple integrity theorem. So, with respect to the security classes this is the low integrity and this is the high integrity class.

So, why does the Biba model not support read down? Why cannot a user with a particular security class read from an object from a lower security class? So, why is this particular direction for information flow not permitted? The reasoning behind that is that a higher integrity object such as this one may be modified based on a lower integrity document. So for instance since, this particular user with a particular security class is capable of writing to this particular object present in the same security class. Now if she is able to read from a lower security class, and there is a flow of information upwards what it means is that she can then get influenced by this information or she can then copy this information on to this particular object in the higher security class. So, this means a lower integrity object is affecting a higher integrity object, and therefore the Biba model prevents such flow of information. So to take an example, let us say the hierarchy in the military where you have a general right on top, then the captains and the privates who are right at the bottom of the hierarchy. Now, the Biba model allows read up meaning a document which is prepared by the general should be read by all, that is a document which is created by the general should be read by the captain as well as the privates. However, no read down is permitted, that is a document written or modified by the privates at the lower end of the hierarchy should not affect the general’s decision.

So, we see that in spite of having such flow mechanisms, where information can be restricted in how they flow that is we can prevent information flow between security classes. However, due to various reasons and due to bugs or other flaws in the design, it may be possible for information to actually flow between security classes, in spite of having such robust measures like the access control measures that we just discussed. So, what we will do in the next video is that, we will look at such techniques where information can actually flow in spite of having such mechanisms in place. So, we will look at control flow hacking, essentially buffer overflows and how they could be used to allow an unauthorized user gaining information from a system.
