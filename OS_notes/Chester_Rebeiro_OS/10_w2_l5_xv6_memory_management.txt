We had seen in previous videos about memory management schemes in Processors and about Virtual Memory and Segmentation, and we also had seen about how memory is managed in x86 systems. In this video we will look at Memory Management in xv6. So, xv6 is an operating system which is targeted for x86 platforms, therefore the video corresponding to memory management in x86 processors would be important. So, we would be referring a lot of xv6 source code in this particular video, therefore for reference you could actually look at the xv6 source code booklet (revision 8) which it can be downloaded from this particular website.

Now, just to recall in an x86 system, there is two levels of memory translation. So the CPU puts out a Logical address which comprises of a Segmentation plus an offset. Then, there is a Segmentation unit which converts the Logical address into a Linear address and a Paging unit which converts a Linear address to the Physical address and only then the Physical memory or the RAM is actually accessed. To get a full view of this memory management in xv6, we had seen this particular diagram.

in particular, we had seen about the segmentation unit which is this part over here followed by the paging unit. We had seen especially in the segmentation unit that there is a segment selector, which is a register such as the stack segment, code segment, the DS, ES, FS segment and this particular segment would index into a table known as the GDT that is the Global Descriptor Table. And in this particular GDT is what is present the Segment Descriptor. The segment descriptor when combined with the offset will give you what is known as the Linear Address. So let us look more about how segmentation is handled in the xv6 operating system.

So, first of all we will look more into the segment descriptor. Each segment descriptor in an x86 system has 64 bits. So, these 64 bits can be viewed as 2 words of 32 bits each. The segment descriptor contains several attributes of the segment. Some of the important attributes are shown over here. So, one important attribute is the segment base or the base address of the segment. So, this base address comprises of 3 parts; it is of 32 bits and comprises of 3 parts, 16 bits over here, bits 16 to 23 over here, and bits 24 to 31 present over here.

The segment limit contains the limits of the segment. So, this is of 20 bits and is present in 2 parts. You have 16 lowest significant bits of the present over here while the 4 most significant bits present here. Another important attribute in the segment descriptor is the privilege level. The privilege level is of 2 bits and can have values from 0 to 3. So, user process’s which have the least privilege level are given a value of 3, while operating system code which has the highest privilege level has a value of 0. Another attribute in the segment descriptor is the Segment type. So, these could have 3 values STA_X that is executable, readable segment as well as writeable segment. In addition to this, you could actually combine these attributes for a particular segment. For instance, you could have a segment, which is executable as well as readable. So, you could specify that the segment has a type X as well as R.

So In xv6, this segment descriptor is represented by a structure in the operating system code. So, if you look at mmu dot h, you will actually see this particular structure. So, as you can see all the attributes in the segment descriptor are represented in this structure. For instance, the base address which is of 32 bits and split into 3 parts is also represented by 3 parts over here. You have 16 bits over here followed by 8 bits and the most significant 8 bits present over here. In addition to this, there is a macro in xv6 known as SEG which takes 4 parameters: type, base that is a base address, segment limit and the dpl. So, this macro is used to create a segment descriptor, it is a helper macro which is used to create a segment descriptor.

A typical usage of the SEG macro is as follows. So, this particular usage of SEG creates a segment which has a base address of 0, it has a limit of 2 power 32 minus 1 that is 0 x followed by 8 Fs. It is having a privilege level of user, specified by dpl underscore user and it is of type W - that is the segment is writeable. Xv6 does not make use of segmentation much, it only creates 4 segments. These are the Kernel code, Kernel data, User code and User data. All these segments have a base address of 0 and have a limit of 4 GB. All the code segments that is the Kernel code and the User code are of type executable and readable that is X, R over here as well as here. The data that is the Kernel data and the User data are of type writeable that is W, W. Now the Kernel code and Data have a DPL value of 0, which indicates the highest privilege level while the User code and Data have a DPL value of 3 indicating the lowest privilege level. Next we will see how these 4 segments are created in xv6.

So, when it comes to segmentation it is required to have a GDT, which is present in memory. So this particular declaration which is struct segdesc gdt which takes the number of segments is an array comprising the GDT. So If you look up line number 2308 of the kernel code, you will see this declaration. So, this particular memory array or this particular array is used to store the GDT table. So this particular array is filled by this these codes. So, we create the 4 segments as follows. So, we create the 4 segments has the Kernel code segment, the Kernel data segment, the User code segment and the User data segment. So, these segments are created according to the rules we have seen over here.

Finally, we need to have the GDT register pointing to this particular GDT table, so that is done by this invocation of this particular function known as lgdt or load gdt. So, load gdt is a function present in line number 512; and essentially it takes two parameters, it takes a pointer to the segment descriptor which essentially is the pointer to this GDT table and the size of the GDT table which we have passed over here as size of c gdt that is the size of this GDT table. And, essentially it just going to invoke this particular instruction call lgdt, which fills the GDT pointer in the mmu with the address of the gdt.

Next we will move on from segmentation to the paging unit that is how the virtual memory is managed in the xv6 operating systems. As we seen before in x86 systems, virtual address sync is actually managed by two levels of page directories. As a result, the linear address or the virtual address is split into 3 parts; you have a directory entry which comprises of 10 bits, a table entry comprising of 10 bits, and an offset comprising of 12 bits. The directory entry is used, to index into a page directory table which is present in memory.

In x86 systems, this page directory is pointed to by a register known as the CR 3 register. Now, the contents of the page directory entry is then used to point to a page table. So that the second part of the linear address that is a table index is then used to offset into the page table to get the page corresponding page table entry then the contents of the page table is then added to the offset to get the corresponding physical address.

Now, we will see how this virtual addressing scheme is managed in xv6? As the xv6 begins to boot, the operating system Kernel code and Data gets copied into the lower regions of RAM as shown in this pink shaded region. As the OS continues to boot page directories and page tables are created such that the entire RAM gets mapped into the higher region of the logical address space that is the 0th location of RAM gets mapped into what is defined as the KERNBASE that is 0x80000000. Similarly, every address in this RAM would have an identically mapped address in the logical space.

Why is such one to one mapping created between the logical address space for the Kernel and the physical RAM? The reason is that, which such a map the kernel could easily convert from virtual from a virtual address to the corresponding physical address that is given any virtual address in the kernel space that is some over here. The operating system or the kernel could easily obtain the corresponding physical address using a macro known as the V2P or the virtual to physical memory conversion macro. Similarly, in order to convert from a physical address to the corresponding virtual address would be very simple. So, any read any physical address in the RAM could be converted to the corresponding logical address or the corresponding virtual address by a macro known as the physical to virtual memory macro is shortened as P2V. So the important thing during these in these two macros is this KERNBASE.

So let us see these two macros in more detail. So, if you look at these two macros, this is present in the line number 212 in the kernel source code that the macro P2V simply takes an address ‘a’ - which is a physical address and converts it to the virtual address by adding a KERNBASE. Similarly, the macro V2P takes a virtual address ‘a’, and converts it to a physical address by subtracting the KERNBASE. So, as you can see converting from virtual to physical and vice versa that is from physical to virtual becomes very simple from the operating system perspective. Now let us see in more detail how the xv6 operating system creates the mapping between physical address and the logical address space. So, this particular figure here shows the physical RAM. So, as you can see the physical RAM is divided into several regions. The region from 0 to 640K is known as the base memory; the region from 640K to 1 MB that is 1 followed by five 0s is known as the I/O space. While the region from 1 MB to phystop - p h y s stop is the extended memory. Now this phystop is defined as a macro, which signifies the maximum amount of RAM present in the system. So, it could be something like 2 GB, 4 GB or 16 GB and could vary from system to system. So the region above this which extends up to 4 G is used by memory mapped devices. Now, in order to create mappings for this particular physical RAM, the operating system would create page directories and page tables.

So, in order to create this mapping, the operating system code defines several macros. So, some of the important ones are shown over here. So, we have already seen about KERNBASE which is defined to be equal to 0x8 followed by seven 0s and there are other macros such as the KERNLINK, PHYSTOP and EXTMEM. Now the KERNBASE determines the virtual address at which the kernel’s space starts. So, if you actually look at this logical address space, you will see that the KERNBASE is defined at this particular location. The region of memory below this location is user space and this is the region where user processes execute; while the region above this KERNBASE that is from here up to the maximum of 4 Gigs is where the operating system is present as well as where it manages memory and interacts with devices.

Now, another important macro is the KERNLINK, which is the KERNBASE plus 1 MB. So, as you see over here this particular point, which is KERNBASE plus 1 MB denotes the KERNLINK. So, this location is important because it is the location where the Kernel code and Data are present. So, starting at the KERNLINK, there is the Kernel text that is a Kernel code; and after the Kernel code is done, the locations comprise of the kernel data that is the global data which is present in the xv6 operating system. The end of the Kernel code and data is specified by this symbol ‘end’. The region from end to this particular location 0xFE followed by six 0s is the free memory. This particular free memory is use for various things in the operating system such as for the OS heap as well as for allocating pages for user processes.

Now in order to create a map of this kernel space into the physical RAM a structure known as kmap is defined. So the kmap structure which is present in the line number 1823 contains four elements. So, it has the virt - v i r t, which is a pointer to the virtual address. Then it has the physical start address which indicates the physical address which gets mapped to the virtual address and the physical end that is the end of that region, and of course, there is the permissions. So, xv6 defines four such regions. So, we have the I/O space, the Kernel text and read only data, the Kernel data and memory regions and the device space. So, these four regions can be actually mapped into this particular kernel space.

For example, the I/O space which starts from the virtual address KERNBASE and gets mapped to the physical address 0 up to EXT EXTMEM. So, this is the 1 MB region starting from 0 to the end of the I/O space that is the 1 MB mag. So, this is known as the I/O space and is typically not used by the xv6 operating system. The region KERNLINK onwards is used to store the kern text plus rodata that is Kernel code and read only data. So, this region gets mapped from the start of the extended memory in the sense that KERNLINK which is this particular location over here present by this line gets mapped into the extended memory. So, it is at the start of the extended memory that contains the Kernel code and read only data in physical RAM. Then we have a region known as the data region which gets mapped into the free memory part so over here, and finally, you have the device spaces which is above this particular location 0xFE 6 0s.

Let us see the sequence of steps that is involved in creating the mapping between the xv6 kernel space to the RAM. So, these are the four steps involved. First, there is a Enable paging. So, by default when the system is turned on paging is disabled. So, in order to turn on paging, a particular bit known as the paging enable bit which is present in the CR0 register has to be set to 1. So the CR0 register is a specific register in the x86 processor and in that register there is a bit called the paging enable bit which needs to be set to 1 to enable paging.

Another step is to create the page directories and the page tables. In order to create and fill the page directories, the function walk page directory or walkpgdir is invoked by the operating system. So, this if you look up the source code, you will see this walkpgdir function present in line number 1754. The walk page directory function creates the page table entry corresponding to a virtual address. So, essentially it is going to create an entry in this particular page directory. Secondly, if it finds that the corresponding page table entry in the page directory is not present then it creates in RAM a page table for it. So, this page table as we have seen will be of 1 page that is of 4 kilo bytes. So, we have seen that there are 1024 entries and each entry is of 32 bits. So, in all this page table will be of 4 KB that that is it will it will hold one page.

In a similar way, other page tables are created whenever required. So, this particular function use a several macro such as the PDX macro which given the virtual address will extract the page directory index that is it is going to just give you this upper 10 bits of the linear address. Then we have the page table entry address which will give the page directory entry and the PTX macro which takes the virtual address and gives you the page table entry. After creating the page directory, the next step is to fill in the page tables. So, this is done by the map page which is present in line number 1779 of the xv6 source code. So, what the map pages does is that it is going to fill this particular page table with the mapping from the virtual address to physical address. So, this particular table entries contain as we have seen the physical address mapping, permissions and also present bit. So, as we have seen that an entry in the page table is then used along with the offset to create the corresponding physical address. So, once we have created the page directories and the page tables, the final step is to load the CR3 register. The CR3 register is another register in the x86 processor which contains the pointer to the page directory. So in other sense we have this CR3 register over here, which is present in the processor of the MMU and it points to the memory location of the page directory. So now that we have seen how the xv6 code enables paging creates page directories as well as page tables. Let us see how the xv6 operating system allocates memory for various purposes. So, these purposes could be from allocating pages for user processes or for the operating system its use itself. We had seen that the xv6 code and read only data gets loaded in the 0th location of RAM and extends upwards. At the end of the code and read only data up to PHYSTOP that is the physical end of the RAM is the free memory. This free memory is utilize by the OS for several purposes such as for allocating pages to user processes or for internal operating system book keeping requirements. So, what we will see now is how this free memory is managed by the operating system.

So essentially this free memory could be a large junk and it is split into pages of 4 kilo byte granularity. Thus we would have several pages present in this particular free memory region. Now, whenever required that is on demand a page would be allocated to a particular calling function and used for it is requirements. So, after the usage the particular page is freed.

Now, the next thing that we will we need to think about is how the operating system or that is how the xv6 OS determines which page to be allocated and how the pages should be freed? In order to do this the xv6 code maintains a link list of free pages. So, as you can see here, this particular figure has pages which are either blue or yellow. So, this entire region corresponds to the free memory region in the RAM, the blue region are the pages which is utilized by either a user process or by the operating system itself while the yellow pages are the once which are free.

Now, all the free pages are linked together using a link list which is pointed to by a pointer known as the freelist. So the freelist points to the head of the link list and all the free pages are linked together with this list. Now in order to allocate a page the kalloc function is utilized. The kalloc function would essentially remove a free page from the list and assign that page to be used. In order to free a page the kfree function is used; essentially the kfree function would add the free page back into the list.

So the link list is as shown over here where you have the freelist pointer which points to the head of the list and then there are pointers to the consecutive free pages. Now, one thing which is different from the standard link list is that there is no exclusive memory to store the pointer to the next page. Note that each of these pages is of 4 kilo bytes and this 4 kilo byte free pages is not used for any other data thus the 0th location in this page contains the pointer to the next page.

In a similar way, the 0th location in this page would contain the pointer to the next page and so on. Thus we are creating this list. So the freelist points to the first or the head node of the list and then the 0th location of that node points to the consecutive page and so on until we reach the end of the list. So, with that we come to the end of how xv6 manages memory. So, it is not the best management scheme that is possible, but it is a representative of what several operating systems actually do to manage memory. 