In this particular video we will look at Hardware Solutions to Solve the Critical Section Problem. So in the previous video we had looked at Software Solutions to Solve the Critical Section Problem. However, in practise these solutions are not very efficient. So in practise both in the operating system as well as in applications, hardware techniques are used to efficiently solve the critical section problem. So we will start this video with the small motivating example.

let us start with this particular example. Let us say we have the two processes; process 1 and process 2 and both are having a similar critical section that accesses the same shared data. And also let us say that we have this shared variable call lock, so this variable is shared between process 1 and process 2. Now what each of these processes do is two things; first in order to lock the critical section, the process would first execute this while loop until lock becomes 0. When lock becomes 0 then the process would enter here and set lock to 1 and then execute the critical section. At the end of the critical section the process would set lock to 0 in order to unlock the section.

The question that I would post over here is; does this particular scheme achieve mutual exclusion? The answer is no. Essentially we have seen such things in the previous video as well. Due to context switching between the two processes we would reach a state some times when both processes execute in the critical section. Thus, we will not be able to achieve mutual exclusion. So, for instance if we actually look at this, we see that lock has an initial value of 0. Then suppose process P1 executes in the CPU, and it executes while lock not equal to 0 and since, we have lock as 0 over here, so this particular while loop will break, however we have a context switch that occurs before the process could set lock equal to 1. Now, this context switch results in process P2 executing. Now P2 will also see the value of lock equal to 0, and therefore break from this while loop and then set lock to 1. Now again if there is a context switch occurring and process P1 will continue to execute from where it stopped, it will see the old value of lock which is 0 because, the context is returned back to the old value of the process before the context switch occurred. And therefore, process P1 would see the value of lock as 0. And therefore, it would set lock equal to 1 and enter into the critical section. Thus we have reached the state where both processes are in the critical section.

Now, the main reason that this particular scheme failed was that as we have written this in software, we were unable to make these two statements atomic. That is, we are unable to ensure that a context switches do not occur in between these two statements. Said another way, we are unable to make these two statements execute as a single unit. And thus, due to this reason we were unable to achieve mutual exclusion.

Now most processors such as the x86 Intel processors have dedicated instructions that will ensure that these statements are executed atomically. Let us take an example of such an atomic instructions through which we could implement this set of statements (refer above slide image) in an atomic manner. So we will take a very general instruction first and then analyse specifically for the Intel x86 type of processors. The first instruction that we would see today is the Test and Set Instruction. Essentially if we were to write this instruction in C, it would look something like this. It is a function which takes a pointer to a memory location. So in this function first the contents of that memory location is stored into this variable called previous, then that memory is set to 1 and the value returned is the previous value. In other words this function would return the previous contents of the memory and set that memory to a value of 1.

Now, when we look at this from a hardware perspective and essentially from the processor perspective, this entire function is an atomic function. Essentially we would have one instruction that would do all of this thing in one shot that is, we would have one instruction that would perform all of these operations atomically. So let us look at this particular diagram to demonstrate how this thing actually works. So let us say that we have the processor and the memory location pointed to by L is over here. So, what would happen when this test and set gets executed, is the following; first the previous contents of the memory get loaded into a register present in the processor and then the memory contents is set to 1.

So let us look at it another time; first the memory contents pointed to by L is loaded into a register present in the processor and then the contents of that memory location is set to 1. Now, the atomicity of the test and set instruction can be defined or explained as this statement here which stats that, if two CPU's execute test and set at exactly the same time, the hardware or that is a processor ensures that one test and set for one of these processors does both its operations. That is, reading contents of the memory to a register and setting that particular memory location, so both these steps are done before the other process starts executing. In other words, it is not possible for two processes to execute the test and set instruction and both processes read the previous value of the memory location.

So, essentially this thing is wrong, is not correct. That is it is not possible for both processes to simultaneously read the contents of the memory location and set the value of memory. However, what actually is guaranteed by the processor hardware is that when processes run on each processor and both processes execute the test and set instruction at exactly the same time, the hardware will ensure that one process completes its entire instruction before the next process could execute its instruction. Therefore, in such a case one process would read the value of 0 while the other process would read the value of 1.

Now we will see how this particular instruction is used to solve the critical section problem. So this particular snippet over here shows how a process could use the test and set atomic instruction which hardware supports in order to solve the critical section problem. Essentially, in order to lock the critical section we would have a while loop present over here which would invoke the test and set with a lock, that is with the memory location. Now, this while loop will execute continuously until the value returned by the test and set is 0; So when the value returned by test and set instruction is 0 then critical section is entered and at the end of this the value of lock is set to 0. When there are multiple processes having such a code snippet, the hardware guarantees that the test and set for exactly one process would return a value of 0.

All other processes will loop continuously in this particular while loop. So when this process has completed executing the critical section, the value of lock would be set to 0. So, setting the value of lock to 0 would result in exactly one other process to obtain a value of 0 from the return of the test and set. Therefore, exactly one other process would then enter into the critical section. So the first invocation of the test and set will read a 0 and set the lock to 1 and return. The second test and set innovation will then see the lock value as 1 and will loop continuously until the lock become 0. The value of the lock becomes 0 only when the first process unlocks it that is exclusively sets the value of lock to 0. So in this way we see that by a little help from the hardware it is feasible to solve critical section problem very efficiently. So, Intel systems do not support the test and set instruction.

On the other hand it supports an instruction known as exchange; xchg. So an xchg instruction is represent over here and this is also an atomic instruction and the xchg instruction takes two parameters, so it takes a memory address and an integer value. Now what is done is that the contents of that memory location is stored in previous, then the value of v that is the value which is passed to xchg is then stored into that memory location and the previous value is returned. So, essentially what this achieves is that we are able to xchg register variable with a memory location. To take an example, so look at this when once an xchg instruction is executed by a process running in this processor, it will exchange a register value with that of a memory location and this entire thing is done atomically. So even if another process executes the xchg at exactly the same time, the Intel hardware ensures that these two operations are done distinctively.

So, first one process would execute and complete the xchg instruction and only then the second process would execute and exchange the data. So this particular slide shows how an xchg instruction in an Intel hardware is used to solve the critical section problem. We could have two primitive functions called Acquire and Release. So the acquire is used to lock a critical section, while a release is used to unlock a critical section. So this, acquire and release functions are passed a pointer to a memory location known as Locked. So in acquire in an infinite rather in acquire in a loop, this function xchg locked is invoked. So, xchg is present over here and it is passed two parameters; the address of the memory location in this case the address of locked and the value which you want to set. So first the value in this case one is moved into the eax register in the Intel processor and then the xchg instruction is invoked. As a result the memory or the data which was stored in memory gets loaded into the eax register. And the value in this case one which was loaded into the eax register gets stored into memory. Now this particular eax register is what is returned back to acquire. So this loop would break if the value returned by xchg that is the contents of the eax register is 0. In order to release the lock, we simply set the locked value to 0.

Let us see how it works. So first, the memory location over here would be 0 and when the process invokes xchg instruction that 0 value is pushed into the eax register, and the value of 1 which was present in the eax register comes into the memory. As a result, the memory has a value of 1 while the eax register present in the processor has a value of 0 and this is what is used to break from this while loop and enter into the critical section. Now in order to release the lock, we have simply setting the value of locked to 0. Now when a second process invokes acquire, it will continue to loop in this while loop until the value of this memory location is set to 0 by the first processor. We see over here, so in order to release lock we simply set the value in memory to 0 and then in another processor perhaps would be able to obtain the value of 0 and then acquire the critical section. So this instruction like the xchg is used to build higher level constructs which are used in various critical section problems. So, we will look at Spinlock, and Mutex in this video and Semaphore in a later video. So Spinlock is what we have seen before, it has two functions acquire and release. While the acquire is used to gain access to the critical section essentially it is used to lock the critical section, while the release function is used to unlock the critical section. So in order to use this we could have two processes; process 1 and process 2. In order to enter into the critical section the process has to acquire the lock and this function acquire will continuously loop until the value return by xchg is 0. So when the value of xchg is 0 then this loop breaks and the process 1 would enter into the critical section. Releasing the lock is just done by setting the value of locked to 0. So, one process will acquire the lock at a given time while the other process will wait in this particular loop and continuously invoke the xchg function until it obtains 0. So the first process in order to release the lock would have set the value to 0, this would cause the second process to break from this loop and enter into the critical section.

So you could see more details about the way spinlocks are implemented in xv6 by looking into these two files that is spinlock dot c and spinlock dot h. We will now look at some of the issues that go about with the use of the xchg instruction. So as we have seen the xchg instruction is the most crucial part of any of the constructs such as the Spinlocks that we have seen in the previous slide. So therefore, it’s important to understand what are the issues related to the xchg instruction. Essentially this particular format of the xchg instruction, exchanges data between a register eax and a memory location X. Now it should be ensured that there are no complier optimization that are done on this variable X. So, some of the common optimization that are possible is to make the value of X stored in a register.

In such a case, we are simply exchanging data between a register eax and an other register which will not solve the purpose. Therefore, we should write this particular loop in assembly or use the keyword volatile. Another requirement while implementing the xchg instruction is to ensure that memory operations are not reordered. The CPU should not reorder memory loads and stores. So in order to achieve this we use serialized instructions, which force instruction not to be reordered. So luckily for us the xchg instruction by default already implements serialization. So there is nothing much we need to take care about this.

However, what we need to look at more closely is the fact of cache memories. Now, recollect that xchg instruction exchanges data between a register and a memory location. Now each CPU present in the system could have their own private cache, for instance CPU 0 has its own private L 1 cache; similarly CPU 1 has its own L 1 cache. So it should be ensured that this value of X is not a cached in each of these CPU's, essentially caching of CPUs is not possible. But rather, each and every execution of this xchg instruction should actually go to memory and load or store the value of X.

Secondly it should also ensure that when one CPU is reading and writing to this X, that is in other words when one CPU is invoking the xchg instruction during this time no other CPU can modify the value of X, as this will break the atomic nature that is present. In order to do this the CPU asserts what is known as a lock line to inform all other CPU's in the system that there is locked memory access that is going to take place. So as a result of this lock instruction, all xchg instruction which read and write data would result in the reading and the writing data from a memory. So, this may be tremendous amounts of performance hits. Therefore, in order to make a better acquire, an acquire which is more efficient we will look at a small tweak to this particular acquire function. So originally, we use to have a loop over here and in this loop we would continuously keep invoking the xchg function and checking whether it returns a value of 0. So note that, each of these xchg instructions has a huge performance overhead because it requires that the locked keyword that is the X value would go all the way to the memory and read and write data from the memory. Essentially, the caching is not possible and therefore huge overheads.

On the other hand if we make a minor change to this acquire function as shown over here it would improve performance quite significantly. So here we have two loops one is the regular xchg loop which as you know would result in a bus transaction and has huge overheads, while does an inner loop which simply loops checking the value of the memory location locked. So this particular internal thing can is cacheable and therefore, will not incur much performance overhead, while, the external while loop will have significant overheads, but it’s not invoke too often. Most of the time this particular cached memory would be read.

Now the cache coherency protocol will ensure that when another process changes the value of locked, this process would see the value of locked changing from 1 to 0 and it will exit the while loop and go back to this particular outside while loop. The xchg function would then exchange the locked value with the register value and set the value to 1, and therefore break from the while loop.
