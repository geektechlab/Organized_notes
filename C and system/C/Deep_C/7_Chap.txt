Some programs don't need to manage their dynamic memory use; they simply allocate what they need, 
and never worry about freeing it. This class includes compilers and other programs that run for a fixed 
or bounded period of time and then terminate. When such a program finishes, it automatically 
relinquishes all its memory, and there is little need to spend time giving up each byte as soon as it will 
no longer be used.

( overall content is good for refreshing system concepts, but not in much detail )

The segmentation fault or violation should already be clear, given the segment model explained earlier. 
On Sun hardware, segmentation faults are generated by an exception in the memory management unit 
(the hardware responsible for supporting virtual memory). The usual cause is dereferencing (looking 
at the contents of the address contained in) a pointer with an uninitialized or illegal value. The pointer 
causes a memory reference to a segment that is not part of your address space, and the operating 
system steps in. A small program that will cause a segmentation fault is:
int *p=0; 
*p = 17; /* causes a segmentation fault */ 
One subtlety is that it is usually a different programmatic error that led to the pointer having an invalid 
value. Unlike a bus error, a segmentation fault will therefore be the indirect symptom rather than the 
cause of the fault.

Common immediate causes of segmentation fault:
• dereferencing a pointer that doesn't contain a valid value 
• dereferencing a null pointer (often because the null pointer was returned from a system 
routine, and used without checking) 
• accessing something without the correct permission—for example, attempting to store a value 
into a read-only text segment would cause this error 
• running out of stack or heap space (virtual memory is huge but not infinite) 

free(p); p = NULL; 
This ensures that if you do use a pointer after you have freed it, at least the program 
core dumps at once. 

Overwriting errors: writing past either end of an array, writing past either end of a 
malloc'd block, or overwriting some of the heap management structures (this is all too 
easy to do by writing before the beginning of a malloc'd block). 
p=malloc(256); p[-1]=0; p[256]=0; 

Free'ing errors: freeing the same block twice, freeing something that you didn't 
malloc, freeing some memory that is still in use, or freeing an invalid pointer. A very 
common free error is to cdr [3] down a linked list in a for (p=start; p; p=p-
>next) loop, then in the loop body do a free(p).
