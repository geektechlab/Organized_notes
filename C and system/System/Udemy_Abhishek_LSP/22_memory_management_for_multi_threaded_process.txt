we will going to focus especially on multithreaded processes. We will learn that how stack or heap memory management is done in case if our process is a multithreaded process.

So far we have considered only single threaded process for all the discussions we have so far regarding memory management. So a process can give birth to multiple threads. Threads in turn can generate more threads, so threads share almost everything amongst each other as well as with the parent process.

So these are the things which the threads share with each other as well as with the parent process. That is the code segment. In a process, virtual address space is shared among all the threads which has been created by the process. When I say share, it means that physical pages into which this code segment is Encoded are actually shared among all the threads which are generated by the process. Here, sharing means that there will be exactly one copy of physical pages which belongs to the code segment of a process.

Similarly, the data segment, which is both initialized and uninitialized portion of data segment in virtual address space of a process is also shared by all the threads that is generated by the process. If the process has certain file descriptors, such as the process has opened, certain sockets or message queues or various other kernel resources. Then as soon as the process creates threads. Threads will have an access to all these file descriptors. It means that these open file descriptors are also shared by all the threads that is created by a process.

And most important among all of these is the heap memory. We already know that if a process generates a thread, a thread can access all the data structures which is residing in the heap memory of the process. In fact, if a thread modify any data structure which is present in the heap memory, that modification is visible to the process also as well as other threads of a process. So it means that the physical page is corresponding to the heap Memory is also shared by all the threads of a process.

But there is one thing that is not shared between threads of a process, and that is the stack memory. Every thread or a process has its own private stack memory. Every thread has its own exclusive private stack memory. We will see how stack memory is managed by the operating system in multithreaded environment.

So each thread has its own execution flow which is independent of other threads. Hence it is required that they have a separate stack memory. Because we know that it is the stack memory which is responsible for program execution. That is, it is the stack memory which supports procedure, call and returns. So because every thread has its own execution flow, it means that every thread needs its own private stack memory.

Because thread shares many things among themselves and we have already listed that these are the things which are shared by all the threads of a process. So kernel operating system don't have to work too hard in order to create or destroy threads because most of the kernel resources which the new thread requires has already been created by the parent process.

So that is why, because the creation and destruction of the thread is a lightweighted operation. Therefore, threads are also called as lightweighted process.

----------------152-------------------

after the thread creation, there will be no separate virtual memory for the newly created thread and all this virtual memory is still belong to the process P But this virtual memory is also shared by a newly created thread. A newly created thread has an equal access to this virtual memory, to this portion of virtual memory of a process.

operating system will allocate only new separate stack portion from virtual memory exclusively only for thread t because a thread needs to have a stack memory in order to execute stack memory of the process P, on the other hand, is preserved and is being used by the process P for its execution. So you can see that the entire process virtual address space is starting from here till the bottom of the process Virtual address space is shared by the process P as well as the thread T. So it is for this reason that a thread can also modify a heap memory of a process and those modification in the heap memory will be visible to other threads or parent process.

the only change that happens in the process Virtual address space of a process P is the allocation of new stack memory when a new thread is created. Other than that, there is absolutely no change in the process Virtual address space.

This continue for further thread creations also.

---------------153-------------------

After thread creation, the only difference that you can see is that in the second page table there are two additional entries corresponding to virtual page number 12 and virtual page number 13. Because these two virtual pages were assigned by the operating system to a process P to be used as a stack memory for the execution of a new thread.

So corresponding to these virtual pages, physical pages are created and loaded in some frame number in main memory. Other than that, there is no difference between the two page table snapshots.

a thread should not access virtual pages that belong to the stack memory of other threads or process. So it means that a newly created thread must not access any virtual address that belongs to the virtual page number 14 and 15. And similarly, a process P must not access any virtual address that belongs to the virtual page number 12 and 13. The reason being that stack memory is private to a process or a thread. Otherwise you can see that a thread or a process can access any virtual address that belongs to any valid virtual page number that is assigned to a process.

a newly created thread shares the same virtual memory as that of a parent process. There is absolutely no separate virtual memory that is created exclusively for a new thread. A new thread Access the same page table also. There is no new page table created for a new thread. Now let us suppose that a thread t performs some write operation at virtual address V where this virtual address V belongs to the heap segment or data segment of a process virtual address space. Now same changes are visible to any other thread or process. And the reason is that there is only one page table which is shared by all the threads and the parent process. So any modification that is made to the heap segment or data segment of a process, virtual address space, that modification will be visible to all other threads or process virtual pages, which belongs to new threads.

Stack memory are created upon creation of new thread and corresponding physical pages are created by the operating system and are loaded in some frame number in the main memory as per the page replacement algorithm.

New thread shares the same page table as that of a parent process P except new virtual pages to physical pages mapping that is created for new stack memory for a new thread.

when a new thread is created operating system create new virtual pages as well as new physical pages for the new thread.And the mapping between these two new virtual pages to physical pages is updated in the page table of a process.

-----------------154------------------

suppose the same new thread terminates its execution. The very first thing that happens is that that the virtual pages which corresponds to the stack memory of a thread, are freed.

virtual page number P two and virtual page number P 13 are the virtual pages which represents the stack memory of a thread. So these two virtual pages will be freed or deallocated by the operating system. Only physical pages which corresponds to the stack memory are freed. Now, since the virtual pages P, two and P 13 have been freed by the operating system, obviously the physical pages to which the virtual page number 12 and 13 mapped were also will also be freed by the operating system.

So the frame number in which the physical page number 12 and 13 were loaded will also be freed. And those frames of physical memory will be used to load physical pages that belongs to some other process or thread. So page table is updated to mark page table entries corresponding to virtual pages which are freed above as empty.

So you can see that this page table will be updated so that the entries corresponding to virtual page number 12 and 13 will be marked as empty because these virtual pages are no more assigned to a process to be used. So this is how operating system clean up the virtual memory as well as update the page table of a process when a thread terminates.
