main memory is a scarce resource for an operating system. The end goal of a page table is that that for a given virtual address, first locate the physical frame in the main memory. And once you locate the physical frame in the main memory, then locate the exact physical address within this frame in a main memory. So this is what the main objective of page table.

Multi-level paging Make use of multi-level page tables. So multi-level page tables is like a book with multi-level indexing of table of contents. The book says that, Hey, go to section number one and in this section number one, go to unit number three.

in multi-level paging each section unit chapter topic page number in turn are page tables and data item of our interest. That is topic of interest is the main memory frame number, which is the final data item to be located. So in multi-level paging, each of these level of indexing is implemented by a page table. So going forward, the main idea behind multi-level paging scheme is to break a large page table into smaller sizes and fit each individual smaller page table at dispersed location in main memory.

Since main memory itself is logically fragmented into frames of size page size, and we have assumed throughout the course that this page size is four kilobytes. So designers of the operating system choose page size as the optimal size into which large page size table must be fragmented. This would allow smaller, fragmented page tables to fully occupy the entire physical frame of main memory. So here we are fragmenting a large page table into smaller, smaller page table, and the size of each smaller page table itself is equal to the size of the frame number of a memory. So it means that after fragmentation of a large page table, each smaller page table can be fit into a physical frame of main memory.

Multi-level paging scheme take the shape of a tree like structure.

----------------146------------------

Suppose the virtual address size that is generated by the CPU is eight bits long. And let us suppose that the size of page is four byte. So it also means that the size of frame of a physical memory is also four bytes. Let us say that the total main memory that our system has is 64 bytes. So how many frames into which this main memory is divided into simply 64 divided by four is equal to 16 frames, Right. And let us assume that the size of each page table entry is just one byte.

So the size of total virtual address space of a process is 256 bytes. And frame size is equal to the page size, which is four bytes. Virtual address composition will going to be six plus two bits. Because the frame size is four bytes. It means that in one frame of main memory there are four physical addresses. Therefore, you need two bits in order to uniquely identify a physical address within a frame of a main memory. Therefore, virtual address composition needs to be splitted as six plus two bits because two is an offset within a frame.

Now in multi-level paging the size of the page table has to be equal to the size of a page, which is four bytes. So it is compulsory that in multi-level paging scheme, the size of the page table has been reduced and has been made fixed to the size of a page, which is four bytes. Now number of entries in a page table will going to be four. Because size of each entry of the page table is one byte, and the size of a page table is four bytes. So clearly, the number of entries in a page table will going to be four divided by one is equal to four.

Now, number of bits required to index into a single page table will going to be two because there are four entries in the page table. So you need two bits in order to index an entry into a page table. Now that you need two bits as an index into the page table, the six bits that is these six bits. These six bits are divided into three levels of indexing. The first two bit is used to index into the first level of page table. The next two bits is used to index into second level page table and the next two bits are used to index into third level page table. And physical address size is six bits.It is six bits because we have taken the size of the main memory as 64 bytes. So 2^6 is equal to 64.

So in our example we need to map eight bit virtual address to six bit physical address.

you can see that a CPU generates an eight bit virtual address and you can see that the last two bits of this virtual address are dedicated to be used as an offset, whereas the first six bits are used as an indexing into the page tables. The first six bits of these page tables in turn is divided into three sets of two bits each.

You can see seven page tables. This is a top level page table. And you can see that the number of entries in each of these page table is four. Now you can see that there is a number which is written against each page table in this slide. So this is actually the physical address in the main memory at which this page table is loaded.

So our very first objective that is split a large page table into smaller page table has been achieved and you can see that page tables can be loaded in any available frame number in main memory. So you can see that page tables are actually scattered throughout the main memory. There is no need to reserve one big chunk of physical memory in order to load all the page tables together. Now coming to the page table entry, you can see that second column of the page table actually stores the physical address. That is the address in the main memory at which the next level page table is stored.

( watch video for better understanding )

---------------147---------------

couldn't get transcript, write manually and watch video. Very important
