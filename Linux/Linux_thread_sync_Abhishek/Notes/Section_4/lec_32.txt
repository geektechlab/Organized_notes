( watch video to understand code example )

let us go through the program example, which shows the transfer of computation. we have entity one on the left hand side and we have entity two on the right hand side. Now, as we discussed in the previous lecture video, that entity one is the owner of two variables. That is A and B, right? Whereas Entity two is the owner of computation. The end goal is that that entity one wants to compute the multiplication of its two integers A and B, using the computation owned by the entity two and store the result in the local storage which is owned by the entity Two.

So this is analogous to like who owns two apples and you don't have a juice grinder, so you go to your neighbor and borrow a juice grinder from him and you extract the juice out of your apples using your neighbor's juice grinder. But the only difference is that that juice is not drunk by you, but it is your neighbor who eventually have a juice party. I hope so. This is not a stupid example.

Anyway, let's resume with our discussion now in order to compute the multiplication of these two integers, which is owned by entity one, that is thread one. The very first thing that needs to be done is that the entity two that is thread two is responsible to register its computation with the entity. One Now you can see that entity one here has a variable which denotes the function pointer. Function pointers are nothing, but they are pointers which stores the address of the functions. So you can see that the prototype of this function pointer is very simple. It accepts two integers and returns an integer. So the prototype of this function exactly matches with the prototype of this computation function, which is multiply function. as the step number one, it is the responsibility of the entity two which eventually wants to have an apple juice to register its computation function with the entity One.

Here, registration means that give the computation function to the entity one for use. So after step number one, this function pointer variable will have some address, let's say f e, d, which is the address of this function multiply. So step number one, accomplish the transfer of computation already after step number one entity one has successfully borrowed the computation from the entity. Two Now in the second step, the entity one has the responsibility to generate the data on which the computation needs to be done right. So data generating steps involves simply initializing the values of A and B right. It is quite obvious that in order to multiply two numbers, you need two numbers. In other words, in order to perform computation, you need input. And once the data is generated by the entity, one entity, one then is responsible to use the computation which it has borrowed from the thread. Two in order to actually perform the multiplication the function multiply which is present on the entity one is nothing, but it simply invokes the borrowed computation from the entity two Right. So this function pointer invokes this particular multiply function with the inputs A and B. And you can see that this multiply function computes the multiplication of two integers and store the result in the local storage which is owned by entity two.

So the model of transfer of computation that we discussed in the previous lecture video is exactly mapped to this programming example. So the step number four involves storing the results in the local storage of the entity. Two So the some points here to be noted is that that there is no flow of data in this whole computation. The data A and B was never copied from one memory location to another, right? So there is absolutely no flow of data. And this model of communication is usually a unidirectional communication, right? With this model of communication, it is the local storage of the entity two, which gets eventually populated with the result. Right. So the computation is done by the entity one, but eventually the results are available in the local storage of the entity Two.

Entity two is your neighbor, which eventually have all the apple juice. And if you look at this example and think about it, the actual multiplier function that is this function is owned by entity two, but it is executed by entity one, right? Why it is executed by entity one through a function pointer. So this was transfer of computation model or in other words, this is how function pointers are used to implement the transfer of computation. We will going to do a short assignment as an exercise to implement transfer of computation or to see that how function pointers can be used to set up the communication between the two threads of the same process.
