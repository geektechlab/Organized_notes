now let us try to understand the concept of transfer of data and transfer of computation and what is the difference between them. So in case of transfer of data, let us suppose that we have two entities the entity one and the entity two. The entity one and entity could be the two threads. There could be the two process. There could be the two process running on the same machine or different machine. Entity one and entity two are just two bodies which wants to communicate with each other.

Now let us suppose that entity one owns two integers, let us say an integer A and integer B, whereas Entity two owns the computation part. That is entity two knows how to multiply two numbers. Let us assume that entity one does not know how to multiply two numbers and it relies on the entity two to compute two numbers. Also, let us assume that entity two has a local storage in which it can store the result which it obtains after multiplying the two numbers. So C is the memory location, which is a local storage of the entity. Two So on whichever machine the entity two is running C is a local storage of that machine. Now let us suppose that we need to compute the multiplication of two numbers A and B. So it is quite obvious that entity one has to send these two numbers to somebody who can multiply, So it means that there should be a transfer of data from entity one to entity two. Once the entity two receives the values of A and B, it can do the computation on A and B and whatever final results it obtains, it can store this result to its local storage right. So you can see there is a transfer of data from entity one to entity two, and the computation is stationary, which is present on entity two side only.

Now let us understand what is transfer of computation. In fact, the transfer of computation is exactly opposite to the transfer of data. So in this case also we have two entities and one entity owns the data and the other entity owns the computation. Now the end goal is same. That is, the multiplication of these two numbers need to be stored in the local storage of the entity Two's memory. But in this case, instead of sending the values of A and B from an entity, one to entity to entity two itself chooses to send the computation to the entity one. That is, it is the function which is being sent from entity two to entity one. And once the entity one receives this computation logic. It can feed its data members as an argument to this computation logic and whatever result is produced, this result can be stored in the local storage, which is owned by the entity too.

Now you must be saying that there is a transfer of data, right? The result Si is being sent from entity one to entity two. So no, actually there is no transfer of data because here we have a constraint that entity one and entity two must reside in the same virtual address space. That is entity one must have an access to the local storage of the entity two and entity two must have an access to the local storage of the entity One. So transfer of computation is feasible only when entity one and two are in the same virtual address space.

And now we already know what are the two entities who lives in the same virtual address space that is threads. So it simply means that transfer of computation is possible only when entity one and entity two are the two threads of the same process. They live in the same virtual address space of a process. So it simply means that the result Si is being stored by entity one into the memory location. Si which is owned by entity two without any transfer of data. The address of this Si memory location is accessible to the entity one also. So it can directly write the result into this memory location. So in a nutshell, if you were to summarize what is transfer of computation, Transfer of computation is nothing, but it is just a function call through a pointer. So many of you must already be knowing that what is a function pointer and how does this work? function pointer is actually an example of transfer of computation.

Transfer of computation can also be implemented in different ways, not necessarily through function pointers, but that is the topic of some other course I guess.
