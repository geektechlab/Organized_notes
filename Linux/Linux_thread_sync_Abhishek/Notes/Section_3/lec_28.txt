a MapReduce is nothing, but it is a programming model which is based on divide and conquer paradigm. With the help of an example, let us suppose that you have a text file and the text file could be a very large. But for our example, let us suppose that this text file has 1200 lines. 1200 lines of text. And our problem statement is that we need to count the number of words in this text file. Now, the question is pretty much simple and straightforward, and you will argue that why not write a simple program that will scan all the lines of this text files and simply count the number of words in the text file? Well, you can always do so. But our problem statement is to solve this problem using the concept of MapReduce. When you will implement a MapReduce, then basically you will end up practicing the concept of joinable and detached threads.

So once we get familiar with the MapReduce, I will discuss what is the practical implications and use of the MapReduce paradigm. So now let us first understand what MapReduce is. So our problem statement was that to count the number of words in this text file, right? So now let us discuss that, how MapReduce programming model can solve this problem for us. So let us suppose that we have a main thread or let us call it as moderator thread. So we have a process. P and one of the threads in the process is called a moderator thread, right? Now the responsibility of the moderator thread is to split a big work into smaller chunks and then allocate those smaller chunks of work to individual worker threads. Right. So as I said, worker threads, it means that it is the moderator thread responsibility to create more threads which are called worker threads. So you can see that moderator threads has not only created worker threads but also assigned work to them. Right? We had a text file of 1200 lines and moderator threads has splitted up work and every worker thread has now been assigned a fixed range of number of lines of the text file which each of these worker threads needs to work with. For example, the worker thread W1 has been assigned number of lines ranging from 0 to 399. The worker thread has to scan only these many number of lines and count the number of words in these lines. Similarly, worker thread W2 has to count the line from 400 to 700in the text file and it has to count the number of words in between these lines only. Right? Similarly, worker thread is also assigned the responsibility to count the number of words in a text file from line number 800 to. 1199. Right?

So you can see that the moderator thread has splitted up a bigger chunk of work into smaller individual chunks of work, and each work has been assigned to a separate worker thread. Right. So now in MapReduce terminology, the worker threads are called mappers, right? And mappers work on Non-shared data independently, right? So here the text file is same, but the number of lines which are present in this text file have been shared among worker threads in a non disjoint manner. Right. So it simply means that each of the mapper thread has been assigned a work to be accomplished. And these works are non-overlapping with each other, right? They are independent works. Now, once the moderator thread assigns the responsibility to each of the worker threads, the moderator threads has to wait for the worker threads to finish their job and provide result. So it simply means that worker thread has to wait until all the worker threads finish their work and return the result. So it simply means that the moderator threads has to invoke p thread, join function and wait for each of the worker threads to finish their work and return their respective results. Right. So it simply means that the moderator threads will block at the first join point.

So the thread who waits for all workers to finish their work is called reducer thread. So in MapReduce terminology, the thread which is waiting for the worker threads to finish their work is called a reducer thread. So in our example, the moderator thread is also a reducer thread, but it is not compulsory. A moderator thread could be different than a reducer thread. Right. Now let us suppose that each of the worker threads that is W1, W2 and W3 have finished their work and as a result they join the moderator thread. Right? When they join the moderator thread back after finishing their work, they join the worker thread with their respective results. Right. So let us suppose that the worker thread W1 has returned its result in this variable that is S1. The worker thread W2 and W3 has also returned the result in the variable S2 and S3. Right. Now, once all the worker threads have joined the reducer thread, then it means that the moderator thread or reducer thread can now resume its computation beyond all the join points. Right. So in this example, let us suppose that the worker thread w one has computed that the number of words in the text file in between the line 0 to 399 is X, and similarly the worker thread w two is returning y and the worker thread w three is returning Z. Right. So X, Y, and Z are the values which is being returned by the worker threads to the moderator or reducer thread.

Now, once the reducer thread has all these values returned by their respective worker threads, the reducer thread will be in a position to actually compute the final result. And what is the final result? The final result is nothing but the reducer thread only has to add all the three values together. That is x plus y plus z. Right. And this will give you the total number of words in the text file. Right. So as I said, moderate a threat need not be reduced, a threat. They can be different threats. So now you understand how MapReduce work. There is one thread called moderator thread which splits a big work into smaller independent units of smaller works. Then each of these smaller work is assigned to an individual thread called mapper thread, then reducer threads waits for all the worker threads to actually finish their chunk of work, work and return result. And when all the worker threads finish their work and return result, the reducer thread uses the result which is returned by each of the individual worker threads to actually calculate the aggregated result. In this case, the aggregated result is X plus y plus Z.

So point to be noted here is that that the reducer thread is blocked until all the mapper threads have returned their respective results. A of thread cannot start computing the aggregated result. If any of the mapper thread has not returned its result. So this is how MapReduce programming model works. That is, it works on the principle of divide and conquer paradigm.
