Cortex-M processors are used in either Little-Endian or Big-Endian memory systems. With Little Endian memory systems, the first byte of word size data is stored in the least significant byte of the 32-bit memory location (Table 6.6).

In Big Endian memory systems, the first byte of word size data is stored in the most significant byte of the 32-bit address memory location (Table 6.7).

Armv8-M Mainline (the Cortex-M33 processor) and Armv7-M processors—the processors determine the endianness of the memory system at a system reset by way of a configuration signal. Once it is started, the endianness of the memory system cannot be changed until the next system reset. However, the system’s hardware would likely be designed for one configuration only and thus cannot be changed.

In some instances, some peripheral registers can contain data of different endianness. In those situations, the application codes accessing those peripheral registers would need to convert the data to the correct endianness by using software (e.g., using REV, REV16, and REVSH instructions).
Please note, for the Cortex-M processors:
• Instruction fetches are always in little-endian
• Access to 0xE0000000 to 0xE00FFFFF, including the System Control Space (SCS), the debug components, and the Private Peripheral Bus (PPB), are always little-endian.

If needed, the software can detect the endianness of the system by reading bit 15 (ENDIANNESS) of the Application Interrupt and Reset Control Register (AIRCR) at address 0xE000ED0C. When this bit is 0, it is little-endian, when it is not, it is big-endian. This bit is  read-only and can only be accessed in a privileged state or by a debugger.

From a programmer’s model point of view, the memory system of a Cortex-M processor is 32 bits. In a 32-bit memory system, a 32-bit (4 bytes, or word) data access or a 16-bit (2 bytes, or halfword) data access can either be aligned or unaligned. An aligned transfer means the address value is a multiple of the transfer size (in number of bytes). For example, a word size aligned transfer can be carried out to  ddress 0x00000000, 0x00000004 … 0x00001000, 0x00001004, …, and so on. Similarly, a halfword size aligned transfer can be carried out to  0x00000000, 0x00000002 … 0x00001000, 0x00001002, …, and so on.

This meant that to access memory, a word transfer would have to have both bit[1] and bit[0] of the address equal to 0. Similarly, a half word transfer would have to have an address bit[0] equal to 0. For example, word data can be located at 0x1000 or 0x1004, but it cannot be located in 0x1001, 0x1002, or 0x1003. For half word data, the address can be 0x1000 or 0x1002, but it cannot be 0x1001. All byte size transfers are aligned. Armv8-M Mainline processors (e.g., the Cortex-M33) and Armv7-M processors (the Cortex-M3, the Cortex-M4 and the Cortex-M7 processors) support unaligned data transfers to memory locations where the memory type is “normal memory” when using single  oadstore instructions (e.g., LDR, LDRH, STR, STRH).

There are several limitations to the unaligned transfer support and these are:
• Unaligned transfers are not supported in Load/Store multiple instructions.
• Unaligned transfers cannot be used on the Private Peripheral Bus (PPB) address range.
• Stack operations (PUSH/POP) must be aligned.
• Exclusive access (such as LDREX or STREX) must be aligned; otherwise, a fault exception (UsageFault) will be triggered.
• Unaligned transfers are not supported on most peripherals. Because most peripherals are not designed to support unaligned transfers, unaligned access to peripherals should generally be avoided.

For the Cortex-M33 processor, unaligned transfers are converted into multiple aligned transfers by the processor’s bus interface unit. Because this conversion is carried out by hardware, application programmers do not have to manually divide the access into multiple software steps. However, the conversion of an unaligned transfer to multiple aligned transfers takes multiple clock cycles. As a result, unaligned data access will take longer than aligned access and might not be good for situations in which high performance is required. To guarantee the best performance, therefore, it is worth ensuring that data is properly aligned. The Armv8-M Baseline processor (the Cortex-M23) and Armv6-M processors (Cortex-M0, Cortex-M0+, and Cortex-M1 processors) do not support unaligned access.  In most instances, C compilers do not generate unaligned data access. It can only happen in:
- Situations where the C/C++ code directly manipulates the pointer values
- Accessing data structures with “__packed” attributes which contain unaligned data
- Inline assembly code
It is possible to set up an Armv8-M Mainline or Armv7-M processor so that an exception is triggered when an unaligned transfer takes place. This is achieved by setting the UNALIGN_TRP (Unaligned Trap) bit in the Configuration Control Register (CCR, address 0xE000ED14) in the System Control Block (SCB). By doing this, the Cortex-M processor generates UsageFault exceptions when unaligned transfers take place. This is useful when developing software as a means to test whether an application produces unaligned transfers.
