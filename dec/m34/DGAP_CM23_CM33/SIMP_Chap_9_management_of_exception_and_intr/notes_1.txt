Arm® Cortex®-M processors use a combination of memory-mapped registers and special
registers for the management of interrupts and system exceptions. These registers reside in
various parts of the processor:
• Most management registers for interrupts are in the NVIC.
• System exceptions are managed by registers in the System Control Block (SCB).
• Interrupt masking registers (PRIMASK, FAULTMASK, and BASEPRI) are special
registers, and can be accessed by using the MSR and the MRS instructions. (Note: The
Cortex-M23 processor does not have FAULTMASK and BASEPRI)
Both the NVIC and SCB registers are in the System Control Space (SCS) address range
(0xE000E000 to 0xE000EFFF). If the TrustZone® security extension is implemented, Secure
software can also access a Non-secure view of SCS using a SCS Non-secure alias (address
range 0xE002E000 to 0xE002EFFF).

There are a number of registers in the NVIC for interrupt control (exception types 16–495).
These registers are located in the address range of the System Control Space (SCS). These registers are listed in Table 9.7.
All these registers, with the exception of the Software Trigger Interrupt Register (STIR), are
only accessible at privileged level. The STIR is accessible at privileged level only by default,
but can be configured to be accessible at unprivileged level by setting the USERSETMPEND
bit in the Configuration and Control Register (Section 10.5.5).

After a system reset, the initial status of the interrupts are as follows:
• All interrupts are disabled (enable bits¼0)
• All interrupts have a priority level of 0 (the highest programmable level)
• All interrupts pending status are cleared
• All interrupts target the Secure state if the TrustZone security extension is implemented
If an interrupt targets the Secure state, then, from a Non-secure software point of view, all
NVIC registers associated with that interrupt are read-as-zero and write is ignored.
Secure software can access the Non-secure view of the NVIC by using the NVIC Nonsecure alias address range 0xE002Exxx. The NVIC Non-secure alias is not available to
Non-secure software or to the debugger.

( TABLE 9.7 Summary of the registers in the NVIC for interrupt control )

The Interrupt Enable register is programmed through two addresses. To set the enable bit,
you need to write to the NVIC->ISER[n] register address and, to clear the enable bit, you need
to write to the NVIC->ICER[n] register address. By doing this, the enabling or disabling of an
interrupt will not affect the enable states of other interrupts. The ISER/ICER registers are
32-bit wide, with each bit representing one interrupt input.
As there are often more than 32 external interrupts in the Cortex-M23 and Cortex-M33
processors, it is likely that each processor will contain more than one ISER and ICER register.

For example, NVIC->ISER[0], NVIC->ISER[1], and so on (Table 9.8). If you only have 32 or
fewer interrupt inputs, you will only have one ISER and one ICER. Only the enable bits for
interrupts that exist are implemented, e.g., if there are 33 interrupts, only the bit 0 of NVIC->
ISER[1] is implemented.

If an interrupt takes place but cannot be executed immediately (e.g., because another
higher-priority interrupt handler is running), it will be pended. The interrupt-pending status is accessible via the Interrupt Set Pending (NVIC->ISPR[n]) and Interrupt Clear Pending
(NVIC->ICPR[n]) registers. Similar to the interrupt-enable registers, the pending status controls, if there are more than 32 external interrupt inputs, will contain more than one register.
Because the values of the pending status registers (Table 9.9) can be changed by software,
you can, when necessary, by using software either:
• cancel a current pended exception by writing to the NVIC->ICPR[n] register or
• generate a software interrupt by writing to the NVIC->ISPR[n] register.

Each external interrupt has an active status bit. When the processor executes the interrupt
handler, the corresponding active status bit is set to 1 and is cleared when the interrupt return
is executed. However, during an Interrupt Service Routine (ISR) execution, another higherpriority interrupt might occur and cause preemption. This results in a nested exception/interrupt scenario, and in such a scenario, the previous servicing interrupt would still be defined as active.
During nested exception/interrupt handling, the IPSR (Interrupt Program Status Register,
see “Program Status Register (PSR)” section in Section 4.2.2.3) shows the current executing
exception service (i.e., the exception number of the higher-priority interrupt). Although
the IPSR cannot be used to identify whether an interrupt is active, the Interrupt Active Status
Register addresses this issue by allowing software and debug tools to detect whether an interrupt/exception is active. This information is valid even if it has been preempted by another
higher priority exception.

Each Interrupt Active Status Register contains the active status of 32 interrupts. If there are
more than 32 external interrupts, there will be more than one active register. The active status
registers for external interrupts are read-only (Table 9.10).

When the TrustZone security extension is implemented, Interrupt Target Non-secure
Register(s) (NVIC->ITNS[n], Table 9.11) are also implemented to allow Secure privileged
software to assign each interrupt as Secure or Non-secure. Similar to other interrupt management registers, the ITNS register will, if there are more than 32 external interrupt inputs, contain more than one register. For each bit, 0 means the targeted security domain is Secure
(which is the default), and 1 is Non-secure. The ITNS registers are only accessible in Secure privileged state; there is no NVIC Nonsecure alias address for the ITNS registers. If the TrustZone security extension is not
implemented, then the ITNS registers are not implemented.

Each interrupt has an associated priority-level register, which is 2-bit wide in the CortexM23 processor and from 3- to 8-bit wide in the Cortex-M33 processor. As described in
Section 8.5.2, for Armv8-M Mainline (e.g., the Cortex-M33 processor) each priority register
can be further divided: into group priority level and into a subpriority level, which is based
on the priority group settings. In Armv8-M Mainline, the priority-level registers are accessible
using byte, half word, or word size transfers. The number of priority-level registers depends
on the number of external interrupts that the chip contains (Table 9.12).

As well as using the NVIC->ISPR[n] registers, you can, if you are using an Armv8-M Mainline processor such as the Cortex-M33, program the Software Trigger Interrupt Register
(NVIC->STIR, Table 9.13) to trigger an interrupt. The Cortex-M23 processor does not support
this register.
For example, you can generate interrupt #3 by writing the following code in C:
NVIC->STIR = 3; // Triggers IRQ #3

Unlike the NVIC->ISPR[n], which is only accessible with a privileged access level, you can
enable unprivileged program code to trigger a software interrupt using NVIC->STIR. To do
this, privileged software needs to set bit 1 (USERSETMPEND) of the Configuration Control Register (address 0xE000ED14, Section 10.5.5). By default, the USERSETMPEND bit is 0,
which means only privileged code can use NVIC->STIR when the system starts.
Similar to NVIC->ISPR[n], NVIC->STIR cannot be used to trigger system exceptions such as
NMI, SysTick, etc. The Interrupt Control and State Register (ICSR) in the System Control Block
(SCB) is, however, available for such system exception management features (Section 9.3.2).

The NVIC also has an Interrupt Controller Type Register in address 0xE000E004. This readonly register gives the number of interrupt inputs supported by the NVIC in granularities of
32 (Table 9.14).

While the Interrupt Controller Type register provides an approximate range of the
available interrupts, it does not furnish you with the exact number of interrupts that have
been implemented. If such information is needed, you can use the following steps to determine how many interrupts have been implemented:
(1) Set the PRIMASK register (to prevent interrupts from being triggered when undertaking
this test)
(2) Calculate N=(((INTLINESNUM+ 1)*32)-1)
(3) Starting with interrupt number N, set the interrupt enable register bit of this interrupt
(4) Read back the interrupt enable register to determine whether the enable bit has been set
(5) If the enable bit is not set, decrement N (i.e., N=N-1) and then retry steps 3 and 4. If the
enable bit is set, then the current interrupt number N is the highest available interrupt
number.
It is also possible to apply the same techniques with other interrupt management registers
(e.g., the pending status or priority level registers) to determine whether a certain interrupt
has been implemented.

When comparing the NVIC in the Cortex-M23 and the Cortex-M33 processors with the
ones in previous Cortex-M processors there are a few noticeable differences:
• The maximum number of interrupt support has increased.
• TrustZone support has been added, including ITNS (Interrupt Target Non-secure Register)
and the NVIC Non-secure alias address range.
