In order to make embedded systems more secure and robust, application threads/tasks are
usually executed at unprivileged level. When using privilege level separation and utilizing
the Memory Protection Unit (MPU) for controlling access permission, unprivileged threads
can only access the memory and resources they are supposed to have access to. However,
since application threads/tasks might, from time to time, need to access privileged features,
many OS’s provide a range of OS services for this purpose. The SVC instruction and the
SVCall exception provide a gateway for those unprivileged threads to access the privileged
level OS services (Fig. 11.11).

( imp: TABLE 11.10 Key aspects of SVCall and PendSV exceptions )

( imp: FIG. 11.11 SVCall as a gateway to OS services. )

Inside an SVC handler, the SVC service in privileged state extracts the parameters passed
from the application and then looks up which application has made the service request (e.g.,
by checking a current OS task ID from the OS kernel). It then decides whether the requested
service should be allowed.
The SVC instruction has an 8-bit integer parameter. This value does not affect the exception
entry sequence of the SVCall exception. However, during the execution of the SVCall handler,
software can extract this data from the program memory and use this value to decide which
SVC service is being requested by the unprivileged application. Because of this, an OS can
provide a range of OS services to the unprivileged application. In many OS designs, the
SVC service look up can be extended to provide custom defined privileged services.
To insert an SVC instruction in an assembly program, the following example code can be
used:
SVC #0x3 ; Call SVC function 3
The immediate value ranges from 0 to 255.

( If we need to enable the SVC service to take input parameters using registers r0–r3 and return a result using r0, the following inline assembly code can be used: )

After triggering the SVC instruction, we then need an SVC handler to deal with the SVC
request. In a typical SVC handler:
• We need to extract the SVC service number from the program memory. To do that, we need
to extract the stacked PC in the stack frame and then use this value to read the SVC number 
• Depending on the SVC service being accessed, we might need to extract arguments––that
is, parameters––from the stack frame
• And, depending on the SVC service being accessed, we might need to return the result(s)
via the stack frame
To allow the SVC service to directly manipulate the stack memory, the SVC handler needs
an assembler wrapper. This assembly wrapper collects two pieces of information which are
then passed to the SVC Handler as function arguments (Fig. 11.12). The two pieces of information are:
• The value of EXC_RETURN
• The value of the MSP when it enters the SVC Handler––this is needed because the prologue
of an SVC Handler in C can update the MSP.

The example SVC Handler code detailed below is written in C. To allow it to be used for OS
services, the handler code needs to:
1. Extract the right stack pointer (Either the MSP or the PSP with the same security domain as
the SVC)
2. Calculate the stack frame address. For the Secure SVC, the handler code needs to determine
whether the stack frame contains Additional State Context (r4–r11 and integrity signature)
(Figs. 8.18, 8.21, 8.22) from the DCRS bit in the EXC_RETURN, and to then adjust the stack
frame address calculation accordingly.
3. Extract the SVC number from the program memory and the function arguments in the
stack frame.

Unlike triggering an exception using the NVIC’s Interrupt Pending Set Registers, the
SVCall exception is synchronous, which means after an SVC instruction is executed, the processor is unable to execute any further instructions in the current context. This is different for
software triggered IRQ services using NVIC->ICSR, where the processor could execute additional instructions before the ISR itself is executed. Please note, because of the way exceptions are handled, if an interrupt with a priority level that is higher than the one for the SVCall
exception arrives at the same time, the interrupt’s ISR would get executed first, and then tailchained into the SVC handler.
Due to the nature and mechanics of exception handling, software designs need to consider
the following aspects when using the SVC:
• The SVC instruction should not be used in an exception/interrupt service routine that has
the same or a higher priority than the SVCall exception, or when an interrupt masking
register is set that blocks the SVCall exception. If the SVCall exception cannot be executed,
a HardFault exception would be triggered.
• When passing parameters to an SVC service via registers r0–r3, the SVC service needs to
extract these parameters from the exception stack frame rather than take the current values
in the register bank. This is because if another interrupt service executes just before the SVC
handler and is tail-chained into the SVC service, the values in r0–r3, and r12 might have
been changed by the previous ISR.
• If an SVC service needs to return a value back to the calling task/thread, the return value
should be written to the exception stack frame in order that it can be read back into r0–r3
during the unstacking of the exception.

One interesting aspect of using the SVC service is that application code only needs to know
the SVC number and the parameters/return results (i.e., the function prototype). It does not
need to know the address of the SVC services. Accordingly, it is possible to separately link the
application code and the OS (i.e., They can be created as separate projects).

( read and compare pendsv )

( imp: FIG. 11.15 The deferring of a context switch to the PendSV handler when an ISR is already running. )

( imp: FIG. 11.16 Using PendSV to partition an interrupt service into two sections. )

If the TrustZone security extension is implemented in the device, the PendSV exception is
banked between security states. The access permission for setting the PendSV pending status
is as follows and as per Table 11.11:
• Secure privileged software can access the pending status of both the Secure and the Nonsecure PendSV.
• Non-secure privileged software is only able to access the pending status of the Non-secure
PendSV.
