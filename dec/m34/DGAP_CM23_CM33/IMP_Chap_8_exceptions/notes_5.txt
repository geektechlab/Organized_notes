In order to allow an interrupted program to resume after the exception/interrupt handler
has ended, the Cortex-M processor automatically pushes a number of registers into the stack
memory. It then restores those registers from the stack when returning to the interrupted program code. In this way, the interrupted code can resume correctly and is unaffected by the fact
that there has been a change of context.

The automatic stacking and unstacking operations use the current selected stack pointer of the interrupted task. For example, if the processor is in the Nonsecure state and is running an application task with the Non-secure Process Stack Pointer
(PSP_NS) selected as the current SP, then PSP_NS will be used for the stacking and unstacking
operations. This is independent from the stack operations within the exception handlers,
which use the Main Stack Pointer (either as Secure or Non-secure, which is dependent upon
the target state of the exception).

For easier development of Cortex-M software, stacking and unstacking works in a way that
enables most exception and interrupt handlers to be programmed as ordinary C functions––
without the need to use tool chain specific keywords to specify that they are exception/interrupt handlers.

Based on the AAPCS specification [3], a C function can modify registers R0–R3, R12,
LR(R14), and the PSR within C function boundaries. If the floating-point unit is present
and enabled, the registers in S0–S15 and the FPSCR (Floating Point Status and Control Register) can also be modified by the C function. The contents on the other registers can also be
modified within the C functions, but the contents of these other registers will need to be saved to the stack before being modified. And, before leaving the C function these registers must be
restored to their original values.
Because of the aforementioned C function requirements, registers in the register bank and
in the floating-point unit register bank are divided into:
- Caller saved registers––R0–R3, R12, LR (also S0–S15 and FPSCR if the FPU is present). If the
data in these registers needs to be used after a C function call, the caller needs to save it
before calling a C function.
- Callee saved registers––R4-R11 (also S16-S31 if the FPU is present). If the C function needs
to modify any of these registers, the C function must first push the affected registers to the
stack and then restore them before returning to caller code.

In addition to caller and callee saved register arrangement, the AAPCS specification also
specifies how parameters and results can be passed between caller and callee. In a simple scenario, registers R0–R3 can be used as input parameters for C functions. Additionally, register
R0 and, optionally, register R1 can be used for returning the results of a function (register R1 is
needed when the return value is 64-bit). Fig. 8.16 shows the grouping of callee-saved registers
and the usage of several caller saved registers for parameters and result passing.

Another requirement of the AAPCS is that the value of the stack pointer must be aligned to
double word boundaries at a function interface. The processor’s exception handling hardware handles this automatically.

To allow a C function to be used as an exception handler, the exception mechanism needs
to automatically save the “caller-saved registers” at exception entrances and restore them at
exception exits. These operations are under the control of the processor’s hardware. In this
way, when returned to the interrupted program the registers retain the same value they
had before the interrupt took place (this excludes special cases like SVC services, where some
of the registers could be used for its return values).

( find how SVC services uses registers for return values )

( imp: FIG. 8.16 Usage of registers for function inputs and outputs based on the AAPCS’s specification. )

When TrustZone is implemented and when a Non-secure interrupt takes place during the
execution of Secure code, then the “callee-saved registers” must also be saved by the stacking
process. This is required because we need to erase the register bank before the Non-secure
handler executes. By so doing, this prevents secure information leaking out. However, this
behavior (i.e., the saving of the callee-saved registers and the erasing of data in the register
bank) does not require the exception handlers, which use a standard C function interface,
to be modified.

For interrupt handling, the automatic stack and unstacking is handled by the processor and is transparent to software. There are, however, some instances
where an understanding of the stack frame is needed and can be useful. These instances are:
• When OS software developers need to create context switching codes or OS services via
SVC exceptions (parameters and results for the OS services can be passed via the stack
frame).
• For the analysis of software failures when the processor enters a fault exception (in order to
locate the faulting address via the stacked return address in the stack frame). Please note,
several commercial development tools have debug features that can extract this
information.

There are several formats of stack frame, with each dependent upon several factors:
• Whether it was running Secure code and will be servicing a Non-secure interrupt. If it was,
both the caller-saved and callee-saved registers need to be pushed into the stack. If it was
not, only the caller-saved registers need to be pushed to the stack during the stacking
process.
• Whether the FPU was enabled and used in current context (indicated by CONTROL.FPCA
being equal to 1). If it was, the caller-saved registers in the FPU register bank will need to be
pushed into the stack.
• Whether the FPU is used by Secure software for Secure processing (determined by the TS
bit in the FPCCR). If this bit is set to 1, then the Callee-saved registers in the floating-point
register bank must also be saved on the stack when the Secure code execution is
interrupted by a Non-secure exception.

At a minimum, an exception stack frame must contain at least 8 data words—Fig. 8.17. The
eight words of data contain the “caller-saved registers” in the regular register bank and information to enable the interrupted software to be resumed later. Since exception handlers
can be implemented as a normal C function, the contents of R0–R3, R12, LR, and xPSR must
be saved. Unlike function calls, the return address for exception handling is not stored in the
LR. At the entrance of the exception handler, the value of LR is replaced by a special value
called EXC_RETURN (Exception Return), which is used to trigger unstacking at the end of the
exception handler.

( very very imp: FIG. 8.17 Exception stack frame without an FPU and which is not interrupted from the Secure background code by
a Non-secure handler. )

The 8-word stack frame format is used when:
• The FPU is not available, is disabled or is inactive in the current context, and
• The transition is not from a Secure background task to a Non-secure handler
This situation is identical to the stack frame in the Armv6-M and Armv7-M processors, but
without an active floating-point context (i.e., CONTROL.FPCA¼0).
Since AAPCS requires that the value of the stack pointer must be double word aligned at
the function boundary, the stacking process automatically inserts a padding word to make
sure that, if needed, the stack frame is double word aligned. If such a padding operation
is carried out, bit 9 of the stack xPSR is set to 1 to indicate the presence of the padding word.
Based on this information, the SP pointer can then re-adjust to the original value during an
exception return.

If the exception happens when executing Secure code and the interrupt/exception target is
in a Non-secure state, then additional registers (callee-saved registers) need to be pushed to
the stack, see Fig. 8.18. The extended stack frame also includes an integrity signature
(0xFEFA125A or 0xFEFA125B, where a value of 0 in the LSB indicates that the stack frame
contains FPU register contents), which is used to prevent the faking of an exception return
from the Non-secure to the Secure world. This stack frame layout is new in Armv8-M and
is only available if TrustZone is implemented.

( very very imp FIG. 8.18 Exception stack frame without an FPU and which is interrupted from Secure background code to the
Non-secure handler. )

Please note, since the additional state context is underneath the previous eight-word stack
frame, the stacking of the additional states can, after the previous eight-word state frame has
been pushed, be pushed with just an extra stacking step. In fact, stacking of the additional
state context can, in certain combinations of an exception event sequence, take place as a
completely separate operation. For example, if the processor is running Secure code and receives two interrupts, the first one being Secure and the second Non-secure, the exception
stacking operations, as shown in Fig. 8.19, could occur.

The stack frame can get more complex when the FPU is available and is enabled. Assuming
that the Secure software did not setup the FPU as Secure (FPCCR.TS==0), and the exception
event is not switching the processor from a Secure background task to a Non-secure handler,
then the stack frame, as shown in Fig. 8.20, is generated. This situation is identical to the stack
frame in Armv7-M processors with a floating-point context (FPU is enabled and is used).

If the processor was executing Secure code (without setting up the FPU as Secure, that is,
FPCCR.TS==0) and a Non-secure exception takes place, then the additional state context is added to the stack frame, as shown in Fig. 8.21. This stack frame layout is new in Armv8-M
and is only available if TrustZone is implemented.
And, finally, if the Secure software does need to use the FPU for secure data processing it
would need to set FPCCR.TS to 1. On the basis that:
• The processor was executing Secure software and the exception is targeting the Non-secure
state,
• The FPU is enabled and is used in the current context (i.e., CONTROL_S.FPCA is 1),
then the maximum size stack frame is used. The stack frame in this scenario would include
the additional floating-point context, as shown in Fig. 8.22.

( very very imp: FIG. 8.22 Stack frame with floating-point context (extended stack frame) and with additional state and FP state
context. )

When the FPCCR.TS is set to 1 and if the processor was executing Secure code and the incoming exception target is in Secure state, the processor will still allocate the stack space for
the additional FP (floating-point) context (S16–S31). This is because it is possible for a Nonsecure interrupt to take place while the Secure handler is running.
As you can see, the processor might, depending on configuration, need to push a fairly high
number of registers to the stack when servicing exceptions/interrupts. The more registers that need to be pushed to the stack, the longer the stacking sequence will take. To avoid causing unnecessary delaysin interrupt handling, Cortex-M processors with a floating-point unit support a
feature called lazy stacking. By default, this feature is enabled. With this feature, although the
processor will still allocate stack spaces for the floating-point registers it will not actually take
time to push the data into the stack. If the exception/interrupt handler executes a floating-point instruction, this will trigger the lazy stacking which then stalls the pipeline and pushes the
floating-point registers into the allocated stack space. If the handler did not use the FPU, the processorwill,during theunstacking stage, skip the unstacking of FPU registers. By utilizing thelazy
stacking feature, most interrupt/exceptions (i.e., those that do not use the FPU) are, by omitting
the saving and restoring of the FPU registers, serviced more quickly.

The stack pointer used by the interrupted background thread/process is used for stacking
and unstacking. This is dependent on the processor’s security state, the processor’s mode (i.e.,
whether it is already executing an exception/interrupt handler) and the setting in the CONTROL.SPSEL (this is covered in “CONTROL register” section). The way that the stack pointer
is selected is shown in Table 8.13.

( very very imp: TABLE 8.13 Stack pointer selection in various situations. )

( very very imp: FIG. 8.23 The selection of the stack pointer for stacking and unstacking. )
