In C functions, the function return is normally carried out by loading a return
address (which is loaded into the LR when the function call is made) into the PC
(Program Counter), for example, by executing a “BX LR” instruction.

when an interrupt
handler executes a return how does the processor know that it is an exception return (which
triggers unstacking, rather than a normal function return)? The answer is that Cortex-M processors use a special value called EXC_RETURN (Fig. 8.24) to indicate an exception return
when it is loaded into the PC. This is achieved by the use of instructions that updates the
PC as shown in Table 8.8.

When the interrupt handler starts, the EXC_RETURN value is generated by hardware and
is loaded automatically into the LR. The last step of the interrupt handler loads the
EXC_RETURN into the PC, just like a normal return address, which triggers the exception
return sequence.

( very very imp: FIG. 8.25 Bit fields in EXC_RETURN. )
( very very imp: TABLE 8.14 Bit fields in EXC_RETURN. )
( very very imp: FIG. 8.26 EXC_RETURN value in various exception handling scenarios. )

if we assume that the processor is in Non-secure thread mode and running a “bare metal” application (i.e.,
a software system with no RTOS), the value of the EXC_RETURN in various exception/interrupt events is shown in Fig. 8.27.
If the application deploys an RTOS running in the Non-secure world, then it is very likely
that the Non-secure world will be using PSP_NS for its thread. Fig. 8.28 shows a Non-secure
thread using PSP_NS being interrupted.
The left hand-side of Fig. 8.26 details several exception transitions where EXC_RETURN.
DCRS¼0, which can be caused by one of the following scenarios:
• Scenario 1: The back ground program is Secure, it is interrupted by a Non-secure interrupt
and the additional state context information (i.e., callee-save registers) has been pushed to
the stack. And then, just before the Non-secure ISR has started, a higher priority Secure interrupt takes place and the processor switches to execute the Secure handler first, that is,
before the Non-secure interrupt is serviced (see Fig. 8.29).
• Scenario 2: The back ground program is Secure, it is interrupted by a Non-secure interrupt
and the additional state context information (i.e., callee-save registers) has been pushed to
the stack. And then, during the execution of the Non-secure ISR, a Secure interrupt occurs,
which has the same or a lower priority than the priority level of the executing Non-secure
interrupt. After the execution of the Non-secure interrupt handler is completed, the
processor switches over to execute the pending Secure interrupt handler (see Fig. 8.30).

In the aforementioned scenarios, although both Background and ISR are Secure the stack
frame still contains the additional context, which is usually needed when dealing with Nonsecure exceptions. Secure handlers can use EXC_RETURN.DCRS to determine whether the
additional context is in the stack frame.

bit fields of EXC_RETURN have been extended when compared to that available in Armv7-M and Armv6-M. In some instances, therefore, source codes will need to be updated to enable them to be used in Armv8-M processors. The areas that source code might
contain EXC_RETURN values include:
• RTOS––for example, for starting a task/thread
• Handler redirection code that switches exception handlers to an unprivileged state

In the case of the RTOS, the direct manipulation of the stack frame is often, as shown in
Fig. 8.31, used to start a new thread.

( very very imp: FIG. 8.31 Use of EXC_RETURN to start a new thread. )

As a result of the EXC_RETURN bit field extensions, the RTOS created for Armv7-M/
Armv6-M needs to be updated to support Armv8-M processors. This is the case even if
the RTOS is being used on a new Armv8-M based microcontroller without the implementation of TrustZone. In addition to the changes for EXC_RETURN update, the RTOS update
might also need to include support for stack limit checking (see Chapter 11) and support
for the new MPU programmer’s model (see Chapter 12).

Another way to classify exceptions is basing it on the nature of the timing relationship between the exception response and the code execution that is being interrupted.
• Synchronous exceptions––these are exceptions that must immediately respond to the
executed code stream without further code execution in the current thread. Examples of
this type of exceptions are:
• SVCall––The SVC handler must be executed before executing the instructions after the
SVC instruction.
• SecureFault, UsageFault, MemManage fault and synchronous BusFault––An error has
occurred in the current thread and should not continue until the fault handling
exception has taken place.
• Asynchronous exceptions––This is where the processor is allowed, for a short period of
time, to continue current code stream execution before the exception handler starts
executing. (The shorter the delay the better for providing a faster interrupt response time.)
Examples of this type of exceptions are:
• Interrupts including the Non-Maskable Interrupt (NMI)
• SysTick interrupt
• PendSV exception
• Asynchronous BusFault––In some processor implementations that contain write
buffer(s) in the bus interface, a write operation might be buffered and not take place
immediately. At the same time, the processor continues its execution of the subsequent
instructions. The delayed write operation might then result in a bus error response
which would then be handled as an asynchronous BusFault. (Note: Cortex-M23 and
Cortex-M33 processors do not have internal write buffers so asynchronous BusFaults
are not applicable to these processors.)

For synchronous exceptions, the exception handler execution usually immediately follows
the exception event. However, if another higher priority exception arrives at the same time,
one that could preempt the current exception entrance sequence, the processor will service
the other higher priority exception first. The deferred synchronous exception is then executed
after the higher priority exception handler has completed its task.

In older Arm Cortex-M documentation, an asynchronous BusFault was known as an imprecise BusFault, and a synchronous BusFault was known as a precise BusFault. These classification names were then changed to become synchronous and asynchronous in order to
align with the architecture of other Arm Cortex processors.
