Stack activities during interrupt and exception. To allow a 'C' function to be used as an exception or interrupt handler, the exception mechanism needs to save R0 to R3, R12,LR, and XPSR at exception entrance automatically and restore them at exception exit under the control of the processor hardware. In this way, when returned to the interrupted program, all the registers would have the same value as when the interrupt entry sequence started.

Some registers have to be saved by the caller and some registers have to be saved by the callee as per the standard. But, consider the case of interrupt or exception execution, there is no caller, isn't it? Because, interrupt and exception handlers are asynchronous in nature. They can come at any time, there is no caller. That means, the processor hardware calls them, whenever there is an event of interrupt or exception in the processor hardware. That's why, since there is no caller, the processor saves "caller saved registers". You can write an interrupt or exception handler as normal 'C' function without worrying about AAPCS rules.

Let's say, you have a thread mode code which is running and suddenly an interrupt arrives and processor will start executing the interrupt handler automatically. But before that, at this point, the registers are saved automatically by the processor hardware. And that what we call as a stack frame. Compiler need not to worry about generating any instructions to do this job.Processor does this automatically. So, you can write the interrupt or exception handler as normal 'C' functions.

Let's say, you have a task running in the thread mode and this is a thread mode code. It is using MSP. If it wants to do any PUSH and POP operation. And let's say suddenly the interrupt or exception arrives.So,the exception handler should come back to the task later. It should know some information, where it should go back. There is no software caller for this exception handler, the hardware called it. That's a reason hardware will save the stack frame onto the stack, which consist of all these registers, and the return address, and the status register of the thread mode code. That's what we call as stacking. When the exception handler finishes and when it wants to exit, hit does an exit, while exiting the processor will automatically retrieve a those register values and the return address and the execution control will come back to the interrupted a thread mode code. This stacking and unstacking will be taken care by the processor automatically during exception entry and exception exit. And stack initialization.

Let's discuss about stack initialization methods or stages by which you can initialize the stack in your application.There could be 2 stages. One is before reaching main and after reaching main.Main is the point from which your user application starts. Before reaching main the stack must be initialized. And this is usually done by the processor itself by reading the first location of the vector table. That's a reason, you should always ensure that the first location of the vector table holds the valid value for the stack pointer register. This is generally taken care by the startup code like we discussed in the earlier videos. After reaching the main function you may again reinitialize the stack. That's possible. Let's say, after reaching the main function you may want to shift the stack to some other memory, maybe two SRAM3, or maybe two a external RAM connected to your microcontroller, something like. That you can again do after reaching main. But, before reaching main you cannot do that.

Stack initialization tips:
	1) First of all you have to evaluate your targeted application. Decide the amount of stack that would be needed for the worst-case scenario of your application runtime.
	2) Second point know your processor's stack consumption model. What it is? Whether it is FD, FA, ED, EA. you should know that. Decide stack placement in the RAM. Where do you want to place that stack? Whether it is in the middle, end, or external memory. You can adjust this memory placement using linker script. 
	3) In many applications, there may be a second stage stack init. For example, if you want to allocate stack in external SDRAM then first start with internal RAM, in the main or startup code initialize the SDRAM then change the stack pointer to point to SDRAM. This involves 2 stage stack initialization. First, application starts with internal RAM as stack, and then in the main code you configure the SDRAM, and then you use SDRAM as stack. You change the stack pointer register and you may also change the a type of stack pointer, whether it is MSP or PSP.
	4) If you are using the ARM Cortex Mx processor, make sure that the first location of the vector table contains the initial stack address. The startup code of the project usually does this.
	5) You may also use the linker script to decide the stack, heap, and other RAM area boundaries. Startup code usually fetches boundary information from linker scripts. In an RTOS scenario, the kernel code may use MSP to trace its own stack and configure PSP for a user task's stack.
