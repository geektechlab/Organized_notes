Importance of T bit of of the EPSR:

Various ARM processors support ARM-Thumb interworking, that means the ability to switch between ARM and Thumb state.The processor must be in ARM state to execute instructions which are from ARM ISA, that is ARM instruction set architecture. And the processor must be in Thumb state to execute instructions of Thumb ISA. If 'T' bit of the EPSR is set, processor thinks that the next instruction which it is about to execute is from Thumb ISA. And if the 'T' bit of the EPSR is 0, then processor thinks that the next instruction which it is about to execute is from ARM ISA. That's a use case of 'T' bit. 'T' bit decides what kind of instruction it is, whether it is from ARM ISA or Thumb ISA.

The Cortex Mx processor does not support "ARM" state. Hence, the value of 'T' bit must always be 1. Failing to maintain this is illegal and this will result in the "usage fault" exception.  Because ARM Cortex Mx processor cannot execute ARM ISA instruction, because the instruction set architecture used in ARM Cortex Mx processor is Thumb ISA. It can only execute Thumb instruction. When you are working with ARM Cortex Mx processor the 'T' bit should always be 1. The lsb that is bit 0 of the program counter is linked to this 'T' bit. When you load a value or an address into PC the bit[0] of that value is loaded into the T-bit. Hence, any address you place in PC must have its 0th bit as 1.

This is usually taken care by the compiler and programmers need not to worry most of the time. Most of the time it will be taken care by the compiler when you code with high level languages such as C. You should be careful only when you are placing some raw value or raw address into the program counter. And you should make sure that, that raw value should be odd, that means the 0th bit of the that address should be 1.

For example, let's say you are dealing with some function pointers and you are initializing a function pointer with a raw address. Then make sure that, that raw address is odd. Or you should be careful whenever you are dealing with inline assembly codes using the program counter. But, if you are using pure 'C' programming than you need not to worry about all these things. The compiler will take care of it. This is the reason why you see all vector addresses are incremented by 1 in the vector table. So, if you just take a look into the vector table all the addresses odd, isn't it? the reason is T-bit.

Not maintaining T-Bit as 1 will cause this exception, that is attempt to switch to invalid state. That will be escalated as hard fault exception.
