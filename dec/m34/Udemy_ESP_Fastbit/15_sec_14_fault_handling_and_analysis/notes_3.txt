mem manage fault exception is a configurable fault exception. This is disabled by default. If you want to enable this exception,then you have to visit this register in the processor."System Handler Control and Status Register (SHCSR)". This is a processor specific register a which you can find in system control block (SCB). When Mem manage fault happens men manage fault exception handler will be executed by the processor and priority of this fault exception is configurable. Here is a register system handler control and state register, you have to touch 16th bit here, in order to enable this exception.

Let's understand some of the causes of a mem manage fault exception. The number one reason as its name indicates this fault exception triggers when memory access violation is detected. That means, if you are code violates access permission which is set by the processor or by the memory protection unit. If there is any violation during read and write, men manage fault exception will be triggered. Unprivileged thread mode code (such as user application or RTOS task) tries to access a memory region which is marked as "privileged access only" by the memory protection unit. By using memory protection unit what you can do is, a you can mark some regions of the memory as privileged access only. If you have done something like that, then if any unprivileged code such as an RTOS task. If it tries to read or write to that memory region that would result in a memory manage fault. It is very helpful in RTOS scenario. Now the third reason could be writing to memory regions which are marked as read only by the MPU. This fault can also be triggered when trying to execute program code from "peripheral" memory regions. Peripheral memory regions are marked as eXecute Never by the processor to avoid code injection attacks through peripherals. If you look at the memory regions of the processor memory map, there is a code space, there is a RAM space, there is a peripheral space, there is a external RAM space, and various other regions. In the code region you can read and write, no problem. In the SRAM region also you can read and write. No problems. So, processor doesn't impose any restrictions. The peripheral region is marked as XN, which stands for eXecute Never. If you keep any of these addresses in the program counter and if you try to fetch any instruction, then that would result in memory manage fault exception. These are all the memory regions which are marked as XN. This is actually implicit in the processor design itself. You cannot change it.

this is a configurable fault exception which is disabled by default, and you have to referred to the same register system handler control and state register, and you have to touch the 17th bit in order to enable or disabled this exception.

What are the possible causes of this fault? Due to error response returned by the processor bus interfaces during access to memory devices. Such as during an instruction fetch, or during a data fetch or data write to external memory devices. If there is any problem in the bus transactions, then that would result in bus fault exception.

If bus error happens during vector fetch from the vector table, it will be escalated to a hard fault even if bus fault exception is enabled. That will always cause hardfault.

After that, memory device sends error response when the processor bus interface tries to access invalid or restricted memory locations which could generate a bus fault. That is you are trying to access some restricted memory or restricted locations of the external memory. In that case, the memory device may send error response and that would result in a Bus fault. When the device is not ready to accept memory transfer.

You may encounter such issues when you play with external memories such as SDRAM connected via DRAM controllers. After that, unprivileged access to the private peripheral bus registers. Let's say, a SCB system control block registers, or NVIC registers, or debug registers of the processor. They all come under private peripheral bus access. If any unprivileged code tries to access those registers, then that would result in bus fault. For example, let's say there is a thread mode code which is in unprivileged access level, and if that code tries to configure the NVIC register, then that's a fault. That would cause a bus fault.

usage fault exception is also another configurable fault exception which is disabled by default, you have to touch 18th bit in the system handler control and state register to enable this exception.

What are the causes of usage fault exception? Execution of undefined instruction. For example, a Cortex M4 supports only thumb ISA, isn't it? so executing any instruction outside this ISA (like ARM ISA) would result in a fault. The next cause would be executing floating point instruction keeping floating point unit of the processor disabled. Let's say, if there is any microcontroller which doesn't have floating point unit, that is hardware floating point unit. If the processor tries to execute hardware floating point instruction, then that would cause a fault. Before executing any floating point instructions the floating point unit must be enabled. After that, trying to switch to ARM state to execute ARM ISA instructions. The Cortex MX processor  doesn't support ARM state, it supports only thumb state. The state is decided by the T bit of the processor. The T bit actually decides ARM state or thumb state. For cortex M T Bit should be maintained at 1. Making T bit zero, this may happen during function call using function pointers whose 0th bit is not maintained as 1. That would result in a usage fault exception. That is trying to switch to ARM state to execute ARM ISA instruction.

So, after that, trying to return to thread mode when an exception or interrupt is still active.Unaligned memory access with multiple load or multiple store instructions. This would result in a usage fault exception. And after that, attempt to divide by zero. This will cause usage fault exception, but only if divided by zero trap is enabled. Otherwise, the result of divide by zero by default will be 0. For all unaligned data access from memory. Again this is true only if unaligned data access trap is enabled. Otherwise, cortex M supports unaligned data access. If you enable unaligned data access trap and if there is any unaligned data access attempt and that  would result in a usage fault exception.
