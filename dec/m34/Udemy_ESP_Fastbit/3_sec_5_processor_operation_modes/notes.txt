ARM processor actually gives 2 operational modes. One is called Thread mode and another one is called handler mode.All your application code will execute under thread mode of the processor. This is also called as user mode. All the exception handlers or it also call it as interrupt handlers runs under the handler mode of the processor. So, that means whenever your processor hits with any system exceptions or any interrupts which comes from any peripherals, then the processor will immediately changes its mode to the handler more and the interrupt service routine associated with that exception or interrupt will be executed under the handler mode. So, all the exception handlers or interrupt handlers will run under the handler mode of the processor.

Processor by default starts with thread mode. Whenever the core meets with the system exception or any external interrupts then the core will change its mode to handler mode in order to service the Interrupt Service Routine associated with that system exception or the interrupt. In handler mode, you have full control over the processor. You can touch any resources you want,you can access all the system level registers of the ARM Cortex Mx processor, you can change the interrupt configuration, you can modify some of the control registers, you have full access to the processor. That's a speciality of handler mode code. Because, handler mode code always executes in privileged access level.

That doesn't mean that thread mode codes will not have privileged access level.Of course they have. By default, all thread mode codes have privileged access level. That's a reason why I'm able to change the a system specific register of the processor in this course snippet. But I can restrict thread mode code not to touch or change any system level settings of the processor by changing the access level to the unprivileged access level. But no one can put restriction on the handler mode code. The handlermode code cannot be in unprivileged access level. It will always execute in privileged access level in ARM Cortex Mx processor.

R13 is a stack pointer which is used to track the stack memory. And beside this R13 register two more registers are mentioned, that is PSP which stands for processor stack pointer, and MSP which stands for main stack pointer, and these registers are called as Banked version of stack pointer. The register R14 is called as the LR. LR stands for link register. It stores the return information for subroutines, function calls, and exceptions. On reset, the processor sets the LR value to 0xFFFFFFFF. When jump to another address, the LR is loaded with the address of the next instruction. That's how, processor maintains the written address. PC is loaded with new address, LR is loaded with the return address. And when the function to finishes here, it has to return to function1. At that time the saved LR is copied into PC. That's how PC jumps back to resume function1. That's a use case of LR. So, that's why, LR is used during function call or subroutine call.To link back to the caller.

The R15 register is called as program counter. So, you can just read about that program counter. Here, program counter is register R15. It contains the current program address. it contains the current instruction to be executed. On reset, the processor loads the PC with the value of the reset vector, after reset the processor automatically loads PC with the value of the reset vector, which is at this address in the memory map. Bit[0] of the value is loaded into the EPSR T-bit at reset and must be 1.

So for, we have explored about the General Purpose Registers, SP, LR, and PC. Now, let's explore special registers.The Program Status register holds the status of the current execution of the program. This is also 32 bit and it is actually a collection of three different registers. The program Status Register combines three sub registers. One is called as APSR which stands for application program status register, which consumes only five bits out of these 32 bits inside the program status register. In the program status register these 5 bits are called as APSR. Interrupt program status register that we call as IPSR which actually consumes 0 to 8 bits here. So, this is called as IPSR register. And the execution program status registered that we call as EPSR and EPSR consumes some bits in between. So, this is collectively called as execution program status registers. So, collectively these three registers are called as program status register. APSR contains all the conditional flags. like Negative flag, Zero flag. If the current instruction execution resulted in any negative value in the ALU, then the negative flag will be set. And if the current operations results in zero value in the ALU the Zero flag will be set and based on that you take you know decision in your assembly programming So, this conditional flags will be useful when you do assembly level programming, where you want to branch based on negative result or you want to take some other decision on the zero or nonzero condition. The IPSR contains the exception type number of the current interrupt service routine. It says that exception type number of the current interrupt service routine.

the register set of the processor are called as Non-memory map registers. Because, these registers do not have unique addresses to access them.Hence, they are not part of the processor memory map All the general purpose registers, the stack pointer,the program counter, link register, special register such as program status register, control register, exception mask register, all these are Non-memory map registers. They are internal to the processor core, they don't have any address to access them from 'C' program. You can't use your 'C' program address manipulation technique to access them. That's why, you cannot access these register in a 'C' program using address dereferencing, that's not possible. To access these registers you have to use assembly instructions. If you want to access let's say the general purpose registers from the 'C' code, then you have to use the data movement instruction such as MOV or Load like that.

Memory mapped registers are part of the processor memory map. That means every register has its own unique address, by using that address in your program you can dereference and you can read and write data to these registers. That's why, to access the memory map registers from your 'C' code you need not to use any assembly instruction. That's why, what I can say is, you can access these registers in a 'C' program using address deeferencing. In the memory mapped registers there are two types or two groups. Some registers which belong to processor peripheral. What are the peripherals of the processor? Like the nested vector interrupt controller, the memory protection unit, the system control block, debug unit,these are all peripherals of the processor.After that, registers of the microcontroller specific peripherals. For example, RTC, I2C, Timer, CAN, USB, all these are peripherals of the microcontroller. These are vendor specific peripherals, that's why, the registers which govern these peripherals are called as vendor specific registers. These are processor specific a registers, which are implemented by the processor design.All these registers are covered by the processor memory map. Whereas, these registers are not covered under processor memory map.
