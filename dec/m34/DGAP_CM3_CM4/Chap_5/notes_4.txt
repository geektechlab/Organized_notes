Memory access instructions

( Table 5.6 )

Note: The LDRSB and the LDRSH automatically perform a sign extend operation on the loaded data to convert it to a signed 32-bit value. For example, if 0x83 is read in a LDRB instruction, the value is converted into 0xFFFFFF83 before being placed in the destination register. If the floating point unit is present, the instructions in Table 5.7 are also available to transfer data between the register bank in the floating point unit and memory. There are also a number of addressing modes available. In some of these modes, you can also optionally update the register holding the address (write back).

Immediate offset (pre-index)
	The memory address of the data transfer is the sum of a register value and an immediate constant value (offset). Sometimes this is referred to as “pre-index” addressing. For example:
		LDRB R0, [R1, #0x3] ; Read a byte value from address R1+0x3, and store the read data in R0.
	The offset value can be positive or negative. ( Table 5.8, 5.7 )

	This addressing mode supports write back of the register holding the address. For example:
		LDR R0, [R1, #0x8]! ; After the access to memory[R1+0x8], R1 is updated to R1+0x8
	The exclamation mark (!) in the instruction specifies whether the register holding the address should be updated (write back) when the instruction is completed. The address used for the data transfer uses the sum of R1þ0x8 calculated regardless of whether the exclamation mark (!) is stated. The write back operation can be used with a number of load and store instructions as shown in Table 5.9. Please note that some of these instructions cannot be used with R15(PC) or R14(SP). In addition, the 16-bit versions of these instructions only support low registers (R0-R7) and do not provide write back. If the floating point unit is present, the instructions in Table 5.10 are also available to perform LDM and STM operations to the registers in the floating point unit.

PC-related addressing (Literal)
	A memory access can generate the address value from the current PC value and an offset value (Table 5.11). This is commonly needed for loading immediate values into  a register, also known as literal pool accesses, as mentioned earlier in this chapter (LDR pseudo instruction).

Register offset (pre-index)
	Another useful address mode is the register offset. This is often used in the processing of data arrays where the address is a combination of a base address and an offset calculated from an index value. To make this address calculation even more efficient, the index value can be shifted by a distance of 0 to 3 bits before being added to the base register. For example:
		LDR R3, [R0, R2, LSL #2] ; Read memory[R0+(R2 << 2)] into R3 The shift operation is optional. You can have a simple operation like
		STR R5, [R0,R7] ; Write R5 into memory[R0+R7]

Post-index
	Memory access instructions with post-index addressing mode also have an immediate offset value. However, the offset is not used during the memory access, but is used to update the address register after the data transfer is completed. For example:
		LDR R0, [R1], #offset ; Read memory[R1], then R1 updated to R1+offset
	When the post-index memory addressing mode is used, there is no need to use the exclamation mark (!) sign because the base address register is always updated if the data transfer is completed successfully. Table 5.14 lists various form of post indexing memory access instructions. The post-index address mode can be very useful for processing data in an array. As soon as an element in the array is accessed, the address register can be adjusted to the next element automatically to save code size and execution time. Please note that post-index instructions cannot be used with R15(PC) o R14(SP). The post-index memory access instructions  are 32-bit. The offset value can be positive or negative.

Multiple load and multiple store
	One of the key advantages of the ARM architecture is that it allows you to read or write multiple data that are contiguous in memory. The LDM (Load Multiple registers) and STM (Store Multiple registers) instructions only support 32-bit data. They support two types of pre-indexing:
	• IA: Increment address After each read/write
	• DB: Decrement address Before each read/write
	The LDM and STM instructions can be used without base address write back (Table 5.15). The <reg list> in Table 5.15 is the register list. It contains at least one register, and:
	• Start with “{“ and end with “}”
	• Use “-“ (hypen) to indicate range. For example, R0-R4 means R0, R1, R2, R3
	and R4.
	• Use “,” (comma) to separate each register
	For example, the following instructions read address 0x20000000 to 0x2000000F (four words) into R0 to R3:
		LDR R4,=0x20000000 ; Set R4 to 0x20000000 (address)
		LDMIA R4, {R0-R3} ; Read 4 words and store them to R0 - R3
	The register list can be non-contiguous such as {R1, R3, R5-R7, R9, R11-12}, which contains R1, R3, R5, R6, R7, R8, R11, R12. Similar to other load/store instructions, you can use write back with STM and LDM. For example:
		LDR R8,=0x8000 ; Set R8 to 0x8000 (address)
		STMIA R8!, {R0-R3} ; R8 change to 0x8010 after the store
	Instructions with multiple Load/Store memory access instructions with write back are listed in Table 5.16. The 16-bit versions of the LDM and STM instructions are limited to low registers only and always have write back enabled, except when the base register is one of the destination registers to be updated by the memory read. If the floating point unit is present, the instructions in Table 5.17 are also available to perform load multiple and store multiple operations to the registers in the floating point unit.

Stack push and pop
	Stack push and pop are another form of the store multiple and load multiple. They use the currently selected stack pointer for address generation. The currently selected stack pointer can either be the Main Stack Pointer (MSP), or the Process Stack Pointer (PSP), depending on the current mode of the processor and the value in the CONTROL special register (see Chapter 4). Instructions for stack push and stack pop are shown in Table 5.18. The register list syntax is the same as LDM and STM. For example:
		PUSH {R0, R4-R7, R9} ; PUSH R0, R4, R5, R6, R7, R9 into stack
		POP {R2, R3} ; POP R2 and R3 from stack
	Usually a PUSH instruction will have a corresponding POP with the same register list, but this is not always necessary. For example, a common exception is when POP is used as a function return:
		PUSH {R4-R6, LR} ; Save R4 to R6 and LR (Link Register) at the beginning of a subroutine. LR contains the return address processing in the subroutine
	Instead of popping the return address into LR, and then writing it to the program counter (PC), we can write the return address directly to PC to save instruction count and cycle count. The 16-bit versions of PUSH and POP are limited to low registers (R0 to R7), LR (for PUSH), and PC (for POP). Therefore if a high register is modified in a function and the contents of the register need to be saved, you need to use a pair of 32-bit PUSH and POP instructions. If the floating point unit is present, the instructions in Table 5.19 are also available to perform stack operations to the registers in the floating point unit. Unlike PUSH and POP, VPUSH and VPOP instructions require that:
	• The registers in the register list are consecutive

SP-relative addressing
	Besides being used for the temporary storage of registers in functions or subroutines, the stack memory is very often also used for local variables, and accessingthese variables requires SP-relative addressing. There is no special 32-bit version of SP-relative addressing as this is already covered by the load and store instructions with immediate offset. However, most 16-bit Thumb instructions can only use low registers. As a result, there is a pair of dedicated 16-bit version of LDR and STR instructions with SP-relative addressing. An example of using SP-relative addressing mode (Figure 5.5) can be: at the beginning of a function the SP value can be decremented to reserve space for local variables and then the local variables can be accessed using SP-related addressing. At the end of the function, the SP is incremented to return to the original value, which frees the allocated stack space before returning to the calling code.

Load and store with unprivileged access level
	There is a set of load and store instructions to allow program code executing in privileged access level to access memory with unprivileged access rights, as shown in Table 5.20. These instructions might be needed in some OS environments where an unprivileged application can access an API function (running within the privileged access level) with a data pointer as an input parameter, and this API operates on memory data specified by the pointer. If the data access is carried out using normal load and store instructions, the unprivileged application task will then have the ability to modify data that is used by other tasks or OS kernel using this API. By coding the API using these special Load and Store instructions with unprivileged access level, the API can only access the data which the application task can access.

Exclusive accesses
	The exclusive access instructions are a special group of memory access instructions for implementing semaphores or MUTEX (Mutual Exclusive) operations. Exclusive access instructions include exclusive loads and exclusive stores.Special hardware inside the processor and optionally in the bus interconnect are  needed to monitor exclusive accesses. Inside the processor, a single bit register is present to record an on-going exclusive access sequence: we call it the local exclusive access monitor. On the system bus level, an exclusive access monitor might also be present to check if a memory location (or memory device) used by an exclusive access sequence has been accessed by another processor or bus master. The processor has extra signals in the bus interface to indicate that a transfer is an exclusive access and to receive a response from the system bus level exclusive access monitor. In a semaphore or a MUTEX operation, a data variable in RAM is used to represent a token. It can be used to indicate, for example, that a hardware resource has been allocated to an application task. For example, assume that if the variable is 0, it indicates the resource is available, and 1 indicates that it is already allocated to a task. The exclusive access sequence for requesting the resource might be:
	1. The variable is accessed with an exclusive load (read). The local exclusive access monitor inside the processor is updated to indicate an active exclusive access transfer and, if a bus level exclusive access monitor is present, it will also be updated.
	2. The variable is checked by the application code to determine whether the hardware resource has already been allocated. If the value is 1 (already allocated), then it can retry later or give up. If the value is 0 (resource free), then it can try to allocate the resource in the next step.
	3. The task uses an exclusive store to write a value of 1 to the variable. If the local exclusive access monitor is set and there is no error reported by the bus level exclusive access monitor, the variable will be updated and the exclusive store will get a success return status. If something happened between the exclusive load and exclusive store that could affect the exclusiveness of the access to the variable, the exclusive store will get a failed return status and the variable will not be updated (either cancelled by the processor itself or the store is blocked by the bus level exclusive access monitor).
	4. From the return status, the application task knows that if it has allocated the hardware resource successfully. If not, it can retry later or give up. The exclusive store fails if:
		• The bus level exclusive access monitor returns an exclusive fail response (e.g., the memory location or memory range has been accessed by another processor)
		• The local exclusive access monitor is not set. This can be caused by:
			a) Incorrect exclusive access sequence
			b) An interrupt entry/exit between the exclusive load and exclusive store (the
			memory location or memory range could have been accessed by an interrupt
			handler or another application task).
			c) Execution of a special instruction CLREX that clears the local exclusive
			access monitor.

Arithmetic operations
	The Cortex-M3 and Cortex-M4 processors provide many different instructions for arithmetic operations. A few basic ones are introduced here. Many data processing instructions can have multiple instruction formats. For example, an ADD instruction can operate between two registers or between one register and an immediate data value:
		ADD R0, R0, R1 ; R0 = R0 + R1
		ADDS R0, R0, #0x12 ; R0 = R0 + 0x12 with APSR (flags) update
		ADC R0, R1, R2 ; R0 = R1 + R2 + carry
	These are all ADD instructions, but they have different syntaxes and binary coding. Aside from ADD instructions, the arithmetic functions that the Cortex-M3 supports include SUB (subtract), MUL (multiply), and UDIV/SDIV (unsigned and signed divide). ( Table 5.22 ) By default, if a divide by zero takes place, the result of the UDIV and SDIV instructions will be zero. You can set up the DIVBYZERO bit in the NVIC Configuration Control Register so that when a divide by zero occurs, a fault exception (usage fault) takes place. Both the Cortex-M3 and Cortex-M4 processors support 32-bit multiply instructions and multiply accumulate (MAC) instructions that give 32-bit and 64-bit results.

Logic operations
	The Cortex-M3 and Cortex-M4 processors support various instructions for logic operations such as AND, OR, exclusive OR and so on. Like the arithmetic instructions, the 16-bit versions of these instructions update the flags in APSR. If the “S” suffix is not specified, the assembler will convert them into 32-bit instructions. The logic operation instructions are given in Table 5.24. To use the 16-bit versions of these instructions, the operation must be between two registers with the destination being one of the source registers. Also, the registers used must be low registers (R0-R7), and the S suffix should be used (APSR update). The ORN instruction is not available in 16-bit form.

Shift and rotate instructions
	The Cortex-M3 and Cortex-M4 processors support various shift and rotate instructions, as shown in Table 5.25, and illustrated in ( imp Figure 5.6 ). If the S suffix is used, these rotate and shift instructions also update the Carry flag in the APSR. If the shift or rotate operation shifts the register position by multiple bits, the value of the carry flag C will be the last bit that shifts out of the register. You might wonder why there are rotate right instructions but no instructions for rotate left. Actually, a rotate left operation can be replaced by a rotate right operation with a different rotate amount. For example, a rotate left by 4 bits can be written as a rotate right by 28 bits. This gives you the same result in the destination register (note that the C flag will be different from rotate left) and takes same amount of time to execute. To use the 16-bit version of these instructions, the registers used must be low registers (R0-R7), and the S suffix should be used (APSR update). The RRX instruction is not available in 16-bit form.

Data conversion operations (extend and reverse ordering)
	In the Cortex-M3 and Cortex-M4 processors, a number of instructions are available for handling signed and unsigned extensions of data; for example, to convert an 8-bit value to 32-bit, or from 16-bit to 32-bit. The signed and unsigned instructions are available in both 16-bit and 32-bit forms (Table 5.26). The 16-bit form of the instructions can only access low registers (R0 to R7).

	The 32-bit form of these instructions can access high registers, and optionally rotate the input data before the signed extension operations, as shown in Table 5.27. For SXTB/SXTH, the data are sign extended using bit[7]/bit[15] of Rn. With UXTB and UXTH, the value is zero extended to 32-bit. For example, if R0 is 0x55AA8765:
		SXTB R1, R0 ; R1 = 0x00000065
		SXTH R1, R0 ; R1 = 0xFFFF8765
		UXTB R1, R0 ; R1 = 0x00000065
		UXTH R1, R0 ; R1 = 0x00008765
	These instructions are useful for converting between different data types.

	Another group of data conversion operations is used for reversing data bytes in a register, listed in Table 5.28 and illustrated in Figure 5.7. These instructions are usually used for converting data between little endian and big endian. The 16-bit form of these instructions can only access low registers (R0 to R7). REV reverses the byte order in a data word, and REVH reverses the byte order inside a half-word. For example, if R0 is 0x12345678, in executing the following:
		REV R1, R0
		REVH R2, R0
	R1 will become 0x78563412, and R2 will be 0x34127856.

	REVSH is similar to REVH except that it only processes the lower half-word and then sign extends the result. For example, if R0 is 0x33448899, running:
		REVSH R1, R0
	R1 will become 0xFFFF9988

Bit-field processing instructions
	To make the Cortex-M3 and Cortex-M4 processor an excellent architecture for control applications, these processors support a number of bit-field processing operations, as listed in Table 5.29. ( read description and this part from book )

Compare and test
	The compare and test instructions are used to update the flags in the APSR, which may then be used by a conditional branch or conditional execution (this will be covered in the next section). Table 5.30 listed these instructions. Note that these instructions do not have the “S” suffix because the APSR is always updated.
