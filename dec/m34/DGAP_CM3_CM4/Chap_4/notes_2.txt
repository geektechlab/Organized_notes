The APSR contains several groups of status flags ( Table 4.6 ) ( Read boolean arithmetics table 4.7 ):
• Status flags for integer operations (N-Z-C-V bits)
  The integer status flags are very similar to ALU status flags in many other processor architectures. These flags are affected by general data processing instructions, and are essential for controlling conditional branches and conditional executions.
• Status flags for saturation arithmetic (Q bit)
  Q status flag is used to indicate an occurrence of saturation during saturation arithmetic operations or saturation adjustment operations. Saturation arithmetic is useful for digital signal processing. If normal data arithmetic instructions are used, the MSB of the result would be lost and can cause a serious distortion in the output. Instead of just cutting off the MSB, saturation arithmetic forces the result to the maximum value (in case of overflow) or minimum value (in case of underflow) to reduce the impact of signal distortion. In most cases, the instructions for saturation arithmetic are mnemonic starting with “Q,” for example “QADD16.” If saturation occurred, the Q bit is set; otherwise, the value of the Q bit is unchanged ( figure 4.16 ).
• Status flags for SIMD operations (GE bits)
  The “Greater-Equal” (GE) is a 4-bit wide field in the APSR in the Cortex-M4, and is not available in the Cortex-M3 processor. It is updated by a number of SIMD instructions where, in most cases, each bit represents positive or overflow of SIMD operations for each byte (Table 4.8).

The Cortex-M3 and Cortex-M4 processors have the following memory system features:

• 4GB linear address space: With 32-bit addressing, the ARM processors can access up to 4GB of memory space. While many embedded systems do not need more than 1MB of memory, the 32-bit addressing capability ensures future upgrade and expansion possibilities. The Cortex-M3 and Cortex-M4 processors provide 32-bit buses using a generic bus protocol called AHB LITE. The bus allows connections to 32/16/8-bit memory devices with suitable memory interface controllers.

• Architecturally defined memory map: The 4GB memory space is divided into a number of regions for various predefined memory and peripheral uses. This allows the processor design to be optimized for performance. For example, the Cortex-M3 and Cortex-M4 processors have multiple bus interfaces to allow simultaneous access from the CODE region for program code and data operations to SRAM or peripheral regions.

• Support for little endian and big endian memory systems: The Cortex-M4 and Cortex-M4 processors can work with either little endian or big endian memory systems. In practice, a microcontroller product is normally designed with just one endian configuration.

• Bit band accesses (optional): When the bit-band feature is included (determined by microcontroller/System-on-Chip vendors), two 1MB regions in the memory map are bit addressable via two bit-band regions. This allows atomic access to individual bits in SRAM or peripheral address space.

• Write buffer: When a write transfer to a bufferable memory region will take multiple cycles, the transfer can be buffered by the internal write buffer in the Cortex-M3 or Cortex-M4 processor so that the processor can continue to execute the next instruction, if possible. This allows higher program execution speed.

• Memory Protection Unit (Optional): The MPU is a programmable unit which defines access permissions for various memory regions. The MPU in the CortexM3 and Cortex-M4 processor supports eight programmable regions, and can be used with an embedded OS to provide a robust system.

• Unaligned transfer support: All processors supporting ARMv7-M architecture (including Cortex-M3 and Cortex-M4 processors) support unaligned data transfers. The bus interfaces on the Cortex-M processors are generic bus interfaces, and can be connected to different types and sizes of memory via different memory controllers. The memory systems in microcontrollers often contain two or more types of memories: flash memory for program code, static RAM (SRAM) for data, and in some cases Electrical Erasable Read Only Memory (EEPROM). In most cases, these memories are on-chip and the actual memory interface details are transparent to software developers. Hence, software developers only need to know the address and size of the program memory and SRAM.

The 4GB address space of the Cortex-M processors is partitioned into a number of memory regions (Figure 4.18). The partitioning is based on typical usages so that different areas are designed to be used primarily for:
• Program code accesses (e.g., CODE region)
• Data accesses (e.g., SRAM region)
• Peripherals (e.g., Peripheral region)
• Processor’s internal control and debug components (e.g., Private Peripheral Bus)
The architecture also allows high flexibility to allow memory regions to be used for other purposes. For example, programs can be executed from the CODE as well as the SRAM region, and a microcontroller can also integrate SRAM blocks in CODE region. In practice, many microcontroller devices only use a small portion of each region for program flash, SRAM, and peripherals. Some of the regions can be unused. Different microcontrollers have different memory sizes and peripheral address locations. This information is usually outlined in user manuals or datasheets from microcontroller vendors. The memory map arrangement is consistent between all of the Cortex-M processors. For example, the PPB address space hosts the registers for the Nested Vectored Interrupt Controller (NVIC), processor’s configuration registers, as well as registers for debug components. This is the same across all Cortex-M devices. This makes it easier to port software from one Cortex-M device to another, and allows better software reusability.

As in almost all processor architectures, the Cortex-M processors need stack memory to operate and have stack pointers (R13). Stack is a kind of memory usage mechanism that allows a portion of memory to be used as Last-In-First-Out data storage buffer. ARM processors use the main system memory for stack memory operations, and have the PUSH instruction to store data in stack and the POP instruction to retrieve data from stack. The current selected stack pointer is automaticallyadjusted for each PUSH and POP operation.

Stack can be used for:
• Temporary storage of original data when a function being executed needs to use registers (in the register bank) for data processing. The values can be restored at the end of the function so the program that called the function will not lose its data.
• Passing of information to functions or subroutines.
• For storing local variables.
• To hold processor status and register values in the case of exceptions such as an interrupt.
The Cortex-M processors use a stack memory model called “full-descending stack.” When the processor is started, the SP is set to the end of the memory space reserved for stack memory. For each PUSH operation, the processor first decrements the SP, then stores the value in the memory location pointed by SP. During operations, the SP points to the memory location where the last data was pushed to the stack (Figure 4.19, 4.20, 4.21, 4.22). In a POP operation, the value of the memory location pointed by SP is read, and then the value of SP is incremented automatically. Since the registers in the register bank are 32 bits, each memory transfer generated by stack PUSH and stack POP transfers at least 1 word (4 bytes) of data, and the addresses are always aligned to 4-byte boundaries. The lowest two bits of the SP are always zero.

Physically there are two stack pointers in the Cortex-M processors. They are the:
• Main Stack Pointer (MSP) e This is the default stack pointer used after reset, and is used for all exception handlers.
• Process Stack Pointer (PSP) e This is an alternate stack point that can only be used in Thread mode. It is usually used for application tasks in embedded systems running an embedded OS.

After power up, the processor hardware automatically initializes the MSP by reading the vector table. The PSP is not initialized automatically and must be initialized by the software before being used.

The selection between MSP and PSP can be controlled by the value of SPSEL in bit 1 of the CONTROL register (Table 4.3 and Figure 4.10). If this bit is 0, Thread mode uses MSP for the stack operation. Otherwise, Thread mode uses the PSP. In addition, during exception return from Handler mode to Thread mode, the selection can be controlled by the value of EXC_RETURN (exception return) value. In that case the value of SPSEL will be updated by the processor hardware accordingly. After an interrupt event is triggered, the processor first pushes a number of registers into the stack before entering the Interrupt Service Routine (ISR). This register state saving operation is called “Stacking,” and at the end of the ISR, these registers are restored to the register bank and this operation is called “Unstacking.” When embedded systems use an embedded OS, they often use separate memory areas for application stack and the kernel stack. As a result, the PSP is used and switching of SP selection takes place in exception entry and exception exit. This is shown in Figure 4.24. Note that the automatic “Stacking” and “Unstacking” stages use PSP. The separating stack arrangement can prevent a stack corruption or error in an application task from damaging the stack use by the OS. It also simplifies the OS design and hence allows faster context switching. Although only one of the SPs is visible at a time (when using SP or R13 to access it), it is possible to read/write directly to the MSP and PSP, without any confusion over which SP/R13 you are referring to. Provided that you are in privileged level, you can access MSP and PSP using the following CMSIS functions:
	x = __get_MSP(); // Read the value of MSP
	__set_MSP(x); // Set the value of MSP
	x = __get_PSP(); // Read the value of PSP
	__set_PSP(x); // Set the value of PSP
In general it is not recommended to change the value of the current selected SP in a C function, as part of the stack memory could be used for storing local variables or other data. To access MSP and PSP in assembly code, you can use the MSR and MRS instructions:
	MRS R0, MSP ; Read Main Stack Pointer to R0
	MSR MSP, R0 ; Write R0 to Main Stack Pointer
	MRS R0, PSP ; Read Process Stack Pointer to R0
	MSR PSP, R0 ; Write R0 to Process Stack Pointer

Exceptions are events that cause changes to program flow. When one happens, the processor suspends the current executing task and executes a part of the program called the exception handler. After the execution of the exception handler is completed, the processor then resumes normal program execution. In the ARM architecture, interrupts are one type of exception. Interrupts are usually generatedfrom peripheral or external inputs, and in some cases they can be triggered by software. The exception handlers for interrupts are also referred to as Interrupt Service Routines (ISR). The NVIC can handle a number of Interupt Requests (IRQs) and a Non-Maskable Interrupt (NMI) request. Usually IRQs are generated by on-chip peripherals or from external interrupt inputs though I/O ports. Inside the processor there is also a timer called SysTick, which can generate a periodic timer interrupt request, which can be used by embedded OSs for time keeping, or for simple timing control in applications that don’t require an OS. The processor itself is also a source of exception events. These could be fault events that indicate system error conditions, or exceptions generated by software to support embedded OS operations. The exception types are listed in Table 4.9. Each exception source has an exception number. Exception numbers 1 to 15 are classified as system exceptions, and exceptions 16 and above are for interrupts. The design of the NVIC in the Cortex-M3 and Cortex-M4 processors can support up to 240 interrupt inputs. However, in practice the number of interrupt inputs implemented in the design is far less, typically in the range of 16 to 100. In this way the silicon size of the design can be reduced, which also reduces power consumption. The exception number is reflected in various registers, including the IPSR, and it is used to determine the exception vector addresses. Exception vectors are stored in a vector table, and the processor reads this table to determine the starting address of an exception handler during the exception entrance sequence. Note that the exception number definitions are different from interrupt numbers in the CMSIS device-driver library. In the CMSIS device-driver library, interrupt numbers start from 0, and system exception numbers have negative values. As opposed to classic ARM processors such as the ARM7TDMI, there is no FIQ (Fast Interrupt) in the Cortex-M processor. However, the interrupt latency of the Cortex-M3 and Corex-M4 is very low, only 12 clock cycles, so this does not cause problems. Reset is a special kind of exception. When the processor exits from a reset, it executes the reset handler in Thread mode (rather than Handler mode as in other exceptions). Also the exception number in IPSR is read as zero.

The NVIC is a part of the Cortex-M processor. It is programmable and its registers are located in the System Control Space (SCS) of the memory map (see Figure 4.18). The NVIC handles the exceptions and interrupt configurations, prioritization, and interrupt masking. The NVIC has the following features:
• Flexible exception and interrupt management
• Nested exception/interrupt support
• Vectored exception/interrupt entry
• Interrupt masking

Each interrupt (apart from the NMI) can be enabled or disabled and can have its pending status set or cleared by software. The NVIC can handle various types of interrupt sources:
• Pulsed interrupt request: the interrupt request is at least one clock cycle long. When the NVIC receives a pulse at its interruptinput, the pending status is set and held until the interrupt gets serviced.
• Level triggered interrupt request: the interrupt source holds the request high until the interrupt is serviced.
The signal level at the NVIC input is active high. However, the actual external interrupt input on the microcontroller could be designed differently and is converted to an active high signal level by on-chip logic.

Each exception has a priority level. Some exceptions, such as interrupts, have programmable priority levels and some others (e.g., NMI) have a fixed priority level. When an exception occurs, the NVIC will compare the priority level of this exception to the current level. If the new exception has a higher priority, the current running task will be suspended. Some of the registers will be stored on the stack memory, and the processor will start executing the exception handler of the new exception. This process is called “preemption.” When the higher priority exception handler is complete, it is terminated with an exception return operation and the processor automatically restores the registers from stack and resumes the task that was running previously. This mechanism allows nesting of exception services without any software overhead. When an exception occurs, the processor will need to locate the starting point of the corresponding exception handler. Traditionally, in ARM processors such as the ARM7TDMI, software handles this step. The Cortex-M processors automatically locate the starting point of the exception handler from a vector table in the memory. As a result, the delays from the start of the exception to the execution of the exception handlers are reduced.