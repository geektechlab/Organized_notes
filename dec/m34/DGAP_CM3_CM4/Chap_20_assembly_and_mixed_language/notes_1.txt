there are some situations where we may need to use assembly language for some parts of the project:
• To allow direct manipulation of stack memory (e.g., context-switching code in embedded OSs; see section 10.5)
• To optimize for maximum speed/performance or minimum program size for a specific task
• To reuse assembly code from old projects
• To learn about processor architecture

There are various ways to add assembly code to a C project:
• The assembly code could be functions implemented in an assembly file and these functions can then be called from C code.
• The assembly code could be functions implemented within a C file using compiler-specific features (e.g., embedded assembler in ARM toolchain, supported in Keil MDK-ARM, ARM DS-5, and legacy toolchains).
• The assembly code can be instruction sequences inserted inside C code using inline assembler.
• Assembly instructions can be inserted inside C code using intrinsic, or CMSIS-Core functions.
In addition, some compilers also support idiom recognition features that recognize certain C constructs and translate them directly to sequences of one or more assembly instructions.

( very important: Table 20.1 Simple Parameter Passing and Returning Value in a Function Call )

This is specified by an ARM document called the Procedure Call Standard for the ARM Architecture (AAPCS, reference 8). AAPCS covers the following areas:
• Register usage in function calls: A function or a subroutine should retain the values in R4eR11, R13, R14 (and S16eS31 for Cortex-M4 with FPU). If these registers are changed during the function or the subroutine, the values should be saved on to the stack and be restored before return to the calling code.
• Parameters and return result passing: For simple cases, input parameters can be passed to a function using R0 (first parameter), R1 (second parameter), R2 (third parameter), and R3 (fourth parameter). In the case of Cortex-M4 with FPU, S0-S15 can also be used depending on the type of ABI selected (see section 13.4.4). Usually the return value of a function is stored in R0. If more than four parameters need to be passed to a function, the stack will be used (details can be found in AAPCS).
• Stack alignment: If an assembly function needs to call a C function, it should ensure that the currently selected stack pointer points to a doubleword aligned address location (e.g., 0x20002000, 0x20002008, 0x20002010, etc.). This is a requirement of the EABI standard. Program code generated from an EABI-compliant C compiler can assume that the stack pointer is pointing to a double-word aligned location. If the assembly code does not call any C functions (either directly or indirectly), this is not strictly required.

When developing assembly functions to be called from C code, we need to make sure the contents of the “callee saved registers” are not changed. If these registers are used, their contents need to be pushed on to the stack and restored at the end of the function. Similarly, assembly code calling a C function should ensure that the contents of the “caller saved registers” are saved before the function call because these registers could be changed by the function (Table 20.2). We also need to be careful with the double-word stack alignment requirement.

( very important: Table 20.2 Register Usages and Requirements in Function Calls )

( important: 20.3 Structure of an assembly function )

In general, the structure of a function can be divided into the following stages:
• Prolog (saving register contents to the stack memory if necessary)
• Allocate stack space memory for local variables (decrement SP)
• Copy some of R0 to R3 (input parameters) to high registers (R8eR12) for later use (optional)
• Carry out processing/calculation
• Store result in R0 if a result is to be returned
• Stack adjustment to free space for local variables (increment SP)
• Epilog (restore register values from stack)
• Return

Most of these steps are optional; for example, prolog and epilog are not required if the function does not corrupt the contents in R4 to R11. The stack adjustments are also not required if there are sufficient registers for the processing. If the function calls another assembly or C function, the values in registers R0 to R3 and R12 could be changed by the called function. So unless you are certain that the function being called will not change these registers, you need to save the contents of these registers if they will be used later. Alternatively you might need to avoid using these registers for the data processing in your function.
