MPU registers

	The MPU contains a number of registers. These registers are located in the System Control Space (SCS). 

MPU type register
	The first one is the MPU Type register. The MPU Type register can be used to determine whether the MPU is fitted. If the DREGION field is read as 0, the MPU is not implemented (Table 11.2).

MPU control register
	The MPU is controlled by a number of registers. The first one is the MPU Control register (Table 11.3). This register has three control bits. After reset, the value of this register is zero, which disables the MPU. To enable the MPU, the software should first set up the settings for each MPU region, and then set the ENABLE bit in the MPU Control register.

	The PRIVDEFENA bit in the MPU Control Register is used to enable the background region (region -1). By using PRIVDEFENA and if no other regions are set up, privileged programs will be able to access all memory locations, and only unprivileged programs will be blocked. However, if other MPU regions are programmed and enabled, they can override the background region. For example, for two systems with similar region setups but only one with PRIVDEFENA set to 1 (the right-hand side in Figure 11.1), the one with PRIVDEFENA set to 1 will allow privileged access to background regions.

	The HFNMIENA is used to define the behavior of the MPU during execution of NMI, HardFault handlers, or when FAULTMASK is set. By default, the MPU is bypassed (disabled) in these cases. This allows the HardFault handler and the NMI handler to execute even if the MPU was set up incorrectly. Setting the enable bit in the MPU Control register is usually the last step in the MPU setup code. Otherwise, the MPU might generate faults accidentally before the region configuration is done. In many cases, especially in embedded OSs with dynamic MPU configurations, the MPU should be disabled at the start of the MPU configuration routine to make sure that the MemManage fault won’t be triggered by accident during configuration of MPU regions.

	Setting the enable bit in the MPU Control register is usually the last step in the MPU setup code. Otherwise, the MPU might generate faults accidentally before the region configuration is done. In many cases, especially in embedded OSs with dynamic MPU configurations, the MPU should be disabled at the start of the MPU configuration routine to make sure that the MemManage fault won’t  be triggered by accident during configuration of MPU regions.

MPU region number register
	The next MPU control register is the MPU Region Number register (Table 11.4). Before each region is set up, write to this register to select the region to be programmed.

MPU region base address register
	The starting address of each region is defined by the MPU Region Base Address register (Table 11.5). Using the VALID and REGION fields in this register, we can skip the step of programming the MPU Region Number register. This can reduce the complexity of the program code, especially if the whole MPU setup is defined in a lookup table.

MPU region base attribute and size register
	We also need to define the properties of each region. This is controlled by the MPU Region Base Attribute and Size register (Table 11.6). The REGION SIZE field (5 bits) in the MPU Region Base Attribute and Size register determines the size of the region (Table 11.7). The sub-region disable field (bit [15:8] of the MPU Region Base Attribute and Size register) is used to divide a region into eight equal sub-regions and then to define each as enabled or disabled. If a sub-region is disabled and overlaps another region, the access rules for the other region are applied. If the sub-region is disabled and does not overlap any other region, access to this memory range will result in a MemManage fault. Sub-regions cannot be used if the region size is 128 bytes or less. The data Access Permission (AP) field (bit [26:24]) defines the AP of the region (Table 11.8). The XN (Execute Never) field (bit [28]) decides whether an instruction fetch from this region is allowed. When this field is set to 1, all instructions fetched from this region will generate a MemManage fault when they enter the execution stage. The TEX (Type extension), S (Shareable), B (Bufferable), and C (Cacheable) fields (bit [21:16]) are more complex. These memory attributes are exported to the bus system together with each instruction and data access, and the information can be used by the bus system such as write buffers or cache units, as shown in Figure 11.2.

Although the Cortex-M3 and Cortex-M4 processors do not include cache controllers, their implementations follow the ARMv7-M architecture, which can support external cache controllers on the system bus level, including advanced memory systems with caching capabilities. In  addition, there is a write buffer in the processor’s internal bus system, which is affected by the bufferable attribute. Therefore, the region access properties TEX, S, B, and C fields should to be programmed correctly to support different types of memory or devices. The definitions of these bit fields are shown in Table 11.9. However, in many microcontrollers, these memory attributes are not used by the bus system and only the B (Bufferable) attribute affects the write buffer in the processor. The memory attribute settings can support two cache levels: inner cache and outer cache. They can have different caching policies. If a system-level cache is implemented, it can either be using the inner cache attribute or the outer cache attribute. This is device-specific and therefore you need to refer to the documentation from silicon vendors regarding suitable settings. In most cases, the memory attributes can be configured as shown in Table  11.10, with the same attributes on both levels.

In the cases where you need to have different inner and outer cache policies, you need to set the bit 2 of TEX to 1. In this case, the definition of TEX[1:0] will become the outer policy (indicated as BB in Table 11.9), and the C and B bits will become the inner policy  (indicated as AA in Table 11.9). The definitions of the cache policy setting (AA and BB) are shown in Table 11.11. If you are using a microcontroller with cache memory, and if you are using the MPU to define access permissions in your application, then you should also make sure that the memory attribute settings match the memory type and the cache policy you want to use (e.g., cache disable,  write-through cache, or write-back cache). The shareable attribute is important for a multi-processor system with caches. In these systems, if a transfer is marked as shareable, then the cache system might need  to do extra work to ensure data coherency between the different processors (Figure 6.16). In single processor systems, the shareable attribute is normally not used.

The remaining registers (MPU->RBAR_Ax and MPU->RASR_Ax) are alias addresses locations. When these addresses are accessed they are just accessing  MPU->RBAR or MPU->RASR. The reason for having these register aliases is to allow multiple MPU regions to be programmed in one go; for example, by using the store-multiple (STM) instruction.
