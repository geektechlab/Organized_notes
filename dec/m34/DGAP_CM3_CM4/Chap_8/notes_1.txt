with the Cortex-M processor, you can program your exception handlers or Interrupt Service Routines (ISR) as normal C routines/functions. In order to understand the exact mechanism to support this, we first look at how C functions work on ARM architecture. C compilers for ARM architecture follow a specification from ARM called the AAPCS, Procedure Call Standard for ARM Architecture (reference 13). According to this standard, a C function can modify R0 to R3, R12, R14 (LR), and PSR. If the C function needs to use R4 to R11, it should save these registers on to the stack memory and restore them before the end of the function (see Figure 8.1).

R0-R3, R12, LR, and PSR are called “caller saved registers.” The program code that calls a subroutine needs to save these register contents into memory (e.g., stack) before the function call if these values will still be needed after the function call. Register values that are not required after the function call don’t have to be saved.

R4- R11 are called “callee-saved registers.” The subroutine or function being called needs to make sure the contents of these registers are unaltered at the end of the function (same value as when the function is entered). The values of these registers could change in the middle of the function execution, but need to be restored to their original values before function exit.

Typically, a function call uses R0 to R3 as input parameters, and R0 as the return result. If the return value is 64 bits, R1 will also be used as the return result (see Figure 8.1)

Similar requirements apply to the registers in the floating point unit if the processor used is a Cortex-M4 with floating point support: S0eS15 are “caller saved registers.” S16eS31 are “callee-saved registers.”

In order to allow a C function to be used as an exception handler, the exception mechanism needs to save R0 to R3, R12, LR, and PSR at exception entrance automatically, and restore them at exception exit under the control of the processor’s hardware. In this way when returned to the interrupted program, all the registers would have the same value as when the interrupt entry sequence started. In addition, since the value of the return address (PC) is not stored in LR as in normal C function calls (the exception mechanism puts an EXC_RETURN code in LR at exception entry, which is used in exception return), the value of the return address also needs to be saved by the exception sequence. So in total eight registers need to be saved during the exception handling sequence on the Cortex-M3 or Cortex-M4 processors without a floating point unit.

For the Cortex-M4 processor with floating point unit, the exception mechanism also needs to save S0eS15 and FPSCR if the floating point unit is used. This is indicated by a bit in the CONTROL register called FPCA (Floating Point Context Active).

The block of data that are pushed to the stack memory at exception entrance is called a stack frame. For the Cortex-M3 processor or Cortex-M4 processor without the floating point unit, the stack frames are always eight words (Figure 8.2 and Figure 8.3). For the Cortex-M4 with floating point unit, the stack frame can either be 8 or 26 words.

Another requirement of the AAPCS is that the stack pointer value should be double-word aligned at function entry or exit boundary. As a result, the Cortex-M3 and Cortex-M4 processors can insert an additional word of padding space in the stack automatically if the stack pointer was not aligned to double-word location when the interrupt happened. In this way, we can guarantee that the stack pointer will be at the beginning of the exception handler. This “double-word stack alignment” feature is programmable, and can be turned off if the exception handlers do not need full AAPCS compliance.

The bit 9 of the stacked xPSR is used to indicate if the value of the stack pointer has been adjusted. In Figure 8.2, the stack pointer was aligned to double-word address location, so no padding was inserted and bit 9 of the stack xPSR is set to 0. The same stack frame behavior can also be found when the double-word stack alignment feature is turned off, even if the value of stack pointer wasn’t aligned to double-word boundary.

If the double-word stack alignment feature was enabled, and the value of the stack pointer was not aligned to double-word boundary, a padding spaces is inserted to the stack to force the stack pointer to be aligned to double-word location, and bit 9 of the stacked xPSR is set to 1, to indicate the present of the padding space, as shown in Figure 8.3. The bit 9 of the stacked xPSR is used in the exception exit sequence to decide whether the value of SP has to be adjusted to remove the padding. For Cortex-M4 with floating point unit, if the floating point unit has been enabled and used, the stack frame will include S0 to S15 of the registers in the floating point unit register bank, as shown in Figure 8.4.

The values of general-purposed registers R0-R3 are located at the bottom of the stack frame. They can be accessed easily using SP-related addressing. In some cases these stacked registers can be used to pass information to software triggered interrupt handlers or SVC services. The double workd stack alignment feature is enabled by a control bit in the Configuration Control Register (CCR, address 0xE000ED14) in the System Control Block (SCB). You can enable this feature during the initialization stage by the following C program code:
	SCB->CCR j= SCB_CCR_STKALIGN_Msk; // Set STKALIGN bit (bit 9) of CCR
The double-word stack alignment is:
• Enabled by default in the Cortex-M4 processor

It is highly recommended to enable this feature, although it can result in slightly larger stack memory space usage. The bit should not be changed inside exception handlers.
