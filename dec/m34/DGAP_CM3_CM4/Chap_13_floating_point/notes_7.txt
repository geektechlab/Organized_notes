By default, the FPU in the Cortex-M4 is already compliant with the IEEE 754 requirements. In most cases there is no need to change the mode settings. If you need to use any of these modes in your application, typically you need to program the FPSCR and the FPDSCR. Otherwise the exception handlers could be using the default IEEE 754 behavior while the rest of the applications use other modes, resulting in inconsistency.

Flush-to-Zero mode
Flush-to-Zero mode allows some floating point calculations to be faster by avoiding the need to calculate results in the denormalized value range (exponent ¼ 0). When the value is too small to be represented by the normalized value range (0 < exponent < 0xFF), the value is replaced with zero. Flush-to-Zero mode is enabled by setting the FZ bit in FPSCR and FPDSCR.

Default NaN mode
In default NaN (Not a Number) mode, if any of the inputs of a calculation is a NaN, or if the operation results in an invalid result, the calculation returns the default NaN (a non-signaling NaN, or quiet NaN). This is slightly different from the default configuration. By default, the default NaN mode is disabled and the behavior follows the IEEE 754 standard:
• An operation that produces an Invalid Operation floating point exception generates a quiet NaN as its result
• An operation involving a quiet NaN operand, but not a signaling NaN operand, returns an input NaN as its resultThe default NaN mode is enabled by setting DN bit in FPSCR and FPDSCR. In some cases it enables quicker checking of NaN values in calculation results.

Alternate half-precision mode
This mode only affects applications with half-precision data __fp16 (see section 13.1.3). By default, the FPU follows the IEEE 754 standard. If the exponent of the half-precision floating point data is 0x1F, the value is infinity or NaN. In the alternate half-precision mode, the value is a normalized value. The alternate half precision mode allows a wider value range, but does not support infinity and NaN. The alternate half-precision mode can be enabled by setting the AHP bit in FPSCR and FPDSCR. To use half-precision data, you also need to set up your compiler command line options accordingly, as shown in Table 13.12.

Rounding modes
The FPU supports four rounding modes as defined in the IEEE 754 standard. You can change the rounding mode at run-time. In C99, the fenv.h defines the four available modes, as listed in Table 13.13. You can use these definitions with C99 functions defined in fenv.h:
• int fegetround (void) e return the currently selected rounding mode, represented by one of the values of the defined rounding mode macros
• int fesetround(int round) e change the currently selected rounding mode. fesetround() returns zero if the change is successful, and nonzero if the change is not successful.
You should use these C library functions when adjusting the rounding mode to ensure that the C run-time library functions are adjusted in the same way as the FPU.

In section 13.2.5 and Table 13.4 we came across some floating point exception status bits. Here the term exception is not the same as the exceptions or interrupts in the NVIC. The floating point exceptions refer to issues in floating point processing. IEEE 754 defines the exceptions given in Table 13.14. In addition to this, the FPU in the Cortex-M4 also supports an additional exception for “Input Denormal” as given in Table 13.15. The FPSCR provides six sticky bits so software code can check these values to see if the calculations were carried out successfully. In most cases these flags are ignored by software (compiler-generated code does not check these values).

If you are designing software with high safety requirements, you could add checking to FPSCR. However, in some cases not all floating point calculations are carried out by the FPU. Some could be carried out by the C run-time library function. For detailed information on these functions, please refer to C99 documentation or manuals from toolchain vendors.

In the Cortex-M4 hardware design, these exception status bits are also exported to the top level of the processor. Potentially these signals can be used to trigger an exception at the NVIC, as shown in Figure 13.26. However, since the interrupt events are imprecise, the generated exception could be delayed by a few cycles even if the exception is not blocked. As a result, you cannot determine which floating point instruction triggered the exception. If the processor was executing a higher priority interrupt handler, the interrupt handler for the floating point exception cannot start until the other interrupt handler is completed. However, this mechanism could be used in some systems that need to detect error conditions like divide-by-zero or overflow instantaneously. When the FPU exception status is used to trigger exceptions at NVIC, please note that the exception handler needs to clear the exception status bits in FPSCR, as well as the stacked FPSCR before exception return. Otherwise the exception could be triggered again accidentally.

Lazy stacking might add a bit of complexity to debugging. When the processor is halted in an exception handler, the stack frame might not contain the contents of the floating point registers. And when you single-step your code and the processor executes a floating point instruction, the deferred stacking will then take place.
