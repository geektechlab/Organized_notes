Double-precision floating point numbers
	Although the floating point unit in Cortex-M4 does not support double-precision floating point operations, you can still have double-precision data in your applications. In such cases the C compiler and linker will insert the appropriate run-time library functions to handle these calculations. The double-precision data format is shown in Figure 13.8. In a little endian memory system, the least significant word is stored in the lower address of a 64-bit address location, and the most significant word is stored in the upper address. In a big endian memory system it is the other way round. When 0 < Exponent < 0x7FF, the value is a normalized value, and the value of the double-precision value is represented by the equation in Figure 13.9. If the exponent value is 0, then there are several possibilities:
	• If Fraction is equal to 0 and Sign bit is also 0, then it is a zero (þ0) value.
	• If Fraction is equal to 0 and Sign bit is 1, then it is a zero (0) value. Usually þ0 and 0 behave in the same way in operations. In a few cases, for example, when a divide-by-zero happens, the sign of the infinity result would be dependent on whether the divider is þ0 or 0.
	• If Fraction is not 0, then it is a denormalized value. It is a very small value between (2^(1022)) and (2^(1022)). The value of a denormalized value can be represented by the equation in Figure 13.10. If the exponent value is 0x7FF, there are also several possibilities:
	• If Fraction is equal to 0 and Sign bit is also 0, then it is an infinity (þN) value.
	• If Fraction is equal to 0 and Sign bit is 1, then it is a minus infinity (N) value.
	• If Fraction is not 0, then it is a NaN (Not a Number).
	There are two types of NaN:
	• If bit 51 of the Fraction is 0, it is a signaling NaN. The rest of the bit in the Fraction can be any value apart from all 0.
	• If bit 51 of the Fraction is 1, it is a quiet NaN. The rest of the bit in the Fraction can be any value.

The Cortex-M4 processor has the option of including a single-precision floating point unit. If the floating pointing unit is available, you can use it to accelerate single-precision floating point operations. Double-precision calculation still needs to be handled by C run-time library functions.

Even if the floating point unit is available and the operation is single precision, you might still need run-time library functions, for example, when dealing with functions like sinf(), cosf(), etc. These functions require a sequence of calculations and cannot be done by single instruction or a few instructions. In all well-established toolchains you can compile an application and select NOT to use the floating point unit. This allows the compiled code to be used on another Cortex-M4 microcontroller product that does not have floating point unit support.

For Cortex-M4 microcontrollers without a floating point unit, or microcontrollers with Cortex-M3, Cortex-M0, Cortex-M0þ processors, or FPGAwith Cortex-M1 processors, there is no floating point unit support and all floating point calculations have to be carried out using run-time library functions.

Alternatively, a software developer can use fixed point data. Fundamentally fixed point operations are just like integer operations but with additional shift adjustment operations. While this is faster than using floating point run-time library functions, it can only handle limited data ranges because the exponent is fixed. ARM has an application note (reference 33) on creating fixed point arithmetic  operations in ARM architecture.
