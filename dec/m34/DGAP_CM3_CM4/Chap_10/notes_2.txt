PendSV (Pended Service Call) is another exception type that is important for supporting OS operations. It is exception type 14 and has a programmable priority level. The PendSV Exception is triggered by setting its pending status by writing to the Interrupt Control and State Register (ICSR). Unlike the SVC exception, it is not precise. So its pending status can be set inside a higher priority exception handler and executed when the higher-priority handler finishes. Using this characteristic, we can schedule the PendSV exception handler to be executed after all other interrupt processing tasks are done, by making sure that the PendSV has the lowest exception priority level. This  is very useful for a context-switching operation, which is a key operation in various OS designs.

In a typical system with an embedded OS, the processing time is divided into a number of time slots. For a system with only two tasks, the two tasks are executed alternatively, as shown in Figure 10.6. The execution of an OS kernel can be triggered by:
• Execution of SVC instruction from application tasks. For example, when an application task is stalled because it is waiting for some data or event, it can call a system service to swap in another task.
• Periodic SysTick exception.

Inside the OS code, the task scheduler can decide if context switching should be carried out. The operations shown in Figure 10.6 assume that the OS kernel execution is triggered by a SysTick exception, and each time it decides to switch to a different task. If an interrupt request (IRQ) takes place before the SysTick exception, the SysTick exception might preempt the IRQ handler. In this case, the OS should not carry out the context switching. Otherwise, the IRQ handler process will be delayed (Figure 10.7). And for the Cortex-M4 processor, by default the design does not allow return to Thread mode when there is an active interrupt service (but there is an exception e see Non-base Thread Enable description in section 23.5). If the OS attempts to return to the Thread mode with an active interrupt service running, it triggers a Usage fault exception. In some OS designs, this problem is solved by not carrying out context switching if an interrupt service is running. This can easily be done by checking the stacked xPSR from the stack frame, or checking the interrupt active status registers in the NVIC (see section 7.8.4). However, this might affect the performance of the system, especially when an interrupt source keeps generating requests around the SysTick triggering time, which can prevent context switching from happening.

The PendSV exception solves the problem by delaying the context-switching request until all other IRQ handlers have completed their processing. To do this, the PendSV is programmed as the lowest-priority exception. If the OS decides that context switching is needed, it  sets the pending status of the PendSV, and carries out the context switching within the PendSV exception, as shown in Figure 10.8 show an example sequence of context switching using PendSV with the following event sequence. Figure 10.8 show an example sequence of context switching using PendSV with the following event sequence:
1. Task A calls SVC for task switching (for example, waiting for some work to complete).
2. The OS receives the request, prepares for context switching, and pends the PendSV exception.
3. When the CPU exits SVC, it enters PendSV immediately and does the context switch.
4. When PendSV finishes and returns to Thread level, it executes Task B.
5. An interrupt occurs and the interrupt handler is entered.
6. While running the interrupt handler routine, a SYSTICK exception (for OS tick) takes place.
7. The OS carries out the essential operation, then pends the PendSV exception and gets ready for the context switch.
8. When the SYSTICK exception exits, it returns to the interrupt service routine.
9. When the interrupt service routine completes, the PendSV starts and does the actual context-switch operations.
10. When PendSV is complete, the program returns to Thread level; this time it returns to Task A and continues the processing.

Besides context switching in an OS environment, PendSV can also be used in systems without an OS. For example, an interrupt service can need a fair amount of time to process. The first portion of the processing might need a high priority, but if the whole ISR is executed with a high priority level, other interrupt services would be blocked out for a long time. In such cases, we can partition the interrupt service processing into two halves (Figure 10.9):
• The first half is the time-critical part that needs to be executed quickly with high priority. It is put inside the normal ISR. At the end of the ISR, it sets the pending status of the PendSV.
• The second half contains the remaining processing work needed for the interrupt service. It is placed inside the PendSV handler and is  executed with low exception priority/.
